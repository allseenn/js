# JavaScript Basics

This repo contains my JS code from lectures and labs by GeekBrains online university.

## 01. Lecture

### Intro

01.Lecture

**HTML** - язык разметки для веб-страниц

**CSS** - язык оформления HTML

**JS** - язык программирования

Этапы выполнения JS-скриптов:

1. Engine (движок)
    - parsing - анализатор лексики и синтаксиса
    - interpreter - интерпретатор в байт-код
    - JIT-compiler - компилятор в машинный код
    - garbage collector - сборщик мусора
2. Runtime (среда выполнения)
    - context - контекст выполнения
    - event loop - цикл событий
        - call stack - стек вызовов
        - callback queue - очередь отложенных задач
    - API - дополнительные функциональные возможности
        - DOM API - взаимодействие с DOM
        - CSSOM API - взаимодействие с CSSOM
        - Storage API - взаимодействие с хранилищем
        - Network API - взаимодействие с сетью
        - WebSockets API - взаимодействие с веб-сокетами
        - Crypto API - взаимодействие с криптографической библиотекой
        - Media API - взаимодействие с мультимедиа
        - Geolocation API - взаимодействие с геолокацией

### Движки

Список популярных движков:

- V8
- Rhino
- SpiderMonkey
- JSC
- Chakra

Движки как правило написаны на С\C++

### Среды выполнения

- Браузеры
- Node.js, Electron, React Native, Deno
- ПО для встраиваемых систем (роботы, Falcon 9, Iskra)

Среды выполнения могут содержать не только JS, но и html, css, json, xml движки в случае браузера:

- HTML Parser → DOM tree
- CSS Parser → CSSOM  
- Rendering Engine → Отображение
- Network Stack → Запросы
- JavaScript Engine (V8) → при необходимости

Среды взаимодействуют с API ОС:

- Браузер установленный на десктопные OC (Windows, Linux, macOS)
- Node.js, Electron, etc установленные на серверные OC (Windows, Linux, FreeBSD, macOS)
- Киоски (банкоматы, терминалы оплаты и т.д.) - легкая версия ОС с браузером

### Стандарты

ECMA international - European Computer Manufacturers Association - Европейская ассоциация по стандартизации компьютерного производства.

Наиболее известные стандарты ECMA Inc.:

- ECMA-376 (OOXML) - Office Open XML
- ECMA-119 (ISO9660) - формат CD-ROM и DVD-ROM
- ECMA-267 (UDF) - перезаписываемый формат CD-ROM и DVD-ROM
- ECMA-262 (ECMAScript) - язык программирования JavaScript

ECMAScript состоит из релизов:

- ...
- ES5
- ES6
- ES2022
- ES6+ - современный JS

### Этапы загрузки страницы в браузере

1. Создается структура HTML-документа
2. Применяются стили
3. Добавляется контент (картинки, мультимедиа)
4. К странице подключается скрипт и выполняется

Браузер начинает выполнять JS-код в момент обнаружения его в html, поэтому рекомендуется помещать его в конце документа. Либо использовать специальные атрибуты.
Если произошла ошибка в коде, то браузер выдает сообщение в консоли, но продолжает загрузку контента, html и дальнейшего JS-кода.
Код выполнятся даже после того как все загрузилось, все время пока страница открыта.

### Операторы

#### Унарные операторы

- `-a` - Унарный минус (отрицательное число)
- `+a` - Унарный плюс  (приведение к числу)
- `a++` - Инкремент
- `a--` - Декремент
- `~a` - Побитовое отрицание
- `^a` - Побитовая инверсия (исключающее или)
- `!a` - Логическое отрицание
- `&a` - Побитовое И
- `|a` - Побитовое ИЛИ
- `<<a` - Побитовый сдвиг влево
- `>>a` - Побитовый сдвиг вправо
- `a.b` - Оператор доступа к свойству объекта (точка)
- `...a`- rest или spread операторы
- `a, b -` Оператор разделения элементов или вычисления выражений
- void - оператор пустого значения - возвращает undefined
- new - оператор создания объекта
- typeof - оператор получение типа объекта
- delete - удаление и возврат true, false в случае успеха, неуспеха

#### Бинарные операторы

- `a + b` - Сложение
- `a - b` - Вычитание
- `a * b` - Умножение
- `a / b` - Деление
- `a % b` - Остаток от деления (модуль)
- `a = b` - Оператор присваивания
- `a?.b` - Оператор опциональной цепочки
- `a ** b` - Возведение в степень
- `'a'+'b'`- Конкатенация
- `a && b` - Логическое И
- `a || b` - Логическое ИЛИ
- `a ^ b` - Исключающее ИЛИ
- `a in b` - Проверка наличия свойства в объекте
- `a of b` - В циклах for..of
- `a ?? b` - Нулевое слияние (Nullish Coalescing Operator) - удобен для задания значений по умолчанию. В нем берется правая часть, если слева null или undefined
- `a == b` - Сравнение по значению
- `a === b` - Сравнение по значению и типу
- `a != b` - Сравнение по значению
- `a !== b` - Сравнение по значению и типу
- `a > b` - Сравнение по значению
- `a < b` - Сравнение по значению
- `a >= b` - Сравнение по значению
- `a <= b` - Сравнение по значению

##### Оператор опциональной цепочки

Опциональная цепочка применяется для методов объектов, которые в определённый момент времени могут быть undefined или null. Часто используется в асинхронных операциях.

Предположим мы ожидаем по сети объект вида:

```js
const obj = {
    key: 'value'
};
```

Пока данные не поступили при обращении к obj будет возвращаться undefined, а при обращении к свойству key будет возвращаться ошибка:

```js
console.log(obj.key); // Uncaught TypeError: Cannot read properties of undefined (reading 'key')
```

Из-за ошибки программа остановится, нужно отлавливать и отрабатывать данную ситуацию, наиболее простым способом является использование опциональной цепочки:

```js
console.log(obj?.key); // undefined
```

Никакой ошибки выдано не будет, нам просто вернётся значение undefined без лишних нагромождений условных операторов и без ловли исключений.

##### Оператор нулевого слияния

В ES2020 был добавлен оператор нулевого слияния:

```js
let a = null;
let b = "значение по умолчанию";

console.log(a ?? b); // значение по умолчанию

a = "значение";
console.log(a ?? b); // значение
```

Цепочка из операторов слияния

```js
let a = null;
let b = undefined;

console.log(a ?? b ?? "значение по умолчанию"); // значение по умолчанию
```

Синтаксический сахар:

```js
let result = (a === null || a === undefined) ? b : a;
```

Если `a` равно `null` или `undefined`, то `result` будет равен `b`, иначе `a`.

#### Тернарный оператор

- `a ? b : c`

Операторы сравнения, тернарный оператор,  возвращают булево значение: true, false

### Приоритет операторов

| Приоритет | Оператор | Описание |
| --- | --- | --- |
| 1 | `()` | Группировка выражений |
| 2 | `.` `[]` | Доступ к свойствам и индексам |
| 3 | `new` | Создание объектов |
| 4 | `++` `--` | Инкремент и декремент |
| 5 | `!` `~` `+` `-` `typeof` `void` | Унарные операторы |
| 6 | `*` `/` `%` | Умножение, деление и остаток |
| 7 | `+` `-` | Сложение и вычитание |
| 8 | `<<` `>>` `>>>` | Битовые сдвиги |
| 9 | `<` `<=` `>` `>=` | Сравнения |
| 10 | `==` `!=` `===` `!==` | Проверка равенства |
| 11 | `&` | Битовая операция И |
| 12 | `^` | Битовая операция XOR |
| 13 | `\|` | Битовая операция ИЛИ |
| 14 | `&&` | Логическое И |
| 15 | `\|\|` | Логическое ИЛИ |
| 16 | `?:` | Условный оператор |
| 17 | `=` `+=` `-=` `*=` `/=` `%=` `**=` | Присваивание |
| 18 | `,` | Запятая (разделитель выражений) |

### Переменные

При объявлении переменных используются следующие ключевые слова:

- let с ES2015
- const c ES205
- var

#### let

Используется для объявления переменных с блочной областью видимости:

```js
let age = 10;

if (true) {
    let age = 20;
    console.log(age); // 20
}

console.log(age); // 10
```

**let** можно переопределять, но не переобъявлять:

```js
let age = 10;
age = 20;
console.log(age); // 20

let age = 30; // SyntaxError
```

#### const

Используется для объявления констант с блочной областью видимости их нельзя изменять

```js
const GAP_SIZE = 10;
GAP_SIZE = 15; // TypeError
```

Часто используется для инициализации изменяемых типов данных (массивы, объекты):

```js
const arr = [1, 2, 3];
const obj = {name: "Ivan", age: 10};

arr = 4 // TypeError: Assignment to constant variable. 
obj = "hello" // TypeError: Assignment to constant variable. 
```

где, используется для защиты от случайного затирания с помощью других типов данных.

#### var

До ES5 с помощью ключевого слова **var** инициализировали переменные. В современных релизах javascript ключевое слово **var** осталась, но используется немного по другому:

1. Для объявления глобальных переменных.
2. Для инициализации переменной без присвоения значения:

```js
var a;
```

Значением переменной **a** будет **undefined**.

var имеет область видимости в пределах функций:

```js
function test() {
    if (true) {
        var a = 10;
        console.log(a); // 10
    }
    console.log(a); // 10
}
```

Т.е. переменная **a** видна внутри функций и за пределами блока if, что не работает с let и const.

Переменную типа var можно переобъявить:

```js
var a = 10;
var a = 20;
console.log(a); // 20
```

При объявлении переменной **a** с помощью var, значение **a** будет являться свойством глобального объекта **window** или **global** в Node.js, что позволять создавать глобальные переменные даже вне текущего модуля.

Переменную типа var можно переобъявить:

```js
var a = 10;
var a = 20;
console.log(a); // 20
```

Переобъявление **var** работает благодаря **hoisting**.

### Всплытие

**Hoisting** (всплытие) - уникальный механизм JS, позволяющий обращаться к значению переменной до ее объявления с помощью **var**. Значением при всплытии такой переменной будет undefined.

```js
console.log(age); // undefined
var brotherAge = age + 12
console.log(brotherAge) // Nan
var age = 10

console.log(name)
let name = "Ivan" // Uncaught ReferenceError
```

### Типы данных

В JS есть 8 типов данных:

1. string (строка) - неизменяемый примитив
2. number (число) - неизменяемый примитив
    - Infinity (бесконечность)
    - NaN (Not A Number)
3. bigInt (большое число) - неизменяемый примитив
4. boolean (булев) - неизменяемый примитив
    - true
    - false
5. symbol (символьный) - неизменяемый примитив
6. undefined (неопределенный) - неизменяемый примитив
7. null (нуль) - неизменяемый примитив, но при проверке указывает на то, что это объект
8. object (объект) - изменяемые типы данных
   - array (массив)
   - function (функция)

Примитивные типы данных в JavaScript не являются объектами и не имеют методов или свойств. Однако, когда вы пытаетесь использовать метод или свойство примитивного типа данных, JavaScript автоматически оборачивает его в одноименный объект, чтобы предоставить доступ к методам и свойствам.
Например, когда вы пытаетесь использовать метод toUpperCase() на строке, JavaScript оборачивает строку в объект String и предоставляет доступ к методу toUpperCase().

Для определения типа данных используют typeof:

```js
console.log(typeof 10); // number
```

Все типы данных отличаются:

- встроенными методами
- методами сравнения

#### 1. string

Строка это текст в кавычках (одинарных, двойных или обратных):

```js
let name = "Ivan";
let lastName = 'Petrov';
let fullName = `Ivan Petrov`;
```

##### Шаблонный литерал

Строки внутри обратных кавычек называют **шаблонным литералом**

#### 2. number

**Number** - это целое или дробное число, как в десятичной так и в других системах счисления, включая шестнадцатеричную. Для чисел есть ограничения от -2^53 до 2^53 не включительно.

```js
let целоеЧисло = 42;
let дробноеЧисло = 3.14;
let двоичноеЧисло = 0b1010;
let восьмеричноеЧисло1 = 0o12;
let восьмеричноеЧисло2 = 0o12;
let шестнадцатеричноеЧисло = 0xA;
let экспоненциальноеЧисло = 1.5e2;
```

Есть специальны значения, которые также имеют тип **number**:

- Infinity
- -Infinity
- NaN

##### Infinity

Infinity, это число, которе получается в математических операциях, типа деления на ноль.

```js
10 / 0 // Infinity
```

##### NaN

NaN поглощает арифметические операции, которые не могут быть выполнены, например операция нат разными типами данных.

```js
5 - '5' // NaN
```

Tип **number** имеет встроенные методы

##### toFixed

```js
let number = 10.123456789;
console.log(number.toFixed(2)); // 10.12
```

##### toExponential

```js
let number = 10.123456789;
console.log(number.toExponential(2)); // 1.01e+1
```

##### toLocaleString

```js
let number = 10.123456789;
console.log(number.toLocaleString()); // 10.123457
```

##### toPrecision

```js
let number = 10.123456789;
console.log(number.toPrecision(2)); // 10.1
```

##### toString

```js
let number = 10.123456789;
console.log(number.toString()); // 10.123456789
```

##### valueOf

```js
let number = 10.123456789;
console.log(number.valueOf()); // 10.123456789
```

##### isFinite

```js
let number = 10.123456789;
console.log(isFinite(number)); // true
```

##### isNaN

```js
let number = 10.123456789;
console.log(isNaN(number)); // false
```

#### 3. bigInt

Супербольшие целые числа. Они записываются как обычные целые, только в конце есть литера n:

```js
let bigNum = 9007199254740991n;
console.log(typeof bigNum); // bigint
```

Используются например для меток времени с микросекундами.

#### 4. boolean

**Boolean** - это логический тип данных, который может иметь два значения: **true** и **false**.

#### 5. Symbol

**Symbol** - это встроенный примитивный неизменяемый тип данных (не объект), для создания уникальных идентификаторов, которые даже при одинаковых значениях будут различаться.

```js
let id1 = Symbol("test");
let id2 = Symbol("test");
console.log(id1 === id2); // false
```

#### 6. undefined

**undefined** - значение не определено, как правило при пустой инициализации переменной или при возвращении функций без ключевого слова return.

```js
let name;
console.log(name); // undefined
```

#### 7. null

**null** - примитив, который возвращает **object**. [Неустранимый баг JS](https://habr.com/ru/sandbox/200708/)

```js
let name = null;
console.log(typeof name); // object
```

Null часто используют в API и при работе с DOM, когда ожидают возврата объекта, но возвращается null.

null и undefind имеют одинаковый смисл но разный тип данных

#### 8. object

Набор данных, к которым можно обратиться по имени объекта через точку:

```js
let person = {
    name: 'Ivan',
    age: 10
}
console.log(person.name); // Ivan
```

Или через квадратные скобки по ключу:

```js
console.log(person['name']); // Ivan
```

Объекты задаются пользователям, но есть 2 типа данных, которые являются встроенными объектами:

- Array
- Function

##### array

Массив это список значений, которые можно обратиться по индексу, он может хранить неограниченное количество значений.

```js
let arr = [1, 2, 3];
console.log(arr[0]); // 1
```

##### function

Функция - имеет свои методы и свои свойства. Она может быть сохранена в переменную или передана в качестве значения другому объекту.

Например, встроенный методе toString() возвращает строковое представление функции.

```js
const add = function(a, b) {
    return a + b;
}

console.log(add.toString()); // function add(a, b) { return a + b; }
```

Встроенные методы объектов, могут быть переопределены.

## 03. Lecture

### Приведение типов

Как правило, типы данных в js назначаются динамически при создании переменных, они не указываются явно. Но, типы можно переопределить: явно и неявно.

#### Явное приведение типов

```js
let number = 10;
let string = number.toString();
console.log(typeof string); // string
```

#### Неявное приведение

```js
let number = 10;
let string = '10';
console.log(number + string); // 1010
```

Арифметические операции кроме сложения всегда приводят типы к одному.

#### Булево приведение

При приведении к булеву типу, у следующих значений будет **false**:

- ""
- 0, -0, NaN
- null
- undefined
- false

При приведении к булеву типу, у следующих значений будет **true**:

- "Hello"
- 42
- {} - объекты
- [] - массивы
- function foo() { ... } - функции

Булево приведение происходит автоматически при условных операторах.
Любой тип данных можно привести к булеву с помощью отрицания !. Но, чтобы не было инвертированного значения, можно использовать два отрицания !!.

```js
let value = 1;
console.log(!!value); // true
```

### Равенства

**==** нестрогое равенство, при котором происходит приведение типов:

```js
let a = 10;
let b = "10";
console.log(a == b); // true
```

**===** строгое равенство, при котором не происходит приведение типов и происходит сравнение типов данных:

```js
let a = 10;
let b = "10";
console.log(a === b); // false
```

Движки JS приводят типы по умолчанию к числу, поэтому нестрогое сравнение пустых массивов false, а сравнение тех же массивов, но с отрицанием true.
А вот сравнение пустого массива и инвертированного, тоже true:

```js
[] == []; // false
![] == ![] // true
[] == ![]; // true
// Потому, что:
+[] // 0 - в соответствии с правилами приведения выше пустой массив это false => +false = 0
![] // false - в соответствии с таблицей [] = true => !true = false => +false = 0
// 0 == 0 is true
```

Непустые объекты или непустые массивы между собой сравниваются по ссылкам, не сравнивая значения. Но, если сравнить объект с примитивом, то объект приводится к конкретному примитиву.

### Сравнения

Когда сравниваются строки, то это происходит посимвольно, слева направо:

```js
let a = '43';
let b = '42';
console.log(a > b); // true
```

Такое сравнение называют - **лексикографическим**.

В JS нет строго сравнения типа (>>), как это есть у равенств. Поэтому, у сравнений происходит приведение типов:

Если при приведении строка не может быть преобразована в число, то возвращается NaN, который не может быть ни больше, ни меньше. Поэтому при сравнении c участием NaN, всегда возвращается false.

```js
let a = 10;
let b = '9cc';
console.log(a > b); // false
```

#### Ленивые вычисления

short-circuit evaluation - по аналогии с "коротким замыканием" в электронике, где ток течет по наименьшему сопротивлению. Аналогично при ленивом вычислении логических операторов (&& и ||) в JavaScript (и других языках), при котором второй операнд вычисляется только при необходимости.

### Проверки и приведение

Если переменная не пустая строка "" и не ноль 0:

```js
let a = "John";
if (a) {
    console.log(a);
}
```

Чтобы привести число к строке можно сложить его с пустой строкой:

```js
let a = 10;
console.log("" + a); // "10"
```

Проверка в условии пустой ли массив:

```js
let a = [];
if (a.length) {
    console.log(a);
}
```

### Методы ввода

У объекта window есть методы ввода:

1. windows.alert()
2. window.prompt()
3. windows.confirm()

Т.е. window - это глобальная область видимости, то методы можно указывать без window.
Методы вызывают диалоговые окна в браузере, которые нельзя изменить и определить их положение.

### Условные конструкции

Условие - любое выражение возвращающее болевое значение (true или false). Если условие верно, то выполняется блок кода, иначе - нет. Если выражение условия возвращает не булевый тип, то он будет приведен к булевому.

false:

- ""
- 0, -0, NaN
- null
- undefined

true:

- любое другое значение

#### Условный тернарный оператор

```js
let a = 10;
let b = 20;
let c = a > b ? a : b;
console.log(c); // 20  
```

#### Switch

```js
let a = 10;
switch (a) {
    case 10:
        console.log('10');
        break;
    case 20:
        console.log('20');
        break;
    default:
        console.log('default');
        break;
}
```

### Комментарии

```js
// однострочный комментарий
/* многострочный комментарий */
```

### Консоль браузера

CTRL+SHIFT+C - открыть инструменты разработчика
CTRL+SHIFT+I - открыть инспектор
CTRL+SHIFT+J - открыть консокль

## 05. Lecture

### Функции

Функция это кусок кода (программы), которая являются объектным типом данных, которая происходит от Object.
Функциям присущи операции, которые можно проводить с объектами: передавать по ссылке, добавлять свойства, методы и тому подобное.

#### Свойства функций

##### name

Можно использовать для идентификации функции:

```js
function foo() {}
console.log(foo.name); // foo
```

Доступно только для чтения.

Выражения анонимных функций будут иметь пустую строку в качестве имени

##### length

Свойство length указывает, сколько аргументов ожидает функция, т. е. количество формальных (объявленных) параметров.

```js

function foo(a, b, c) {
  console.log('foo.length:', foo.length); // 3
  console.log('arguments.length:', arguments.length); // зависит от переданных аргументов
}

foo(1, 2); // foo.length: 3, arguments.length: 2
```

Свойство массива arguments.length содержит фактическое количество переданных аргументов в функцию.

Массив arguments — это локальный массив, доступный во всех функциях, кроме стрелочных

#### Встроенные функции

- Object() - создает объект
- Array() - создает массив
- Number() - конвертирует аргумент в число
- String() - в строку
- Boolean() - к булеву типу
- Function() - создает функцию

Данные функции в сочетании с оператором new используются как [конструкторы](#конструктор-объекта) для создания объектов.



#### Функции конструкторы

Пользовательские функции конструкторы, используемые для создания пользовательских объектов принято именовать с большой буквы:

```js
function Person(name, age) {
    this.name = name;
    this.age = age;
}
```

Т.к. конструкторы это функции, то присваивание переменных (свойств) происходит с помощью знака равно, а не двоеточия, как у объектов.

Для создания объекта с помощью функции-конструктора используется оператор new:

```js
let person = new Person('John', 30);
console.log(person); // {name: "John", age: 30}
```

##### Встроенные функции конструкторы

- Date() - конструктор даты
- RegExp() - конструктор регулярных выражений
- Function() - конструктор функций
- Error() - конструктор ошибок
- Map() - конструктор карт
- Set() - конструктор множеств
- WeakMap() - конструктор слабых карт
- WeakSet() - конструктор слабых множеств

Конструкторы могут иметь встроенные свойства и методы:

```js
let today = new Date().getDay();
```

#### Именование функций

Функции должны начинаться с глагола и с маленькой буквы.

```js
function getSum(a, b) {
    return a + b;
}
```

Не нужно давать слишком длинные имена функциям, типа **getSumOfTwoNumbers**

С большой буквы именуются функции-конструкторы

#### Классификация по всплытию (hoisting)

- Невсплывающие (Анонимные) функции
- Всплывающие (Именованные) функции

##### Невсплывающие функции

**Анонимные** функции используют **функциональное выражение**, где функция создается в момент выполнения данного выражения

```js
const sum = function(a, b) {
    return a + b;
};
```

##### Всплывающие функции

**Именованные** функции используют **декларативное объявление**, где функция создается до основной компиляции кода, т.е. всплывает вверх. Поэтому такая функция может быть расположена в конце кода, а вызываться в начале.

```js
function sum(a, b) {
  return a + b;
}
```

#### По возвращаемому значению

- Возвращающие значение
- Не возвращающие значение (всегда возвращает undefined)

#### По параметрам

- С обязательными параметрами
- С опциональными параметрами
- Без параметров

**Параметр функции** - это имя переменной, которое находится внутри скобок после имени функции.

**Аргумент функции** - это значение передаваемое параметру функции.

##### Обязательные параметры

JS-это не строгий язык, т.е. можно передать несколько параметров, но не все параметры будут использоваться.

```js
const minus = (a, b) => {
    return a - b;
}
console.log(minus(10, 5, 8, 9)); // 5
```

Если же передать меньше параметров, то недостающим параметрам присвоится undefined:

```js
const minus = (a, b) => {
    if (b === undefined) {
        return -a;
    }
    return a - b;
}

console.log(minus(10)); // -10
console.log(minus(10, 5)); // 5
```

В случае отсутствия значения параметра b, выполнится условие if.

##### Опциональные параметры

Если написать = (равно), после параметра, то данный параметр будет иметь значение по умолчанию:

```js
const minus = (a, b = 0) => {
    return a - b;
}
console.log(minus(10)); // 10
console.log(minus(10, 5)); // 5
```

#### По наличию побочного эффекта

- Чистые функции
- Функции с побочным эффектом
- Гибридные функции

##### Чистые функции

Чистая функция:

- не контактирует с глобальными переменными
- не связаны со сторонними побочными эффектами от других функций
- получает данные только чрез аргументы
- возвращает одно и тоже (ожидаемое) значение
- легко переиспользуемы в других местах или коде

При создании чистой функции следует быть внимательным к изменяемым типам данных, например объектам,
т.к. свойства объекта легко изменить извне, следует создавать копию объекта внутри функции:

```js
const addPropToObj(object, key, value){
    return {
        ...object,
        [key]: value
    }
}
```

Функции без побочных эффектов, как правило возвращают значение:

```js
const sum = (a, b) => {
    return a + b;
}
```

##### Функции с явными побочными эффектами

```js
const sum = (a, b) => {
    console.log(a + b);
}
```

Нечистые функции использующие **побочные эффекты** - получение данных по сети или из БД, тоже нужны и без них нельзя. Но, нужно стараться по максимуму использовать чистые, а обращения по сети и к БД выносить в грязные функции.

##### Гибридные функции

```js
const sum = (a, b) => {
    console.log(a + b);
    return a + b;
}
```

### Классификация по способу объявления

- Декларативные функции
- Функциональные выражения
- Стрелочные функции

#### Декларативные функции

Декларативная функция состоит:

- ключевого слова function
- имени функции
- параметров
- тело функции

```js
function sum(a, b) {
    return a + b;
}
```

Декларативно объявленные функции могут не завершаться точкой с запятой.

Декларативные функции могут быть объявлены раньше вызывающего их кода. Причину смотри в **Hoisting** всплытии функции.

#### Функциональное выражение

Функциональное выражение состоит:

- ключевого слова function
- параметров
- тело функции

```js
const sum = function(a, b) {
    return a + b;
}
```

Функциональные выражения часто присваивают переменной.

#### Стрелочные функции

В ES2015 появились стрелочные функции, в них убрано:

- ключевое слово function
- нет своего this (берется из внешнего контекста)
- не могут вызывать как конструкторы с new
- в однострочных функциях можно не писать return (подставляется автоматически) 

Стрелочные функции состоят:

- параметров
- стрелки
- тело функции

() => {}

```js
const sum = (a, b) => 
{
    return a + b;
}
```

Можно устанавливать параметры по умолчанию:

```js
const sum = (a = 0, b = 0) => 
{
    return a + b;
}
```

Если параметр функции один, то можно убрать скобки:

```js
const square = a => 
{
    return a * a;
}
```

Но, если параметров нет вообще, то пустые скобки нужны:

```js
const square = () => 
{
    return 2 * 2;
}
```

Стрелочной функции нельзя присвоить имя типа sum(), ее можно присвоить переменной.

##### Неявный возврат

Если функция возвращает одно выражение, то можно убрать фигурные скобки и ключевое слово return (неявный возврат):

```js
const square = () => 2 * 2;
```

Вид стрелочной функции с неявным возвратом: `() =>`

##### Стрелочная функция с одним параметром без скобок

Если стрелочная функция имеет один параметр, то можно убрать скобки:

```js
const square = a => a * a;
```

Вид стрелочной функции с параметром без скобок: `=>`

#### Наращиваемые функции

Может использоваться как отдельная фукнция или в составе других функций, наращивая их фукнционал:

```js
function zeroPad(number, width) {
  let string = String(number);
  while (string.length < width) {
    string = "0" + string;
  }
  return string;
}

function printFarmInventory(cows, chickens, pigs) {
  console.log(`${zeroPad(cows, 3)} Cows`);
  console.log(`${zeroPad(chickens, 3)} Chickens`);
  console.log(`${zeroPad(pigs, 3)} Pigs`);
}

printFarmInventory(7, 16, 3);
// Output:
// 007 Cows
// 016 Chickens
// 003 Pigs
```

### Стек вызовов

ОЗУ в JS делится на 3 вида памяти:

- Стековая память (stack memory) - специализированная область памяти, предназначенная для хранения стека вызовов
- Динамическая память (dynamic memory) - область памяти, которая может быть выделена и освобождена динамически во время выполнения программы
- Куча (heap) - область памяти, которая используется для хранения данных, которые не имеют фиксированного размера

Стековая память используется для хранения **стека вызовов**

Когда вызывается функция, она добавляется на вершину стека вызовов, если внутри нее выполняется еще функция, то следующая добавляется выше и т.д.
Когда функция завершает свое выполнение, она удаляется из вершины стека и так до тех пор пока стек не освободится.

Если вызовов функций слишком много, например в случае неправильной рекурсии, то стек будет переполнен и программа завершится с ошибкой: **Maximum call stack size exceeded**

### Области видимости

1. Глобальная область видимости
    - window
    - global
2. Локальная область видимости
    - Область видимости функции
    - Область видимости блока
    - Вложенная область видимости

Глобальные переменные являются свойствами объекта window для браузера или объекта global для Node.js

### Лексический контекст

Лексический контекст или окружение - это область видимости, которая определяется местом объявления переменной. Она имеет следующие правила:

1. Глобальные переменные видны во всех областях видимости
2. Все переменные любых локальных областей видят глобальную область
3. Переменные и объекты в локальной области видят все вложенные в нее области видимости

Каждый раз при вызове любой функции создается структура данных похожих на объект - **лексический контекст. Данная структура содержит все переменные функции и вне ее, к которым она будет обращаться:

```js
const lastName = "Petrov"
// lexical env: { lastName: "Petrov" }
function getFullName(firstName) {
    // lexical env: { lastName: "Petrov", firstName: <будет определено в момент запуска функции> }
    const fullName = firstName + " " + lastName;
    // lexical env: { lastName: "Petrov", firstName: <будет определено в момент запуска функции>, fullName: <будет вычислено в момент запуска функции> }
    return fullName;
}

getFullName("Ivan"); // "Ivan Petrov"
// lexical env в момент вызова стал таким: { lastName: "Petrov", firstName: "Ivan", fullName: "Ivan Petrov" }
```

Когда функция определена но, не выполнена, в ее лексическом контексте нет многих переменных, но есть для них задел (ключи). В момент запуска функции пробелы заполняются значениями.

#### Неправильное использование контекста

```js
const houses = [];

let i = 0;
while (i<10){
    let house = function(){
        console.log(i); // вывод номера дома по порядку
    }
    houses.push(house) 
    i++;
}

houses[0](); // 10 
houses[9](); // 10
```

Видим, что первый дом имеет номер 10 и последний тоже. Это потому-что лексический контекст общий у всех функций в массиве. Контекст содержит общую переменную i, которая к концу цикла выросла до 10. А т.к. вызов функций происходит мосле цикла, то они все видят десятку: `{ i: 10 }`

Для исправления ситуации нужно номер дома (текущее значение i) сохранять внутри блока цикла:

```js
const houses = [];

let i = 0;
while (i<10){
    let houseNumber = i
    let house = function(){
        console.log(houseNumber); // вывод номера дома по порядку
    }
    houses.push(house) 
    i++;
}

console.log(houses[0]()); // 0
```

Или еще глубже, в теле функции.

### Замыкания

Возможность передавать функцию как значение, плюс факт того, что каждый раз при вызове одной и тоже функции внутри области видимости каждого вызова создаются независимые переменные, открывает побочный эффект - **замыкание** (closures):

```js
function makeCounter() {
    let count = 0;
    return () => count++;
}
const counter = makeCounter();
console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2
```

Тут стрелочная функция которая имеет доступ к внешней переменной count называется замыканием.
Легко сравнить замыкание как функцию которая запускается в среде окружения, в которой уже задана некая переменная, причем эта среда активируется именно в том месте из которого запустили замыкание.

Этапы создания замыкания:

- создать функцию
- внутри объявить замкнутые переменные
- вернуть из функции функцию

Замыкания очень полезны:

1. для кеширования или хранилищ данных, защищенных из внешнего кода
2. скрытие переменных в модулях (когда подключено несколько скриптов с одинаковыми именами)
3. создание счетчиков

#### 1. Кеширование

Функция вычисляющая квадрат числа и сохраняющая результат в кэше:

```js
function closureFunction{
    const cache = {};
    return (x) => {
        if (cache[x]) return cache[x];
        const result = x * x;
        cache[x] = result;
        return result;
    }
}

const square = closureFunction();

console.log(square(5)); // 25
console.log(square(5)); // 25
```

#### 2. Переменные в модулях

```js
(function (){
    const sliderTexts = ['Promo', 'Brands', 'Best'];
    function showSlider(text){
        console.log(text[0]);
        console.log(text[1]);
        console.log(text[2]);
    }
    showSlider(sliderTexts);
}());
```

Данная функция сразу вызывается и исполняется. Переменная sliderTexts - не видна другим и может быть переиспользована.

#### 3. Счетчики

```js
const createCounter = () => {
    let count = 0;
    return () => count++;
}

const counter = createCounter();

console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2
```

#### Недостатки замыканий

Каждый раз при новом вызове любой функции создается лексическое окружение, которе удаляется после выполнения функции. Т.к. часто для замыкания присваивают некой переменной функцию, в результате лексическое окружение остается в памяти, до завершения работы программы или до закрытия браузера, т.к. наличие ссылки (переменной) на функцию препятствует удалению лексического окружения и замкнутых в нем переменных. Поэтому большое количество замыканий приводит к утечке памяти.

### Рекурсия

Функция которая сама себя вызывает называется **рекурсивная функция**

Рекурсию применяют для воспроизведения повторяющихся действий:

1. Для обхода вложенной структуры дерева каталога или документа (DOM)
2. Для математических вычислений, которые поддаются разбиению типа:
   **Сложное вычисление = простая операция, примененная к вычислению попроще**
   $2^{10} = 2^9 \times 2 => b^{e} = b^{e-1} \times b$

```js
function power(base, exponent){
    if (exponent === 0) { // Главное задавать условие выхода иначе будет бесконечная рекурсия
        return 1;
    } else {
        return base * power(base, exponent - 1);
    }
}
console.log(power(2, 3)); // 8
```

Данная реализации вычисления степени числа в три раза медленнее чем вариант с циклом.

### Браузерные события

У HTML-тегов есть атрибут onclick, который выполняет код при нажатии мышью по тегу.

Для того чтобы не писать длинные инструкции в атрибуте onclick, можно использовать функцию-обработчик:

```html
<button onclick="buy()">Buy</button>
<script>
    function buy() { 
        alert('Congratulations! You have bought a good!');
        alert('Good luck!'); 
    }
</script>
```

## 07. Lecture

### Циклы

Цикл - набор инструкций, который выполняется несколько итераций до удовлетворения условий выхода.

Тело цикла - набор инструкций.

Итерация - повторение тела цикла.

Условие выхода из цикла - условие, при котором цикл завершается.

#### Цикл while

Цикл с предусловием:

```js
let i = 0;
while (i < 10) {
    console.log(i);
    i++;
}
```

Очень удобен для бесконечных циклов.

#### Цикл do-while

Цикл с постусловием:

```js
let i = 0;
do {
    console.log(i);
    i++;
} while (i < 10);
```

Тело цикла проверяется на условие после выполнения. Следовательно минимум один раз цикл выполнится. Полезно например при вводе пароля, а потом его проверки до тех пор пока не введут верный.

#### Цикл for

Цикл с инициализацией, условием и инкрементом:

```js
for (let i = 0; i < 10; i++) {
    console.log(i);
}
```

Самый популярный цикл.

#### Прерывание цикла

Выход из цикла происходит:

- если условие выхода из цикла возвращает **false**
- если встречается инструкция **break**

Выход из итерации цикла, но не выход из цикла:

- при достижении конца тела цикла, если условие выхода из цикла возвращает **true**
- если встречается инструкция **continue**

### Массивы

Массив - упорядоченная коллекция элементов одного и того же типа, но в JS типы данных элементов могут быть разными:

```js
let arr = [1, "string", true, null, undefined, { name: 'John' }, [1, 2, 3]];
console.log(arr); // [1, "string", true, null, undefined, { name: 'John' }, [1, 2, 3]]
```

Массив также можно создать с помощью конструктора Array:

```js
let arr = new Array(1, 2, 3, 4, 5);
console.log(arr); // [1, 2, 3, 4, 5]
```

Максимальная длина массива:

- $2^{30}=$ 1_073_741_823 элементов в браузерах 
- $2^{31}=$ 2_147_483_647 элементов в Node.js
- $2^{32}=$ 4_294_967_295 элементов в спецификации ES6+

Имя массива (переменная) - это указатель на область памяти объекта. Т.к. массив это наследник объекта:

```js
typeof [] // object
```

Чтобы случайно не переименовать или удалить имя массива делают константным, элементы массива все еще могут быть изменены:

```js
const arr = [1, 2, 3];
arr[0] = 10;
console.log(arr); // [10, 2, 3]
```

Элементы массива хранятся как значения свойств объекта. А индексы как ключи свойств объекта.
К свойствам любого объекта можно обращаться через точечную нотацию или квадратные скобки. Но, обращаться используя точечную нотацию можно только свойствам (переменным), которые начинаются с буквы или символа подчеркивания и не имеют пробелов, т.е. в имена переменных не могут быть только цифрами, иначе нужно обращаться через квадратные скобки:

```js
value[2] // нельзя value.2
value["John Doe"] // нельзя value.John Doe
```

Поэтому для доступа к элементам массива, как наследнику объекта, нельзя обращаться через точечную нотацию - индексы нужно обрамлять квадратными скобками.

Обратиться к последнему элементу массива, можно так:

```js
const arr = [1, 2, 3];
arr[arr.length - 1] // 3
```

#### Свойства массивов

##### length

Как и строки, массив имеет свойство **length** - количество элементов в массиве.

К свойствам массива можно обращаться через скобочную нотацию:

```js
arr.['length']
```

У массивов помимо встроенных свойств есть методы - это свойства, которые содержат функции.

#### Методы массивов

В зависимости от воздействия на массива методы могут быть:

1. Мутаторы (Mutators) - изменяют массив
2. Аксессоры (Accessors) - возвращают значения
3. Итераторы (Iterators) - могут работать только с итерируемы объектами (массивами, строками, Map, Set)

##### Мутаторы

#### fill

Метод заполняет массив указанным значением:

```js
const arr = [1, 2, 3];
arr.fill("a");
console.log(arr); // ["a", "a", "a"]
```

Если в методе fill не указано значение, то вместо него по умолчанию будет использоваться undefined.

```js
const arr = [1, 2, 3];
arr.fill();
console.log(arr); // [ undefined, undefined, undefined ]
```

Метод имеет второй и третий аргумент, которые определяют с какого и по какой индекс заполнять массив:

```js
const arr = [1, 2, 3];
arr.fill("a", 1, 2);
console.log(arr); // [1, "a", 3]
```

###### reverse

Метод переворачивает массив:

```js
const arr = [1, 2, 3];
arr.reverse();
console.log(arr); // [3, 2, 1]
```

###### push

Добавление одного или нескольких элементов в конец исходного массива (похож unshift):

```js
const arr = [1, 2, 3];
arr.push(4, 5);
console.log(arr); // [1, 2, 3, 4, 5]
```

###### unshift

Добавляет один или несколько элементов в начало исходного массива (похож push):

```js
const arr = [1, 2, 3];
arr.unshift(4, 5);
console.log(arr); // [4, 5, 1, 2, 3]
```

###### pop

Извлекает и удаляет последний элемент исходного массива (похож на shift):

```js
сonst arr = [1, 2, 3];
console.log(arr.pop()); // 3
console.log(arr); // [1, 2]
```

###### shift

Удаляет первый элемент исходного массива, сдвигая все остальные элементы влево (похож на pop):

```js
const arr = [1, 2, 3];
arr.shift();
console.log(arr); // [2, 3]
```

###### sort

Метод сортирует массив:

```js
const arr = [3, 2, 1];
arr.sort();
console.log(arr); // [1, 2, 3]
```

Может быть также итератором:

```js
const arr = [3, 2, 1];
arr.sort((a, b) => a - b);
console.log(arr); // [1, 2, 3]
```

###### splice

Удаляет элементы в текущем массиве:

```js
const arr = [1, 2, 3, 4, 5];
arr.splice(2, 1); // указываем индекс с которого начать удаление, количество символов для удаления
console.log(arr); // [1, 2, 4, 5]
```

Если метод splice вызывается без аргументов, то он может использоваться для полного клонирования массива:

```js
const arr = [1, 2, 3];
const arr2 = arr.splice();
console.log(arr2); // [1, 2, 3]
```

Также для клонирования, т.е. создания полной копии массива может использоваться метод высшего порядка map:

```js
const arr = [1, 2, 3];
const arr2 = arr.map(item => item);
console.log(arr2); // [1, 2, 3]
```

##### Аксессоры

###### slice

Slice (отрезать) в отличие от splice (латать) является персистентным, он копирует часть или весь массив:

```js
const arr = [1, 2, 3, 4];

const all = arr.slice();
console.log(all); // [1, 2, 3, 4]

const start = arr.slice(1);
console.log(start); // [2, 3, 4]

const overload = arr.slice(14);
console.log(overload); // []

const minus = arr.slice(-2);
console.log(minus); // [3, 4]

const range = arr.slice(1, 3);
console.log(range); // [2, 3]

const startMinus = arr.slice(1, -1);
console.log(startMinus); // [2, 3]
```

###### concat

Персистентная конкатенация массивов:

```js
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const arr3 = arr1.concat(arr2);
console.log(arr3); // [1, 2, 3, 4, 5, 6]
```

Вторым и далее аргументами concat() можно передать любой примитив или объект и они будут добавлена справа от первого массива:

```js
const arr3 = arr1.concat(arr2, {key: 1}, "string", [10, 11, 12]); 
console.log(arr3); // [ 1, 2, 3, 4, 5, 6, { key: 1 }, 'string', 10, 11, 12 ]
```

concat() похож на push(), но не изменяет первоначальный массив, а создает новый

###### concat + slice

Можно создать функцию remove, которая удаляет нужный элемент массива по индексу:

```js
function remove(array, index) {
  return array.slice(0, index)
    .concat(array.slice(index + 1));
}
console.log(remove(["a", "b", "c", "d", "e"], 2));
// → ["a", "b", "d", "e"]
```

Похожего эффекта можно добится с помощью метода splice(2, 1)

###### indexOf

Метод возвращает индекс первого искомого вхождения (самого левого) элемента в массиве:

```js
const arr = [1, 2, 3];
console.log(arr.indexOf(2)); // 1
console.log(arr.indexOf(5)); // -1
```

Если элемент не находится в массиве, то возвращается -1.

В методе можно указать второй параметр, который определяет с какого индекса начать поиск:

```js
const arr = [1, 2, 3];
console.log(arr.indexOf(2, 1)); // 1
```

###### lastIndexOf

Метод возвращает индекс последнего искомого вхождения (самого правого) элемента в массиве:

```js
const arr = [1, 2, 3, 2];
console.log(arr.lastIndexOf(2)); // 3
console.log[arr.lastIndexOf(5)]; // -1
```

Метод, как и indexOf имеет второй необязательный параметра, место к которого начать поиск.

###### includes

Метод возвращает true если в массиве есть искомый элемент:

```js
const arr = [1, 2, 3];
console.log(arr.includes(2)); // true
```

###### join

Метод объединяет элементы массива в строку:

```js
console.log(['H', 'e', 'l', 'l', 'o'].join(" ")); // H e l l o  
```

Если сепаратор (разделитель) не указан в аргументе метода, то по умолчанию он равен пробелу.

#### Массивы с циклами

Цикл очень часть используется при работе с массивами:

##### for

```js
const arr = [1, 2, 3];

for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}
```

##### for of

Цикл для массива можно записать короче:

```js
for (let item of arr) {
   console.log(item); 
}
```

Цикл был разработан для решения проблемы **сурогатных пар** (см. строки), позволяет итерироваться по знакам занимающим две символьные единицы:

```js
let roseDragon = "🌹🐉";
for (let char of roseDragon) {
  console.log(char);
}
// → 🌹
// → 🐉
```

##### forEach

```js
arr.forEach(item => console.log(item));
```

### Пвсевдомассивы

(01 adjs)

Псевдомассив - это объект, который имеет индексы и свойство length. Более того, строки можно представить в виде псевдомассива, хотя они не являются объектами. 

#### Array.from

Из объекта можно сделать псевдомассив:

```js
let pseudo = { 0: 'first', 1: 'second', length: 1 };

let array = Array.from(pseudo);
array.push('third');
console.log(array); // [ 'first', 'second', 'third' ]
```

Т.е. обязательно наличие только свойства length, которое должно совпадать с количеству элементов. В случае если количество будет элементов будет больше значения length, то в псевдомассиве лишние выкинутся, если элементов меньше, то остатки заполнится undefined.

Преобразование строки в песевдомассив еще проще из-за встроенного свойства length:

```js
let string = "hello world";
let array = Array.from(string);
console.log(array); // [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd' ]
```

Преобразование в псевдомассив одностороннее действие, обратно можно преобразовать только через самописный цикл или класс, нет встроенных решений.

### Строки

Строки - это примитивы. Поэтому, при работе с ними происходит приведение типов.

При обращении к методам строки, происходит оборачивание строки в объект.

#### Unicode

Содержит коды символов для 140 письменностей (81 живая письменность, 59 неживые) https://en.wikipedia.org/wiki/Script_(Unicode)

Кодовая единица (code unit) для одного символа в строке составляет 2 байта и он закодирован в UTF-16.
Некоторые символы (emoji или иероглифы) выходящие за 16-битный диапазон хранятся как два символа и называются **суррогатными парами**

```js
console.log(characterScript(121));

const emoji = "😊";

console.log(emoji.length); // ❗ 2, а не 1
console.log(emoji.charCodeAt(0)); // d83d (старший суррогат)
console.log(emoji.charCodeAt(1)); // de0a (младший суррогат)
console.log(emoji.codePointAt(0)); // полноценный суррогат
console.log(emoji[0]);  // � (неправильный символ)
```

Из-за суррогатных пар практически невозможно провильно итерироваться по строке используя классический цикл for. Когда была обнаружена проблема суррогатных пар появился цикл for/of

#### for/of

Пример корректной итерации по двум-юнитовым символам, т.е. по символам состоящим из суррогатных пар:

```js
let roseDragon = "🌹🐉";
for (let char of roseDragon) {
  console.log(char);
}
// → 🌹
// → 🐉
```
```

#### Строковые методы

При попытке добавить новый метод, ничего не получится в отличие от объекта.

```js
let kim = "Kim";
kim.age = 88
console.log(kim); // undefined
```

Но, встроенных методов предостаточно.

#### charCodeAt

Выводит в примере выше только кодовую единицу, т.е. старший суррогат

#### codePointAt

Возвращает полноценный Unicode код символа. Метод был разработан когда встала проблема **суррогатных пар**

#### slice()

```js
let str = 'Hello';
console.log(str.slice(1, 3)); // el
```

#### substr

```js
let str = 'Hello';
console.log(str.substr(1, 3)); // ell
```

#### substring

```js
let str = 'Hello';
console.log(str.substring(1, 3)); // el
```

#### replace

```js
let str = 'Hello';
console.log(str.replace('l', 'L')); // HelLo
```

#### split

Создает массив из строки по указанному разделителю:

```js
let str = 'Hello';
console.log(str.split('')); // ['H', 'e', 'l', 'l', 'o']
```

#### charAt

```js
let str = 'Hello';
console.log(str.charAt(1)); // e
```

#### indexOf()

```js
let str = 'Hello';
console.log(str.indexOf('ll')); // 2
```

В отличие от одноименного метода массива, для строки можно указывать несколько символов для поиска

#### length()

```js
let str = 'Hello';
console.log(str.length); // 5
```

#### toUpperCase()

```js
let str = 'Hello';
console.log(str.toUpperCase()); // HELLO
```

#### toLowerCase

```js
let str = 'Hello';
console.log(str.toLowerCase()); // hello
```

#### trim

Удаляет крайние пробелы, переносы строк, табуляцию и однотипные символы:

```js
let str = '   Hello   ';
console.log(str.trim()); // Hello
```

#### padStart

Дополняет строку до указанного количества символов в строке:

```js
let str = 'Hello';
console.log(str.padStart(10, '0')); // 00000Hello
```

#### repeat

Повторяет строку указанное в параметре метода количество раз:

```js
let str = 'Hello';
console.log(str.repeat(3)); // HelloHelloHello
```

#### Функции для строк

##### parseInt

Парсит целые числа как в десятичной системе, так и в шестнадцатеричной представленных в виде строк:

```js
let str = '123';
console.log(parseInt(str)); // 123
// если строка начинается с 0x
let str = '0x7b';
console.log(parseInt(str)); // 123
```

Можно парсить в других системах счисления от 2 до 36, указав систему в качестве второго параметра:

```js
let str = '0x7b';
console.log(parseInt(str, 16)); // 123
```

##### parseFloat

Может парсить как целое так и дробное число представленное в виде строки

```js
let str = '123.456';
console.log(parseFloat(str)); // 123.456
```

## 09. Lecture

### Объекты

Объекты это абстрактные структуры данных (Выразительный JS. Глава 6), которые обладают набором интерфейсов (методов.) Это справедливо как для встроенных типов данных Массивы, Функции, так и для пользовательских объектов. 

К типу Object относятся все не примитивные типы данных, кроме null: массивы, классы, промисы, события и т.д.

Правила создания объектов:

1. Объекты рекомендуют объявлять с помощью ключевого слова **const**.
2. Определение (тело) объекта заключается в фигурных скобках. Фигурные скобки обрамляют также начало и конец блока инструкций, например функции. Встречаются случаи когда надо явно отличить функцию от объекта:
   `n => { prop: value } // treated as function`
   `n => ({ prop: value }) // treated as object`
3. Имя (ключ) свойства отделяется от значения свойства двоеточием.
4. Имя свойства может быть любым
5. Объект не может содержать дублирующиеся имена свойств.
6. Все свойства объекта объявляются через запятую.

Пустой объект можно создать двумя способами:

- С помощью конструктора Object: `const obj = new Object();`
- С помощью литеральной нотации (литерал объекта): `const obj = {};`

Объекты имеют свойства (характеристики) и методы (действия).

```js
const user = {
    name: 'John',
    age: 30
    move: function() {
        console.log('move');
    }
};
```

#### Свойства объектов

Почти все типы данных в JS имеют свойства , за исключением null и undefined. Если обратиться к их свойствам, то получим ошибку:

```js
null.length; // TypeError: Cannot read properties of null (reading 'length')
null["length"]; // TypeError: Cannot read properties of null (reading 'length')
```

Имена свойств объектов это строки. К свойствам можно обратиться двумя способами:

- с помощью точечной нотации
- с помощью квадратных скобок
- смешанным способом

##### Точечная нотация

Обращение к свойству объекта через точечную нотацию:

```js
const user = {
    name: 'John',
    age: 30
};

console.log(user.name); // John
console.log(user.age); // 30
```

С помощью точечной нотации нельзя обратиться к свойствам, которое целиком состоят из цифр или имеют пробелы в именовании:

```js
const arr = [1, 2, 3]
for(let i=0; i < arr.length; i++) console.log(arr[i]); // вычисляемое имя поля i
```

Поэтому следует использовать квадратные скобки.

##### Квадратные скобки

В точечной нотации свойство это строка, а в скобках это может быть вычисляемое выражение:

```js
const user = {
    name: 'John',
    age: 30
};

const key = 'age';
console.log(user[key]); // 30
console.log(user.key); // undefined
```

##### Смешанная нотация

При обращении к свойствам вложенных объектов допускается использование квадратных скобок, точечной или смешанной нотации:

```js
const user = {
    name: 'John',
    age: 30,
    address: {
        city: 'New York',
        country: 'USA'
    }
};

console.log(user.address.country); // USA
console.log(user.address['country']); // USA
console.log(user['address'][country]); // USA
```

##### Добавление свойств

В любой момент можно добавить новое свойство:

```js
const user = {
    name: 'John',
    age: 30
};

user.isAdmin = true;
console.log(user); // {name: "John", age: 30, isAdmin: true}
```

Рекомендуется имена свойств (характеристики) объектов всегда заключать в кавычки, особенно:

- содержат пробелы
- состоят только из цифр
- содержат спецсимволы

Более того, это походит на JSON:

```js
const obj = {
  'hello world': 'value',
  '123': 'another value',
  '!@#$': 'yet another value'
};
```

Чтобы заменить значение свойства объекта используют знак равно =:

```js
const user = {
    name: 'John',
    age: 30
};

user.age = 40;
user.lastname = 'Smith';

console.log(user); // {name: "John", age: 40, lastname: "Smith"}
```

Если при присваивании значения свойству через знак равно такого нет, то оно создастся автоматом.

При обращении к несуществующему свойству возвращает **undefined**:

```js
console.log(user.age); // undefined
```

Но, есть разница между удалением свойства и присвоением ему **undefined**:

```js
user.age = undefined;
console.log(user.age); // undefined
```

##### delete

Для удаления свойства объекта применяется оператор **delete**:

```js
const user = {
    name: 'John',
    age: 30
};

delete user.age; // true
console.log(user); // {name: "John"}
```

При успешном удалении свойства возвращается true, иначе false (например защищенный объект браузера).

##### оператор in

Используется для поиска свойства в объекте, возвращая true или false:

```js
console.log("right" in {left: 1, right: 2});
// → true
console.log("center" in {left: 1, right: 2});
// → false
```

##### Особенности объектов

При сравнении объектов == сравниваются их указатели и проверяется их идентичность, но не содержание.

При указании переменных в качестве аргументов функции передаются только их значения, исходные переменные остаются нетронутыми. При указании имени объекта в качестве аргумента функции передает указатель на этот объект. Поэтому при изменении объекта внутри функции, изменится исходный объект.

##### Короткое присваивание свойств объекта

Если при создании объекта передаются переменные в качестве свойств и без значений, то значения берутся из переменных, а ключами свойств становятся имена переменных.

```js
let event = "hello";
let squirrel = "World";
const obj = {event, squirrel}; // same as - const obj = {event: "hello", squirrel: "World"}
console.log(obj); // { event: 'hello', squirrel: 'World' }
```

##### Опциональное обращение к свойству объекта

Если нет уверенности, что обращение к свойству объекта существует, то можно использовать **?.**  (оператор опциональной цепочки):

```js
const user = {
    name: 'John',
    age: 30
};

console.log(user?.name); // John
console.log(user?.lastName); // undefined
```

Можно использовать как точечную нотацию, так и квадратные скобки:

```js
const user = {
    name: 'John',
    age: 30
};

console.log(user?.['name']); // John
console.log(user?.['lastName']); // undefined
```

Данный механизм позволяет избежать выброса исключения при обращении к несуществующему свойству.

#### Методы объекта

Методы объекта это свойства которым присвоены функции:

```js
function speak(line){
    console.log(`The ${this.type} rabbit says: ${line}`);
}

let whitRabbit = {type: "white", speak};
let hungryRabbit = {type: "hungry", speak};

whiteRabbit.speak("oh my fur and whiskers")
// The white rabbit says: oh my fur and whiskers
hungryRabbit.speak("got any carrots?");
// The hungry rabbit says: got any carrots?
```

Для наглядности вызова метода, можно использовать встроенный в функции метод call:

```js
speak.call(whiteRabbit, "Hurry");
// → The white rabbit says 'Hurry'
```

В объекте принято методы объявлять после свойств:

```js
// Объект робот-пылесос
const Roomba = { // Есть негласное правило называть объекты в алгоритмах с большой буквы.
    // Обычно сначала объявляют свойства объекта.
    model: "Romba-1",
    power: 200,
    batterySize: 2100,
    boxSize: 0.5,
    workTime: 45,
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    isUVLampOn: false,
    // После свойств объявляют его методы.
    startCleaning: function () { // увеличивает счетчик стартов робота и выводит сообщение о старте
        this.counterOfStarts++;
        console.log('I am cleaning... I have been started: ', this.counterOfStarts, 'times.');
    },
    goCharge: function () { // отправка на зарядку
        console.log('I am going to charge...');
    },
    switchUVLamp: function () { // вкл.выкл ультрафиолетовой лампы
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    }
};

// Обращение к свойствам объекта.
console.log(Roomba.model); // "Romba-1"
console.log(Roomba.isFull); // false
// Вызов методов объекта.
Roomba.startCleaning(); // 'I am cleaning... I have been started: 1 times.'
// Установим свойства объекта isUVLampOn в true, чтобы продемонстрировать результат работы метода switchUVLamp.
Roomba.switchUVLamp(); // 'UV lamp is working.'
Roomba.goCharge(); // 'I am going to charge...'
```

Объявление методов в объекте можно делать разным синтаксисом:

- с ключевым словом function
- без ключевого слова function
- с использованием стрелочной функции

Каждый синтаксис имеет разные области видимости и наследование.

Методы могут обращаться к свойствам объекта с помощью ключевого слова **this**

#### this

Ключевое слово this ссылается на текущий объект, оно также доступно в любой функции:

```js
// Работа с this
const checkThis = function() {
    console.log(this);
}
checkThis(); // Window {0: global, window: Window, self: Window, document: document, name: "", location: Location, ...}
```

Из лексического контекста данной функции видно, что this (текущий объект) ссылается на глобальный объект window, в случае браузера или global в node.js

Внутри методов объекта this указывает на сам объект, в котором он был объявлен:

```js
const checkThisInObject = {
    testProperty: true,
    checkThis: function () {
        console.log(this);
    },
};
checkThisInObject.checkThis(); // {testProperty: true, checkThis: ƒ}
```

Контекст не указывает никаких глобальных объектов, следовательно this - это сам объект, но есть нюансы, т.к. this в JS отличается от других языков программирования. Например, стрелочные функции не имеют контекста, поэтому в них this будет ссылаться на глобальный объект по отношению к ним.

#### Одалживание методов

Создадим улучшенного робота-пылесоса, на основе первого:

```js
// Объект робот-пылесос модель Tango.
const Tango = { 
    model: "Tango-1",
    power: 300,
    batterySize: 3200,
    boxSize: 0.7,
    workTime: 60,
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    isUVLampOn: false,
    // После свойств объявляют его методы. А так как методы у новой модели такие же как и у старой, давайте позаимствуем их у объекта Roomba.
    startCleaning: Roomba.startCleaning,
    goCharge: Roomba.goCharge,
    switchUVLamp: Roomba.switchUVLamp,
};

console.log(Tango.model); // "Tango-1"
console.log(Tango.isFull); // false
// Вызов методов объекта.
Tango.startCleaning(); // 'I am cleaning... I have been started: 1 times.'
// Результат вызова следующего метода зависит от значения, хранящегося в свойстве объекта, а также от того как этот метод был вызван (об этом поговорим чуть ниже).
Tango.switchUVLamp(); // 'UV lamp working.'
Tango.goCharge(); // 'I am going to charge...'
```

Создадим третьего робота, но объекты экспортируем с помощью внешних способов:

```js
const Samba = {
    model: "Samba-1",
    power: 250,
    batterySize: 2500,
    boxSize: 0.5,
    workTime: 50,
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    isUVLampOn: false,
    // На этот раз мы не будем создавать методы в объекте, мы постараемся их заимствовать непосредственно перед использованием.
};

// Одолжим методы из объекта Roomba.
Samba.startCleaning = Roomba.startCleaning;
Samba.switchUVLamp = Roomba.switchUVLamp;
Samba.goCharge = Roomba.goCharge;
Samba.startCleaning(); // 'I am cleaning... I have been started: 1 times.'
// Результат вызова следующего метода зависит от значения, хранящегося в свойстве объекта, а также от того как этот метод был вызван (об этом поговорим чуть ниже).
Samba.switchUVLamp(); // 'UV lamp is working.'
Samba.goCharge(); // 'I am going to charge...'
```

Лампа работает по принципу одной кнопки (вкл/выкл). Сейчас лампа включена
Предположим мы хотим включить лампу по расписанию через пять секунд:

```js
setTimeout(Samba.switchUVLamp, 5000); // 'UV lamp is working.'
```

Но, лампа не выключается. Потому что через 5 секунд объекта Samba уже нет и внутренняя this ссылается несуществующий объект, т.е. undefined.

Можно обернуть метод в анонимную функцию, тогда ссылка на Samba сохраниться в лексическом контексте функции и объект не будет удален:

```js
setTimeout(function() {
    Samba.switchUVLamp();
}, 5000); // 'UV lamp in not working.'
```

Можно вместо анонимной функции использовать методы call, apply или bind

#### Встроенные методы объектов

##### call

Метод call позволяет вызвать метод в контексте другого объекта, на примере объекта Roomba:

```js
const notARobot = {
    counterOfStarts: 10,
}

Roomba.startCleaning.call(Roomba); // 'I am cleaning... I have been started: 1 times.'
Roomba.startCleaning.call(notARobot); // 'I am cleaning... I have been started: 10 times.'
```

В последнем вызове метода мы передали с помощью call контекст другого объекта и он выполнился со своим свойством counterOfStarts равным 10. Если в качестве второго и последующих аргументов call что-то передать, то данные параметры пойдут в вызываемый метод

##### apply

Аналогичен методу call, только второй параметр передается в виде массива:

```js
Roomba.startCleaning.apply(Roomba, [1, 2, 3]); // 'I am cleaning... I have been started: 10 times.'
```

##### bind

Позволяет привязать контекст к фукнции (методу) навсегда:

```js
Samba.startCleaning = Roomba.startCleaning.bind(Samba);
```

Методы можно добавить в объект, путем присвоения функции как значения свойства с ключевым словом function:

```js
const user = {
    make: 'Audi',
    model: "A6",
    year: 2008,
    startEngine: function() {
        console.log('Engine is started');
    }
};

user.startEngine(); // Engine is started
```

Если использовать стрелочную функции внутри объекта, то они не будут видеть объекта, т.к. стрелочные функции не имеют собственного контекста поэтому берется объект на уровень выше, т.е. global. Тут не помогут даже call, apply и bind.

Но, стрелочные функции очень полезны как анонимные внутри самого метода объекта:

```js
const Stand = {
    model: "Stand-1",
    robots: ['Roomba-1', 'Tango-1', 'Samba-1', 'Roomba-2'],
    // Метод, с использованием стрелочной функции в качестве функции обратного вызова.
    startTestingArrow: function() {
        console.log('Start testing...');
        this.robots.forEach((value) => {
            console.log('stand: ', this.model, 'is testing robot: ', value);
        })
    },
    // Метод, с использованием классической функции в качестве функции обратного вызова.
    startTestingClassic: function() {
        console.log('Start testing...');
        this.robots.forEach(function(value) {
            console.log('stand: ', this.model, 'is testing robot: ', value);
        })
    },
};
Stand.startTestingArrow();
// Start testing...
// stand: Stand-1 is testing robot: Roomba-1
// stand: Stand-1 is testing robot: Tango-1
// stand: Stand-1 is testing robot: Samba-1
// stand: Stand-1 is testing robot: Roomba-2
Stand.startTestingClassic();
// Start testing...
// stand: undefined is testing robot: Roomba-1
// stand: undefined is testing robot: Tango-1
// stand: undefined is testing robot: Samba-1
// stand: undefined is testing robot: Roomba-2
```

Получили двойную вложенность в двух методах: startTestingArrow() и startTestingClassic(). Первый метод со стрелочной функцией внутри отработал, т.к. стрелочная функция не имея собственного this ссылается через уровень к свойству model и отрабатывает хорошо. Вот второй метод не отрабатывает как надо, потому что внутри классического метода, классическая функция видит свой контекст и this в нем не видит свойства model в результате возвращается undefined.

#### Object.freeze

Делает объект неизменным (immutable). После применения этого метода к объекту невозможно:

- Добавить новые свойства
- Удалить существующие свойства
- Изменить значения уже имеющихся свойств

```js
const user = { name: "Иван", age: 30 };

Object.freeze(user);
user.age = 31; // Не изменится
user.email = "test@example.com"; // Не добавится
delete user.name; // Не удалится
console.log(user); // { name: "Иван", age: 30 }
```

Не применяется к вложенным объектам.

#### Клонирование объектов

##### С помощью for in

Цикл for in используется для перебора свойств объекта:

```js
const user = {
    name: 'John',
    age: 30
};

for (let key in user) {
    console.log(key); // name, age - вывод всех ключей свойств объекта
    console.log(user[key]); // John, 30 - вывод всех значений свойств объекта
}
```

Цикл for in часто используют для клонирования объекта:

```js
const user = {
    name: 'John',
    age: 30
};

const clonedUser = {};
for (let key in user) {
    clonedUser[key] = user[key];
}
console.log(clonedUser); // { name: 'John', age: 30 }
```

Для клонирования объекта удобнее использовать метод **Object.assign**

##### Object.assign

Для полного клонирования объекта:

```js
const user = {
    name: 'John',
    age: 30
};

const clone = Object.assign({}, user); // {name: "John", age: 30}
```

Или для частичного копирования свойств одного объекта в другой:

```js
const user = {
    name: 'John',
    age: 30
};

const phoneBook = Object.assign(user, {mobile: "+7916777777"}); // {name: "John", age: 30, mobile: "+7916777777"}
```

##### C помощью spread

Клонировать объект можно циклом for/in, методом Object.assign или с помощью оператора spread:

```js
const user = {
    name: 'John',
    age: 30
};

const clonedUser = {...user, city: "New York"}; // {name: "John", age: 30, city: "New York"}
```

После spread можно указывать дополнительные свойство которые добавятся в клонированный объект

#### Объект в массив

У массивов для преобразование его элементов и помещения результатов в новый массив можно использовать метод **map**. Но, у объектов такого метода нет, поэтому для преобразования объекта в массив необходимо использовать методы **Object.values** и **Object.keys**.

##### Object.keys

Для сохранения в массив ключей объекта используется метод **Object.keys**:

```js
const user = {
    name: 'John',
    age: 30
};

const array = Object.keys(user); // ["name", "age"]
```

##### Object.values

Для сохранения в массив значений объекта используется метод **Object.values**:

```js
const user = {
    name: 'John',
    age: 30
};

const array = Object.values(user)); // ["John", 30]
```

##### Object.entries

Для сохранения в массив пар ключ-значение используется метод **Object.entries**:

```js
const user = {
    name: 'John',
    age: 30
};

const array = Object.entries(user); // [["name", "John"], ["age", 30]]
```

Можно было бы использовать для итерации for in по объекту без конвертации в массив, но в итерацию могут попасть наследуемые свойства объектов, включая прототип, при их наличии.

```js
const user = {
    name: 'John',
    age: 30
};

for (let key in user) {
    console.log(key); // name, age, toString, constructor
    console.log(user[key]); // John, 30, [object Object], [object Object]
}
```

Поэтому лучше преобразовывать в массив с помощью Object.keys, Object.values или Object.entries и далее работать с данными внутри массива.

#### Math

Объект Math объединяет в себя математические методы, для того чтобы не плодить глобальные функции, дабы не засорять глобальное пространство имен. Иначе, велика вероятность что функции, либо переменные создаваемые пользователем могут случайно совпасть с библиотечными.

##### Математические константы

Такие как $\pi$, $e$ и другие, доступны в объекте Math. и записываются прописными буквами:

```js
console.log(Math.PI); // 3.141592653589793
console.log(Math.E); // 2.718281828459045
```

##### Math.random

Возвращает псевдослучайное число от 0 включительно до 1 не включительно:

```js
console.log(Math.random()); // 0.123456789
```

Если необходимо сгенерировать случайное целое число, то в купе с текущей функцией используют округление

##### Math.floor

Округляет до наименьшего целого числа, которое меньше или равно указанному числу:

```js
console.log(Math.floor(2.9)); // 2
```

##### Math.ceil

Округляет до наибольшего целого числа, которое больше или равно указанному числу:

```js
console.log(Math.ceil(2.1)); // 3
```

##### Math.round

Округляет до ближайшего целого числа по правилам математики:

```js
console.log(Math.round(2.4)); // 2
console.log(Math.round(2.6)); // 3
```

##### Math.abs

Возвращает модуль числа:

```js
console.log(Math.abs(-5)); // 5
console.log(Math.abs(5)); // 5
```

##### Math.pow

Возведение в степень:

```js
console.log(Math.pow(2, 3)); // 8
```

##### Math.sqrt

Возвращает квадратный корень числа:

```js
console.log(Math.sqrt(9)); // 3
```

##### Math.cbrt

Возвращает кубический корень числа:

```js
console.log(Math.cbrt(27)); // 3
```

##### Math.min и Math.max

Возвращает минимальное и максимальное значения:

```js
console.log(Math.min(1, 2, 3)); // 1
console.log(Math.max(1, 2, 3)); // 3
```

##### Math.trunc

Возвращает целую часть числа:

```js
console.log(Math.trunc(2.9)); // 2
```

##### Math.sign

Возвращает знак числа:

```js
console.log(Math.sign(-5)); // -1
console.log(Math.sign(0)); // 0
console.log(Math.sign(5)); // 1
```

##### Math.clz32

Возвращает количество знаков в двоичном представлении числа:

```js
console.log(Math.clz32(0b1001)); // 3
console.log(Math.clz32(0b1010)); // 2
```

##### Math.imul

Возвращает произведение двух целых чисел:

```js
console.log(Math.imul(2, 3)); // 6
```

##### Math.fround

Возвращает число с плавающей точкой в одинарной точности:

```js
console.log(Math.fround(2.9)); // 2.9000000953674316
```

##### Math.hypot

Возвращает гипотенузу треугольника:

```js
console.log(Math.hypot(3, 4)); // 5
```

##### Math.cosh

Возвращает гиперболический косинус числа:

```js
console.log(Math.cosh(1)); // 1.5430806348152437
```

##### Math.sinh

Возвращает гиперболический синус числа:

```js
console.log(Math.sinh(1)); // 1.1752011936438014
```

##### Math.tanh

Возвращает гиперболический тангенс числа:

```js
console.log(Math.tanh(1)); // 0.7615941559557649
```

##### Math.asinh

Возвращает аркгиперболический синус числа:

```js
console.log(Math.asinh(1)); // 0.881373587019543
```

##### Math.acosh

Возвращает аркгиперболический косинус числа:

```js
console.log(Math.acosh(1)); // 0
```

##### Math.atanh

Возвращает аркгиперболический тангенс числа:

```js
console.log(Math.atanh(1)); // 0.5493061443340549
```

##### Math.sin

Возвращает синус числа:

```js
console.log(Math.sin(1)); // 0.8414709848078965
```

##### Math.cos

Возвращает косинус числа:

```js
console.log(Math.cos(1)); // 0.5403023058681398
```

##### Math.tan

Возвращает тангенс числа:

```js
console.log(Math.tan(1)); // 1.5574077246545013
```

##### Math.asin

Возвращает арксинус числа:

```js
console.log(Math.asin(1)); // 1.5707963267948966
```

##### Math.acos

Возвращает арккосинус числа:

```js
console.log(Math.acos(1)); // 0
```

##### Math.atan

Возвращает арктангенс числа:

```js
console.log(Math.atan(1)); // 0.7853981633974483
```

### Глобальные объекты

Глобальный объект — хранит функции и переменные, которые могут быть доступны в любой части программы

В среде JS всегда есть один встроенный в язык глобальный объект, от которого происходят остальные объекты.

Имя такого первичного объекта всегда зависит от среды исполнения JS:

- **window** в браузере
- **global** в Node.js
- **WorkerGlobalScope** в веб-воркере

**Web Worker** — это механизм, позволяющий выполнять фоновые задачи отдельно от основного скрипта. Это полезная функция, но используется
нечасто в узкоспециализированных скриптах, где требуются фоновые вычисления.

Эти объекты не являются частью языка, они являются частью движка на котором ведется работа. Глобальный объект нужен для взаимодействия со средой в которой исполняется код.

Все методы и свойства глобального объекта доступны везде напрямую без указания window или global:

```js
console.log(this); // window
window.console.log(window); // window
console.log(global); // global
console.log(this === window); // true
console.log(this === global); // true
```

Помимо этого в браузерах к глобальному объекту можно обратиться через **self** или **frames**:

```js
console.log(self === window); // true
console.log(frames === window); // true
```

**self** и **frames** являются свойствами window (ссылаются на текущее окно/фрейм)

В ES6 введён новый универсальный для всех сред глобальный объект globalThis.

Функции, объявленные с ключевым словом function и переменные обвяленные с ключевым словом var создаются с привязкой к глобальному объекту (window, global, globalThis).

Переменные, созданные с помощью операторов let и const, а также функции, объявленные с помощью выражений (в том числе, анонимные), не являются методами глобального объекта, они хранятся в скрытом лексическом окружении (Lexical Environment) движка:

```js
const local = 5;
let localFunc = () => 'localFunc';

console.log(local); // 5
console.log(localFunc()); // localFunc
console.log(globalThis.local); // undefined
console.log(globalThis.localFunc()); // undefined
```

Это сделано для того, чтобы исключить конфликт имен переменных в разных лексических окружениях (блочных, функциональных, глобальных).

Т.к. основная работа ведется в глобальной области видимости, все свойства и методы глобального объекта доступны без указания главного объекта:

```js
window.alert("Hello"); // Hello
alert("Hello"); // Hello
```

Объекты из подключаемых модулей не будут частью глобального объекта.

В React в основном используется глобальный объект, и для управления большим количеством глобальных переменных используется специальные механизмы управления состоянием (state management).

Состоянием (State) приложения называются все данные приложения на этот момент. Данные эти могут храниться как в глобальной области, так и
в одном из хранилищ.

Глобальный объект хранит все встроенные классы, функции и методы.

### Функции высшего порядка

ПО можно конструировать двумя способами, где:

1. Код простой и очевидно без дефектов
2. Код сложный и без очевидных дефектов

$\copyright$ Theories of Programming: The Life and Works of Tony Hoare

#### 1. Простой код

```js
function range{
    pass
}

function sum{
    pass
}

console.log(sum(range(1,10)));
```

Посчитать сумму о одно до десяти.

#### 2. Сложный код

```js
let total = 0;
let count = 1
while(count <= 10){
    total += count;
    count += 1;
}

console.log(total)
```

#### Абстракция

В пример 1.Простой код использованы словарь функций (sum, range) Словарь функций представляет собою набор функций которые выполняют определенную задачу.

Проблема в том, что невозможно создать словарь (функции), на все случаи жизни. Но, можно использовать абстрактный подход - **функции высшего порядка**:

Можно написать конкретный цикл для повторения конкретного действия, например для вывода элементов в консоль:

```js
for (let i=0; i<10; i++) console.log(i);
```

Если нужно данное действие выполнять желаемое количество раз (n), можно поместить цикл в функцию:

```js
function repeat(n){
    for (let i=0; i<n; i++) console.log(i);
}
```

Но, что если нужен не вывод в консоль, а другое действие? Тогда можно передавать функцию в качестве аргумента в повторяющую функцию:

```js
function repeat(n, action){
    for (let i=0; i<n; i++) action(i);
}

repeat(10, console.log);
```

Можно не передавать заранее описанную функцию в качестве параметра, можно в ее тело передать в качестве аргумента значения:

```js
let labels = [];
repeat(10, i => labels.push(i+1));

console.log(labels);
```

В примере выше, опущены фигурные скобки, т.к. тело функции короткое и однострочное.

#### Типы функций высшего порядка

Функции высшего порядка бывают двух типов:

1. Функции возвращающие другие функции (замыкания)
2. Функции принимающие другие в функции в качестве своих аргументов. Функция аргумент называют callback функцией.
   2.1. Функции меняющие другие функции
   2.2. Функции изменяющие поток выполнения

##### 1. Функции возвращающие другие функции

```js
function greaterThan(n){
    return m => m > n;
}

let greaterThan10 = greaterThan(10);
console.log(greaterThan10(11)); // true
```

##### 2 Функции меняющие другие функции

```js
function calc(x, action, y){
  return action(x, y);
}

function minus(x,y){
  return x-y;
}

console.log(calc(5, minus, 1)) // 1 
```
```

##### 2.1. Функции меняющие другие функции

```js
function noisy(f){
    return (...args) => {
        console.log('calling with', args);
        let result = f(...args);
        console.log('called with', args, ', returned', result);
        return result;
    }
}

noisy(Math.min)(3, 2, 1); 
// calling with [3, 2, 1]
// called with [3, 2, 1], returned 1
```

Функция `noisy` принимает другую функцию нахождения минимума в качестве аргумента и возвращает с помощью стрелочной конструкции "болтливую" версию, которая оповещает о начале и конце вызова. Для передачи аргументов болтливой функции используется цепочный вывоз:

```js
noisy(Math.min)(3, 2, 1);
```

##### 2.2. Функции изменяющие поток выполнения

```js
function unless(test, then){
    if (!test) then();
}

repeat(3, n => {
    unless(n%2 == 1, ()=>{
        console.log(n, 'is even');
    })
})
// 0 is even
```

Функции высшего порядка могут быть методами в стандартных структурах данных JavaScript их называют итераторами.

### Итераторы

Это методы высшего порядка, которые могут работать с итерируемыми структурами данных:

- массивы
- строки
- Map
- Set

Итераторы принимают в качестве аргумента предикат, т.е. функцию возвращающую true либо false.

Большинство итераторов, кроме reduce, могут принимать 3 аргумента:

- element текущий элемент массива, обязательный
- index текущий элемент массива, опциональный
- array исходный массив, опциональный

#### forEach()

Метод похожий на функцию `for of`:

```js
["A", "B", "C"].forEach(item => console.log(item));
```

Меняет текущий массив, возможен ранний выход через throw.

#### filter

Что бы отфильтровать элементы в массиве можно создать функцию высшего порядка принимающую два аргумента:

- массив
- условия отбора (тестирующая функция).

```js
function filter(array, test){
    let passed = [];
    for (let element of array){
        if(test(element)){
            passed.push(element);
        }
    }
    return passed;
}

console.log(filter(SCRIPTS, script => scripts.living));
```

Чистая функция не модифицирует массив SCRIPTS а создает новый в соответствии с тестовыми условиями (функцией).

Как и forEach, filter является стандартным методом массива.

Предположим у нас есть массив объектов, где каждый объект содержит имя студента и его оценку за экзамен:

```js
const students = [
    { name: 'John', score: 80 },
    { name: 'Jane', score: 90 },
    { name: 'Bob', score: 70 },
    { name: 'Alice', score: 85 },
    { name: 'Charlie', score: 95 },
    { name: 'Dave', score: 75 },
    { name: 'Eve', score: 85 },
    { name: 'Frank', score: 90 },
    { name: 'Grace', score: 80 },
    { name: 'Henry', score: 85 }
];
```

Мы хотим вывести только тех студентов, у которых оценка больше 80.

```js
const goodStudents = students.filter(student => student.score > 80);
```

Используя метод console.table() можно вывести массив в виде таблицы:

```js
console.table(goodStudents);
```

#### map

Создадим функцию высшего порядка, которая трансформирует элементы массива, по заданному условию (функции).
Предположим мы хотим вывести не объекты массива SCRIPTS а свойство name этих объектов:

```js
function map(array, transform){
    let mapped = [];
    for(let element of array){
        mapped.push(transform(element));
    }
    return mapped;
}

console.log(map(SCRIPTS, s => s.name))
```

**map** также стандартный метод массива.

Предположим, что мы хотим не просто вывести студентов которые набрали 80 и более баллов, но мы хотим вывести вообще всех студентов. У тех кто прошел экзамен должно быть слово "passed", а у тех кто не прошел должно быть "Not passed":

```js
const result = students.map(student => {
    if (student.score >= 80) {
        return { name: student.name, score: student.score, result: "passed" };
    } else {
        return { name: student.name, score: student.score, result: "Not passed" };
    }
});

console.table(result);
```

В данном примере мы передаем методу map анонимную функцию, таким образом метод является функцией высшего порядка.

#### reduce

Напишем функцию суммаризации (подсчет суммы значений массива) по заданным признакам:

```js
function reduce(array, combine, start){
    let current = start;
    for(let element of array)
        current = combine(current, element);
    return current;
}

console.log(reduce([1, 2, 3, 4], (a, b) => a+b, 0));
```

Встроенный в массив метод reduce на примере расчета общей сумму баллов всех студентов:

```js
const totalScore = students.reduce((acc, student) => acc + student.score, 0);
console.log(totalScore);
```

1. Первый аргумент в примере у метода reduce() это анонимная стрелочная функция обратного вызова. Данная функция принимает свои два аргумента:
   - acc - аккумулятор (временное хранилище которое передается при каждой итерации)
   - student - текущий элемент (student) из массива students
2. Второй аргумент - 0, это первоначальное значение аккумулятора.
3. Третий аргумент - индекс текущего элемента.
4. Четвертый аргумент - сам массив.

Чаще всего в reduce() используется первые два аргумента.

В качестве аккумулятора можно использовать объект и это расширяет возможности метода:

```js
const {sum, count} = SCRIPTS.reduce((acc,b) => {
    if(b.living == true) {
        acc.sum+=b.year
        acc.count++
    }
    return acc
},{sum: 0, count: 0})

console.log(Math.round(sum/count));
```

#### some

Используется для поиска хотя бы одного нужного элемента в массиве. Например, чтобы выяснить есть ли среди студентов прошедшие практику:

```js
const hasPassed = students.some(student => student.score >= 80);
console.log(hasPassed); // true
```

Функция обратного вызова вызывается для каждого элемента итерации и если один из них возвращает true, то some() возвращает true и завершает работу на первом попавшемся элементе.

#### every

Обратный методу some(). В массиве все элементы должны соответствовать заданному условию. Например, чтобы выяснить все ли студенты прошли практику:

```js
const hasPassed = students.every(student => student.score >= 80);
console.log(hasPassed); // false
```

#### find

Возвращает первый элемент, который соответствует условию. В противном случае возвращает undefined:

```js
const student = students.find(student => student.score >= 80);
console.log(student); // { name: 'Jane', score: 90 }
```

Возвращает первое найденное вхождение. Позволяет искать неточное совпадение.

#### findIndex

Возвращает индекс первого элемента, который соответствует условию. В противном случае возвращает -1:

```js
const index = students.findIndex(student => student.score >= 80);
console.log(index); // 1
```

Возвращает индекс первого вхождения. Позволяет искать неточное совпадение.

### Деструктуризация

Позволяет распаковать значения из объекта/массива в переменные.

#### Деструктуризация массива

Позволяет сохранять значения из массива в отдельные переменные:

```js
const numbers = [1, 2, 3];
const [a, b, c] = numbers;
console.log(a); // 1
console.log(b); // 2
console.log(c); // 3
```

При деструктуризации массива первый элемент пойдет в первую переменную, второй элемент - во вторую и т.д, т.е. порядок сохранится.
Переменных может быть меньше или больше чем в массиве, при этом переменным можно задать значение по умолчанию:

```js
const arr = [1, 2, 3];
let [a, b, c, d=10] = arr;
console.log(d); // 10

arr.push(4);
[a, b, c, d=10] = arr;
console.log(d); // 4
```

Можно даже пропускать переменные:

```js
const arr = [1, 2, 3];
let [a, , b] = arr;
console.log(b); // 3
```

Деструктуризировать можно и многоуровневый массив:

```js
const arr = [1, 2, [3, 4]];
let [a, b, [c, d]] = arr;
console.log(d); // 4
```

Можно задать значение по умолчанию:

```js
const arr = [1, 2, 3];
let [a, b, c, d=10] = arr;
console.log(d); // 10
```

#### Деструктуризация объекта

Можно использовать деструктуризацию значений из объектов, где порядок свойств не важен:

```js
const person = { name: 'John', age: 30, city: 'New York' };
let { name, age, city } = person;
console.log(name); // John
console.log(age); // 30
console.log(city); // New York
```

Название переменных должно совпадать с именами свойств объекта. Но, можно переименовать любое свойство при деструктуризации:

```js
const person = { name: 'John', age: 30, city: 'New York' };
let { name: userName, age: userAge, city: userCity } = person;
console.log(userName); // John
console.log(userAge); // 30
console.log(userCity); // New York
```

Можно деструктуризировать вложенные объекты:

```js
const user = { name: 'John', info: { age: 30, city: 'New York' } };
let { info: { age, city } } = user; // info тут не как свойство, а как путь внутрь другого объекта
console.log(age); // 30
console.log(city); // New York
```

При деструктуризации объекта можно задавать переменные по умолчанию:

```js
const person = { name: 'John', age: 30, city: 'New York' };
let { name: userName = 'John Doe', age: userAge = 0, city: userCity = 'New York' } = person;
console.log(userName); // John Doe
console.log(userAge); // 30
console.log(userCity); // New York
```

Значение по умолчанию можно задать и для вложенного объекта, которого не существует:

```js
const user = { name: 'John' };
let { name, old: { age = 30 } = {}} = user;
console.log(name, age); // John 30
```

#### Деструктуризация параметров функции

Удобно пользоваться деструктуризацией параметров функции переданных массивом:

```js
function pri([n0, n1, n2, n3]) {
    console.log( n1, n3);
}

pri([1, 2, 3, 4]); // 1 4
```

Или параметров функции переданных в виде объекта:

```js
function pri({n0, n1, n2, n3}) {
    console.log( n1, n3);
}

pri({n0: 1, n1: 2, n2: 3, n3: 4}); // 2 4
```

При передаче параметров функции при деструктуризации, можно задать значения по умолчанию:

```js
function pri({n0 = 1, n1 = 2, n2 = 3, n3 = 4}) {
    console.log( n1, n3);
}

pri({n0: 1, n1: 2, n2: 3, n3: 4}); // 2 4
pri({n1: 2, n3: 4}); // 2 4
pri({}); // 2 4
pri(); // TypeError: Cannot read properties of undefined (reading 'n1')
```

Ошибка возникала потому был передан неопределенный массив, что undefined, таже ошибка возникнет и при деструктуризации null:

```js
const obj = null;
let { name } = obj; // TypeError: Cannot destructure property 'name' from 'null'
```

#### Деструктуризация с rest

Деструктруризацию объекта в сочетатании с rest оператором:

```js
const obj = { name: 'John', age: 30, city: 'New York' };
let { name, ...rest } = obj;
console.log(rest); // {age: 30, city: 'New York'}
```

Деструктуризация массива в сочетатании с rest оператором:

```js
const arr = [1, 2, 3, 4];
let [a, b, ...rest] = arr;
console.log(rest); // [3, 4]
```

Оператор rest должен быть один и в конце, в него попадут все остальные свойства, включая вложенные объекты.

### Сериализация

Свойства объектов не содержат значения, а всего лишь захватывают их указатель. Если у нас есть массив объектов или массивов, тогда происходит двойная адресация ссылки ссылаются на ссылки памяти, содержащие реальные значения. Можно сделать дамп памяти для отправки содержимого по сети, но это не удобно и долго. Для того, что бы сохранить чистые данные без привязки к участками памяти, существует процедура сериализации. Сереализованные данные легко переносить по сети между разными устройствами или с разной архитектурой.

#### JSON

Java Script Object Notation

Формат очень похож на объекты JS, но имена свойств (ключи) обрамлены двойными кавычками, в нем не функций, не должно быть комментариев, в конце группы ключей не ставят запятые:

```json
{
    "name": "John",
    "age": 30
}
```

##### JSON.stringify

Для конвертации объекта JS в строкове представление JSON:

```js
const person = { name: 'John', age: 30 };
const json = JSON.stringify(person);
console.log(json); // {"name":"John","age":30}
```

Метод принимает 3 аргумента:

1. Объект, который нужно конвертировать в JSON (обязательный)
2. Функция-преобразователь, применится ко всем элементам(необязательный)
3. Количество пробелов, которое будет в качестве отступов в JSON (необязательный)

##### JSON.parse

Для конвертации JSON в объект JS:

```js
const json = '{"name": "John", "age": 30}';
const person = JSON.parse(json);
console.log(person); // { name: 'John', age: 30 }
```

## ECMAScript

### 01.Lecture

В ES2015 появились новые операторы:

- **spread** - распаковывает массив (объект) или другие структуры данных в атомарные элементы
- **rest** - принимает неограниченное количество параметров

#### оператор распаковки массива/объекта

**Spread** - расширять, распространять.

Любая функция содержит служебную переменную arguments, которая является псевдомассивом. Псевдомассив не имеет стандартных методов как настоящий массив, типа forEach. Поэтому при передаче в функцию неограниченного количества переменных, мы не сможешь по ним итерироваться как по массиву. Можно только с помощью классического for, что не всегда удобно. Использую spread оператор:

```js
function sum(a, b, c) {
    const args = [...arguments];
    console.log(args);
}
```

Распаковывает массив (объект) или другие структуры данных:

```js
const sum = (a, b, c) => {
    return a + b + c;
}
const arr = [1, 2, 3];
console.log(sum(...arr)); // 6
```

Можно распаковывать внутри другого массива или объекта:

```js
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const arr3 = [...arr1, ...arr2];
console.log(arr3); // [1, 2, 3, 4, 5, 6]
```

#### оператор упаковки

**Rest** - остальные, подобные, другие. Позволяет собрать другие оставшиеся аргументы в массив, тогда не нужно будет использовать встроенный псевдомассив функций arguments:

```js
let summa
function sum(...rest) {
    for (let i = 0; i < rest.length; i++) {
        summa += args[i];
    }
}

sum(1, 2, 3, 4, 5);
console.log(summa); // 15
```

rest можно комбинировать с обычными аргументами функции:

```js
function sum(name, lastname, ...rest) {
    console.log(`your name is ${name} surname is ${lastname} and other ${rest}`);
}
```

В последнем примере внутри переменной **rest** будет массив, если даже оставшееся значение всего одно.

Оператор упаковки можно использовать только в конце аргументов функции.

#### spread + rest

```js
function addOne(...ar){
    let sum = 0;
    for (let x of ar) sum+=x;
    return sum;
}

console.log(addOne(1, 2, 3)); // 6
let arr = [1, 2, 3]
console.log(addOne(arr)); // 01,2,3 
console.log(addOne(...arr)); // 6
```

При передачи отдельных цифр как аргументов функция addOne собирает их в один массив (rest), по которому пробегается цикл for of, суммируя элементы. В итоге возвращается сумма в виде числа.

Если же передать массив в addOne, то он упаковывается в еще один массив [arr], поэтому функция for of пробегается не по элементам массива arr, а по элементам внешнего для arr массива, где он сам элемент. Далее, идет приведение типов: цифрового sum и массива arr, которые приводятся к строке, поэтому функция возвращает конкатенированную строку "01,2,3".

Чтобы посчитать сумму массива к нему нужно применить оператор распаковки (spread).

## 06.Chapter of eloquent JS (3 edition)

### Инкапсуляция

In capsule *lat.* - в оболочке. Инкапсуляция это изолирование свойств и методов внутри объекта, чтобы они не могли быть изменены извне. 

Свойства и методы внутри объекта имеют 4 уровня доступа (по возрастанию сложности):

1. public - публичные
2. protected - защищенные `_`
3. Symbol - скрытие `[]`
4. private - приватные `#`

#### Public

Публичные свойства и методы видны всему приложению и любая его функция может их использовать. Принято именовать такие свойство как обычные переменные.

```js
class Car {
    constructor(brand, model, distanceTraveled) {
        this.brand = brand;
        this.model = model;
        this.distanceTraveled = distanceTraveled;
        this.isRunning = false;
    }
    start() {
        this.isRunning = true;
    }
    stop() {
        this.isRunning = false;
    }
    getGasolineVolume() {
        
        console.log(this.distanceTraveled / 100 * 9);
    }
}

const car = new Car("Toyota", "Camry", 50000);
car.distanceTraveled = "qwer";
car.getGasolineVolume(); // NaN
```

В данном случае свойству `distanceTraveled` по ходу кода случайно присвоенно значение "qwer", что приводит к невозможности посчитать остаток топлива.

Что бы избежать случайного или непредвиденного воздействия извне, можно использовать специальные свойства и методы.

#### Protected

Защищенные свойства и методы доступны только внутри объекта (класса) или его наследников (подклассов). По джентельменскому соглашению имена таких свойств должны начинаться с одного символа подчеркивания `_`.

Добавим защищенное свойство `_driver`:

```js
class Car {
    _driver;
    constructor(brand, model, distanceTraveled, driver) {
        this.brand = brand;
        this.model = model;
        this.distanceTraveled = distanceTraveled;
        this.isRunning = false;
        this._driver = driver;
    }
    start() {
        this.isRunning = true;
    }
    stop() {
        this.isRunning = false;
    }
    getGasolineVolume() {
        
        console.log(this.distanceTraveled / 100 * 9);
    }
}

const car = new Car("Toyota", "Camry", 50000, "Jhon");
car._driver = "Jane";
console.log(car._driver); // Jane
```

`_driver` программно можно изменить, но знак подчеркивания говорит программисту, что это особое свойство, к которому нужно относится внимательнее.

#### Symbol

C помощью Symbol, можно создать так называемые «скрытые» свойства объекта. Эти свойства не получится нечаянно перезаписать обратившись к нему по строковому имени, обратившись из различных частей программы по имени, они не отображаются при цикле `for in`.

```js
let id = Symbol("id");
let buddy = {[id]: "Жучка"}
buddy.id = "Шарик";
console.log(buddy[id]); // Жучка
```

Данные свойства будут всегда уникальными если даже использовать одинаковые описания:

```js
let index = Symbol("id");
console.log(index === buddy[id]); // false
```

Чтобы обратиться к свойству его нужно знать его точное имя. И в тоже время объекты со скрытами свойствами можно клонировать с помощью `Object.assign`, в отличие от приватных свойств.

#### Private

В ES2022 было введено приватное совойство на уровне языка (не джентельменское соглашение). Доступ к приватным свойствам и методам возможен только внутри класса, которому они принадлежат. По соглашению приватные свойства и методы начинаются с символа решетки `#`.

Сделаем приватным свойство `#distanceTraveled`:

```js
class Car {
    _driver;
    #distanceTraveled;
    constructor(brand, model, distanceTraveled, driver) {
        this.brand = brand;
        this.model = model;
        this.#distanceTraveled = distanceTraveled;
        this.isRunning = false;
        this._driver = driver;
    }
    start() {
        this.isRunning = true;
    }
    stop() {
        this.isRunning = false;
    }
    getGasolineVolume() {
        
        console.log(this.#distanceTraveled / 100 * 9);
    }
}

const car = new Car("Toyota", "Camry", 50000);
car.#distanceTraveled = "qwer"; // Uncaught SyntaxError: Private field '#distanceTraveled' must be declared in an enclosing class
car.[#distanceTraveled] = "qwer"; // Uncaught SyntaxError: Private field '#distanceTraveled' must be declared in an enclosing class
```

Для изенения приватных свойств и методов успользуют геттеры и сеттеры.

Приватные свойства не клонируются, при копировании объекта.

### Геттеры и сеттеры

Каждый раз при использовании точечной нотации при обращении к свойству объекта под капотом используюется геттеры и сеттеры.

Геттеры и сеттеры в JavaScript — это специальные методы доступа к свойствам объекта, которые позволяют перехватывать чтение и запись значений.

```js
class Car {
    _driver;
    #distanceTraveled;
    constructor(brand, model, distanceTraveled, driver) {
        this.brand = brand;
        this.model = model;
        this.#distanceTraveled = distanceTraveled;
        this.isRunning = false;
        this._driver = driver;
    }

    get distanceTraveled() {
        return this.#distanceTraveled;
    }
    set distanceTraveled(value) {
        if(typeof value !== "number") console.log("its not number");
        this.#distanceTraveled = value;
    }
    start() {
        this.isRunning = true;
    }
    stop() {
        this.isRunning = false;
    }
    getGasolineVolume() {
        
        console.log(this.#distanceTraveled / 100 * 9);
    }
}

const car = new Car("Toyota", "Camry", 50000);

console.log(car.distanceTraveled); // 50000
car.distanceTraveled = "qwer"; // its not number
car.distanceTraveled = 100000;
console.log(car.distanceTraveled); // 100000
```

У геттеров нет аргументов, а сеттер наоборот должен иметь аргумент.
Геттеры и сеттеры должны иметь return, их нужно вызыват как свойства без круглых скобок.

#### Интерфейсы

Это ограниченный набор **публичных** свойств и методов (включая геттеры и сеттеры), которые предоставляют полезную функциональность на более абстрактном уровне, пряча тем самым их точную реализацию.

Основная идея ООП в разбиении программы на мелкие куски независимого кода, каждый кусок сам следит за своим состоянием и его изменением. Если другой программист будет работать со вторым куском, то ему не обязательно знать как работает первый.
Разные куски взаимодействуют между собой с помощью **интерфейсов**, т.е. публичных свойств.

У объекта могут быть и **приватные** свойства и методы, которые не являются частью интерфейса.

В отличии от других ЯП (например, java) в JS нет механизма разделения на публичные и приватные значения. Но, существует договоренность приватные свойства начинать с символа подчеркивания.

## 02.Lecture

### Классы

[Систему прототипирования](#prototype) удобно использовать для задания экземпляров, которые имеют абсолютно одинаковые свойства и методы иначе каждому экземпляру придется добавлять свои методы и свойства. Для создания экземпляров которые имеют часть одинаковых свойств и часть уникальных удобно применять классы (class). Классы в JS появился в ES2015.

```js
// Класс робот-пылесос.
class RobotVacuumCleaner {
    // Свойства класса.
    model = "Romba-1";
    power = 200;
    batterySize = 2100;
    boxSize = 0.5;
    workTime = 45;
    counterOfStarts = 0;
    isFull = false;
    isObstacle = false;
    isUVLampOn = false;
    // Конструктор класса можно не указывать, если он пустой, он добавится автоматически
    constructor() {
    }
    // Методы класса.
    startCleaning() {
        this.counterOfStarts++;
        console.log('I am cleaning... I have been started: ',
        this.counterOfStarts, 'times.');
    }
    goCharge() {
        console.log('I am going to charge...');
    }
    switchUVLamp() {
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    }
}

const Roomba = new RobotVacuumCleaner();
Roomba.isUVLampOn = true;
setTimeOut(Roomba.switchUVLamp, 5000);
```

Все схоже с объектом, только добавился конструктор, в данном примере он пустой поэтому конструктор можно не указывать, он добавиться автоматически. Свойства внутри присваиваются через равно и методы объявляются по другому. Но, ультрафиолетовая лампа не выключается, т.к. setTimOut запускает выключатель лампы через 5 секунд когда контекст методов класса исчезает и this начинает ссылаться на глобальный объект.

#### Способы создания классов

Ключевое слово class используеся для объявления двух видов классов:

1. именованного класса
2. анонимного классового выражения

Т.к. классы родственны функциям, то они имеют похожие механизмы всплытия.

##### Именованный класс

Данный способ не обладает всплытием:

```js
let classExpression = class { getWord() { return "hello"; } };
const obj = new classExpression();
console.log(obj.getWord());
```

Поэтому объявлять объекты и работать с ними можно только после объявления класса.

##### Анонимное классовое выражение

Выражение "всплывает", т.е. его можно использовать в любом месте программы, т.к. оно создается до выполениня основного кода.

```js
const obj = new classDeclaration();
console.log(obj.getWord());
class classDeclaration { getWord() { return "hello"; } };
```

Именнованный класс и анонимное выражение возвращает конструктор, который в свою очередь с помощью ключевого слова new создает объект.

#### bind()

Используя стандартный метод объектов bind можно сохранить контекст.

```js
// Класс робот-пылесос.
class RobotVacuumCleaner {
    // Свойства класса.
    model = "Romba-1";
    power = 200;
    batterySize = 2100;
    boxSize = 0.5;
    workTime = 45;
    counterOfStarts = 0;
    isFull = false;
    isObstacle = false;
    isUVLampOn = false;
    // Используем его, чтобы привязать все методы класса к контексту - текущему объекту (this).
    constructor() {
        this.startCleaning = this.startCleaning.bind(this);
        this.goCharge = this.goCharge.bind(this);
        this.switchUVLamp = this.switchUVLamp.bind(this);
    }
    // Методы класса.
    startCleaning() {
        this.counterOfStarts++;
        console.log('I am cleaning... I have been started: ',
        this.counterOfStarts, 'times.');
    }
    goCharge() {
        console.log('I am going to charge...');
    }
    switchUVLamp() {
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    }
}
// Создадим экземпляр класса.
const Roomba = new RobotVacuumCleaner();
Roomba.isUVLampOn = true;
setTimeout(Roomba.switchUVLamp, 2000); // UV lamp is not working.
```

Можно еще проще. В случае с классом хорошо работают стрелочные методы, которые не имеют своего контекста, и которые по умолчанию ссылаются через уровень к глобальному для них объекту, т.е. в наше случае к своему классу:

```js
// Класс робот-пылесос.
class RobotVacuumCleaner {
    // Свойства класса.
    model = "Romba-1";
    power = 200;
    batterySize = 2100;
    boxSize = 0.5;
    workTime = 45;
    counterOfStarts = 0;
    isFull = false;
    isObstacle = false;
    isUVLampOn = false;
    // Конструктор класса, мы изучим его подробнее на следующем уроке.
    constructor() {
    }
    // Методы класса.
    startCleaning = () => {
        this.counterOfStarts++;
        console.log('I am cleaning... I have been started: ',
        this.counterOfStarts, 'times.');
    }
    goCharge = () => {
        console.log('I am going to charge...');
    }
    switchUVLamp = () => {
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    }
}
// Создадим экземпляр класса.
const Roomba = new RobotVacuumCleaner();
Roomba.isUVLampOn = true;
setTimeout(Roomba.switchUVLamp, 2000); // UV lamp is not working.
```

Тут не нужно даже инициализировать конструктор, методы отрабатывают хорошо, с привязкой к контексту нашего класса.

#### Методы внутри класса

Методы внутри класс можно задат двумя способами:

1. В виде функции (как обычные функции)
2. В виде свойства (стрелочные функции)

##### Метод как функция

```js
class Box {
  unlock() { this.locked = false; }  // Метод класса
}
```

Такой метод создается только один раз в классе, экономя место в памяти

##### Метод как свойство

```js
class Box {
  unlock = () => { this.locked = false; }  // Свойство-функция
}
```

Такой метод создается каждый раз при создании экземпляра класса, но занимает место в памяти больше

##### Переопределение методов

Когда определяется свойство к текущему объекту оно добавляется к текущему объекту, но если свойство есть в родителе, то оно переопределяется именно в текущем объекте, не затрагивая родителя:

```js
Rabbit.prototype.teeth = "small";
console.log(killerRabbit.teeth);
// → small
killerRabbit.teeth = "long, sharp, and bloody";
console.log(killerRabbit.teeth);
// → long, sharp, and bloody
console.log((new Rabbit("basic")).teeth);
// → small
console.log(Rabbit.prototype.teeth);
// → small
```

Код иллюстрирует, как выражение `new Rabbit("basic")).teeth` наследует отсутствующее изначально свойство teeth у родителя.

Переопределение использовано например в стандартном методе toString() массива:

```js
console.log(Array.prototype.toString ==
            Object.prototype.toString);
// → false
console.log([1, 2].toString());
// → 1,2
console.log({f: 1, s: 2}.toString());
// [object Object]
```

Как видно метод toString() у объекта и массива разные. В массиве метод переобределен чтобы выводит строку значений как это делает функция join().

## 03.Lecture

### `__proto__`

Устаревший способ наследования, но рабочий. Указывает на какой объект родитель ссылаться. 
Если свойство `__proto__` не задано, то оно по умолчанию ссылается на Object.

Зададим родителя:

```js
// Объект робот-пылесос.
const VacuumCleaner = {
    Model: "vacuum cleaner",
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    startCleaning: function () {
        this.counterOfStarts++;
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of VacuumCleaner');
        console.log('I am cleaning... I have been started: ', this.counterOfStarts, 'times.');},
        goCharge: function () {
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of VacuumCleaner');
        console.log('I am going to charge...');
    }
};
```

Зададим серию наследников:

```js
// Объект робот-пылесос.
const DancingSeries = {
    // Объявляем новые свойства и переопределить свойство model.
    model: "dancing series",
    power: 200,
    batterySize: 2100,
    boxSize: 0.5,
    workTime: 45,
    isUVLampOn: false,
    // Добавляем новый метод.
    switchUVLamp: function () {
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of DancingSeries');
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    },
    // Делаем ссылку на прототип от родителя.
    __proto__: VacuumCleaner,
};
```

Зададим наследника серии:

```js
// Объект робот-пылесос.
const Samba = {
    // Обновляем свойства под конкретную модель.
    model: "Samba-1",
    power: 250,
    batterySize: 2500,
    workTime: 50,
    // Делаем ссылку на прототип от родителя.
    __proto__: DancingSeries,
};
```

Обратимся к свойствам и методам родителя через серию:

```js
// Обращение к свойствам объекта.
console.log(Samba.model); // "Samba-1"
console.log(Samba.isFull); // false
// Вызов методов объекта.
Samba.startCleaning();
// I am the method of VacuumCleaner
// 'I am cleaning... I have been started: 1 times.'
Samba.isUVLampOn = true;
Samba.switchUVLamp();
// I am the method of DancingSeries
// 'UV lamp is not working.'
Samba.goCharge();
// I am the method of VacuumCleaner
// 'I am going to charge...'
```

Механизм прототипов позволяет использовать методы объекта Array в пользовательских массивах, который в свою очередь через свое **proto** ссылкается на Object.

Создадим еще одного конечного наследника и переобределим в нем метод startCleaning(), которые есть в родителе:

```js
// Объект робот-пылесос.
const Djaiv = {
    // Обновляем свойства под конкретную модель.
    model: "Djaiv-1",
    power: 250,
    batterySize: 2500,
    workTime: 50,
    // Переопределим метод startCleaning.
    startCleaning: function () {
        this.counterOfStarts++;
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of Djaiv');
        console.log('I am Djaiv, and I am cleaning... I have been started: ', this.counterOfStarts, 'times.');
    },
    // Делаем ссылку на прототип от родителя.
    __proto__: DancingSeries,
};

Samba.startCleaning();
// I am the method of VacuumCleaner
// 'I am cleaning... I have been started: 1 times.'
Djaiv.startCleaning();
// I am the method of Djaiv
// I am Djaiv, and I am cleaning... I have been started: 1 times.
```

startCleaning() для Djaiv является переопределенным, но у родителя и наследников остался прежним.

### [[Prototype]]

В ES2015 произошел отказ от свойства __proto__, ему на смену было введено внутреннее свойство [[Prototype]].
Это ссылка на прототип объекта, которая не доступна для просмотра и редактированию пользователю напрямую. В JS двойными квадратными скобками [[]] обозначают внутренние свойства языка, например: [[Configurable]], [[Get]], [[Set]], [[Value]], [[Writable]] и т.д.

Для работы с [[Prototype]] используют 2 метода: Object.getPrototypeOf и Object.setPrototypeOf.

#### Object.getPrototypeOf

Позволяет получить ссылки на прототип объекта по цепочке:

```js
// Получим прототип для объекта Djaiv.
const DjaivProto = Object.getPrototypeOf(Djaiv);
console.log(DjaivProto.model); // dancing series
const DjaivProtoProto = Object.getPrototypeOf(DjaivProto);
console.log(DjaivProtoProto.model); //vacuum cleaner
const DjaivProtoProtoProto =
Object.getPrototypeOf(DjaivProtoProto);
console.log(DjaivProtoProtoProto); // [object Object]
```

Object не имеет прототипов, т.к. является самым первым, поэтому он вернет null.

#### Object.setPrototypeOf

Зададим новоую серию наследников musicSeries:

```js
// Объект робот-пылесос.
const MusicSeries = {
    // Объявляем новые свойства и переопределяем свойство model.
    model: "music series",
    power: 200,
    batterySize: 2100,
    boxSize: 0.5,
    workTime: 45,
    // Добавляем новый метод.
    startWipe: function () {
    // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of MusicSeries');
        console.log('I am starting to wipe the floor...');
    },
    // Делаем ссылку на прототип от родителя.
    __proto__: VacuumCleaner,
};
```

Создадим конечного наследника и используем setPrototypeOf с двумя параметрами - объект наследник, объект родитель:

```js
// Объект робот-пылесос.
const Blues = {
    // Обновляем свойства под конкретную модель.
    model: "Bluees-1",
    power: 250,
    batterySize: 2500,
    workTime: 50,
};
// Установим прототип для робота.
Object.setPrototypeOf(Blues, MusicSeries);

console.log(Object.getPrototypeOf(Djaiv).model) // dancing series
console.log(Object.getPrototypeOf(Blues).model) // music series

Djaiv.startWipe(); // Uncaught TypeError: Djaiv.startWipe is not a function
```

### Конструктор объекта

Конструктор объекта - вызываемая с помощью оператора new функция, которая создает объект и проводит инициализацию.
Функцию конструктор объекта принято называть с большой буквы, внутри нее свойства и методы объявляют с помощью this.

Этапы создания объекта с помощью конструктора:

- создание нового пустого объекта;
- пустой объект присваивается свойству this;
- выполняется тело функции-конструктора;
- возвращается новый объект, либо this:

```js
function Test1(name) {
    this.a = 1;
    return {name};
}

const test1 = new Test1("test1"); // { name: 'test1' }

function Test2(name) {
    this.b = 2;
    this.name = name;
}

const test2 = new Test2("test2"); // { b: 2, name: 'test2' }
```

Обычная функция возвращающей без return undefined, а конструктор без return возвращает this, c return указанный объект.

Если попытаться веррнуть примитов, то объект не созадется:

```js
function Test3(name) {
    this.name = name;
    return 1;
}

const test3 = new Test3("test3"); // undefined
```

Создадим конечного наследника от первой серии пылесосов:

```js
// Конструктор объекта робот-пылесос.
function Samba(serailNumber) {
    // Создаем свойства объекта, используя this.
    this.serialNumber = serailNumber;
    this.model = "Samba-1";
    this.power = 250;
    this.batterySize = 2500;
    this.workTime = 50;
    // Делаем ссылку на прототип от родителя.
    this.__proto__ = DancingSeries;
}
// Создадим экземпляр нового объекта.
const Samba1 = new Samba(1014778);
console.log(Samba1.serialNumber); // 1014778
console.log(Samba1.startCleaning()); // I am the method of VacuumCleaner
// I am cleaning... I have been started: 1 times.
```

Конструкторы ускоряют процесс создания множества однотипных объектов:

```js
// Создадим 10 роботов пылесосов Samba, как на конвейере. 
// const robots = [];
for (let index = 0; index < 10; index++) {
    // Создадим экземпляр нового объекта и добавляем его в массив наших роботов, каждый с уникальным серийным номером.
    robots.push(new Samba(index));
}
console.log(robots[3].serialNumber); // 3
console.log(robots[7].serialNumber); // 7
```

В примере с конструкоторм мы указали родителя с помощью this.**proto**, а можно с помощью свойства prototype:

```js
function Samba(serailNumber) {
    this.serialNumber = serailNumber;
    this.model = "Samba-1";
    this.power = 250;
    this.batterySize = 2500;
    this.workTime = 50;
}
// Делаем ссылку на прототип от родителя.
Samba.prototype = DancingSeries;
const Samba1 = new Samba(1014778);
console.log(Samba1.serialNumber); // 1014778
console.log(Samba1.startCleaning()); // I am the method of VacuumCleaner
// I am cleaning... I have been started: 1 times.

console.log(Samba1.__proto__); // {model: "dancing series", power: 200, batterySize: 2100, boxSize: 0.5, workTime: 45, ...}
console.log(Samba1.prototype); // undefined
console.log(Samba1.__proto__ === Samba.prototype); // true
```

Свойства `__proto__` есть у каждого объекта, оно позволяет найти родителя. Свойство же prototype есть только у нестрелочных функций, оно выполняет служебную роль при создании объекта и с помощью оператор new.

#### prototype

Методы это всего лишь свойства, хранящие значения фукнций:

```js
function speak(line) {
  console.log(`The ${this.type} rabbit says '${line}'`);
}
let whiteRabbit = {type: "white", speak};
let hungryRabbit = {type: "hungry", speak};

whiteRabbit.speak("Oh my fur and whiskers");
// → The white rabbit says 'Oh my fur and whiskers'
hungryRabbit.speak("Got any carrots?");
// → The hungry rabbit says 'Got any carrots?'
```

Обычно метод применяется к тому объекту из которого он был вызван и ключевое слово this в теле метода ссылается на этот объект.
В данном случае this можно рассматривать как эстрапараметр передаваемый отличным от обычного аргумента фукнции способом. Можно указать явно объект внутри call, который будет подставлен вметсо this в методе:

```js
speak.call(whiteRabbit, "Oh my fur and whiskers");
```

Любая фукнция воспринимает this как объект, но делает это по разному:

- классические функции под this подразумевуют свой объект
- стрелочные функции не имеют своего this, но могут обращаться к нему на уровень выше:

```js
let finder = {
  find(array) {
    return array.some(v => v == this.value);
  },
  value: 5
};
console.log(finder.find([4, 5])); // true
```

Если в данном контексте использовать классическую фукнцию с ключевым словом this внутри метода some, то мы не сможем выйти за пределы конекста и ничего не получится.

Другой способ создать объектный тип "кролик" с методом "говорить" использование вспомогательной функции, которая примет параметры: тип данных "кролик" и функцию "говорить". Можно создать много кроликов у которых похожие методы. Механизм, который позволяет это дела называется **prototype inheritance**.

```js
let empty = {};
console.log(empty.toString);
// → function toString(){…}
console.log(empty.toString());
// → [object Object]
```

Создали пустой объект, но у него уже есть метод toString(). Когда у объекта нет какого либо свойства (метода), оно будет искаться у его прототипа, если у прототипа нет такого свойства, то будет искаться у его прототипа и так далее, пока не будет достигнут объект без протолтипа:

```js
console.log(Object.prototype) // undefined
```

На этом принципе работают созданые пользователем объекты:

- Функции Function.prototype
- Массивы Array.prototype

Но можно переопределить прототипы или указать в качестве прототипа другой объект:

```js
let blackRabbit = Object.create(protoRabbit);
```

### Object.create

Метод позволяет также создавать новые объекты как и способы ранее. Аргументами принимает прототип и свойства нового объекта в формате словаря с ключами. Данный метод хорош тем, что в качестве первого аргумента может принимать null, тогда создаваемые объекты не будут привязаны к Object и не будут наследовать его методы такие как toString(), valueOf() и т.д. Иногда нужно создать объект без единого свойства и метода:

```js
const Samba1 = new Samba(101);
console.log(Samba1.toString()); // [object Object]

const Samba1 = Object.create(null);
console.log(Samba1.toString); // undefined
console.log(Samba1.__proto__); // undefined
```

Но, есть более удобные механизмы создания объектов и насследования, которые появились с приходом ES2015

### new

Оператор new позволяет правильно вызвать конструктор, которая как функция ничего не возвращает и создать объект, по алгоритму:

1. Создаем пустой объект.
2. Задает ссылку для this на созданый объект
3. Вызывает функцию конструктор.
4. Если у функции конструктора есть свойство prototype, то устанавливает его значения для свойства объекта `__proto__`
5. Устанавливает свойство constructor ссылкой на конструктор
6. Возвращает созданный объект

Самописный оператор new в виде фукнции в соотвествии с алгоритмом выше:

```js
function createObject(constructor) {
    // Создаем новый объект.
    const obj = {};
    // Установим новому объекту прототипом прототип функции-конструктора
    Object.setPrototypeOf(obj, constructor.prototype);
    // Вызовем функцию-конструктор, передав ей как this созданный на шаге 1 объект, и передадим остальные аргументы, если они были переданы в createObject
    const argsArray = Array.prototype.slice.apply(arguments);
    const result = constructor.apply(obj, argsArray.slice(1));
    // Вернем новый объект, если конструктор вернул примитивное значение или undefined, иначе вернем то, что вернул конструктор.
    if (!result || typeof result === 'string' || typeof result === 'number' || typeof result === 'boolean') {
        return obj
    } else {
        return result;
    }
}
// Создадим экземпляр нового объекта.
const Samba1 = createObject(Samba, 1014778);
// Проверим установку свойств в конструкторе.
console.log(Samba1.serialNumber); // 1014778
// Проверим, что прототип установился корректно, и мы можем вызывать методы из родительских объектов.
console.log(Samba1.__proto__); // {model: "dancing series", power: 200, batterySize: 2100, boxSize: 0.5, workTime: 45, ...}
console.log(Samba1.startCleaning()); // I am the method of VacuumCleaner
// I am cleaning... I have been started: 1 times.
// Проверим присвоение конструктора.
console.log(Samba1.constructor); // function Object() { [native code] }
```

### Коллекции

Начиная с ES6, JavaScript получила встроенные коллекции:

- Map
- Set
- WeakMap
- WeakSet

#### Map

Map — это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.

Предположим нужна структура данных для храненния возраста пользователей:

```js
let ages = {
    "Julia" : 62,
    "Boris" : 39,
    "Grandpa" : 402,
    "Eddie" : 10
};

console.log(`Julia is ${ages["Julia"]}`); // Julia is 62
console.log("Is Jack's age known?", "Jack" in ages); // Is Jack's age known? false
console.log("Is toString's age known?", "toString" in ages); // Is toString's age known? true
```

Видим проблему в последней строке. Метод (свойство) объекта toString (лешнее имя) и аналогичные свойство могут дать не тот результат, что ожидаем. В объекте ages нет элемента с именем toString, но в нем есть метод toString, поэтому возращается true.

Для решения проблемы лишних имен, можно создать объект без прототипа:

```js
const ages = Object.create(null);
ages.Julia = 62;
...
```

Можно использовать `Object.hasOwn(ages, "toString"); \\ false`

Помимо проблемы внутренних методов есть и другие проблемыпри использовании объекта как словаря:

- Ключи могут быть только строками или Symbol
- Объект напрямую не итеррируемы
- Нет свойства size, т.е. кол-во элементов объекта нужно считать вручную.

Поетому в ES2015 добавили конструктор Map(), который имеет преемущества перед объектом:

- Нет по умолчнию ни ключей ни методов
- Ключи могут быть любыми, включая цифры и объекты
- Имеется свойство size
- Можно итерироваться с помощью for/of или forEach()

Конструктор Map(), предназначены для создания структуры данных ассициированных пар ключ-значение. Ключи уникальны, а значения могут повторяться.

```js
let ages = new Map();
ages.set("Julia", 62);
ages.set("Boris", 39);
ages.set("Grandpa", 402);
ages.set("Eddie", 10);
console.log(ages.has("toString")); //false
```

`Map.set` возвращает при вызове объект Map, поэтому мы для установки значений можем использовать цепочку из методов set:

```js
let ages = new Map();
ages
    .set("Julia", 62)
    .set("Boris", 39)
    .set("Grandpa", 402)
    .set("Eddie", 10);

console.log(ages); // Map { "Julia" => 62, "Boris" => 39, "Grandpa" => 402, "Eddie" => 10 }
```

`Map` имеет недостаток, его нельзя напрямую серелизовать, например в JSON-строку.

##### Map и Object

Можно из объекта создать Map:

```js
let map = new Map(Object.entries(ages));
console.log(map); // Map { "Julia" => 62, "Boris" => 39, "Grandpa" => 402, "Eddie" => 10 }
```

Можнол из Map создать объект:

```js
let obj = Object.fromEntries(map);
console.log(obj); // { Julia: 62, Boris: 39, Grandpa: 402, Eddie: 10 }
```

##### Методы Map

- set(key, value) — записывает по ключу key значение value
- get(key) — возвращает значение по ключу или undefined, если ключ key отсутствует
- has(key)  — возвращает true, если ключ key присутствует в коллекции, иначе false
- delete(key) — удаляет элемент (пару «ключ/значение») по ключу key
- clear() — очищает коллекцию от всех элементов
- map.size — возвращает текущее количество элементов
- keys() — возвращает итерируемый объект по ключам
- values() — возвращает итерируемый объект по значениям
- entries() — возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for(..of..)
- forEach() — итератор, работающий так же, как и с массивом

#### Set

Set — это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
new Set(iterable) — создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его уникальные значения в новый Set

```js
let set = new Set([1, 2, 3, 4, 4, 4]);
console.log(set); // Set { 1, 2, 3, 4 }
set.add(4);
console.log(set); // Set { 1, 2, 3, 4 }
```

При повторных вызовах set.add() с одним и тем же значением ничего не происходит.

Перевести из Set в Array можно с помощью Array.from(set), но будут только уникальные значения элементов массива.

##### Методы Set

- set.add(value) — добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set
- set.delete(value) — удаляет значение, возвращает true, если value было во множестве на момент вызова, иначе false
- set.has(value) — возвращает true, если значение присутствует во множестве, иначе false
- set.clear() — удаляет все имеющиеся значения
- set.size — возвращает количество элементов во множестве

#### WeakMap

Map-подобная коллекция, не имеющая встроенных свойств и методов, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.

```js
let wm = new WeakMap();

let obj = {};
wm.set(obj, 'value');
console.log(wm.get(obj)); // 'value'
```

#### WeakSet

WeakSet — это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.

```js
let ws = new WeakSet();
let obj = {};
ws.add(obj);
console.log(ws.has(obj)); // true
```

WeakMap и WeakSet используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта. Если объект удаляется из
основного хранилища и нигде не используется, кроме как в качестве ключа в WeakMap или в WeakSet, то он будет удалён автоматически.

### Полиморфизм

Полиморфизм в JS основан на утиной типизации (duck typing): "Если, что-то похожее на утку крякает, то это утка".

Например у нас есть два объекта машина и мотоцикл, если эти оба объекта имеют метод start(), т.е. они зоводятся, то данные объекты можно объеденить одним понятием **транспортные средства** и применять к данным объектам соотвествующие методы:

```js
function startVehicle(vehicle) {
    if (typeof vehicle.start === 'function') {
        vihicle.start();
    } else {
        throw new Error('Not a vehicle');
    }
}

startVehicle(car);
startVehicle(bike);
```

Другой пример со встроенными объектами JS.
Когда вызываете функцию String() для строк, она вызывает метод toSting() у строчного-объекта, так на выводе получаем напечатанную строку.
Но, со стандартным объект [object Object] функция String() не работает, потомучто, метод toString() не определен и не известно как выводить содержимое конкретного объекта (особенно вложенного и многоуровнего).
Тем не менне, для объекта можно определить метод toString() и фукнция String() будет работать.:

```js
const user = {
    name: 'John',
    age: 30,
    toString() {
        return `${this.name} is ${this.age} years old`;
    }
};
console.log(String(user)); // John is 30 years old
```

Получается хороший подход - когда кусок кода написан для работы с объектами, которые имеют определенный интерфейс, в нашем случае toString(), то любой объект, поддерживающий этот интерфейс, будет работать с этим кодом. Данная техника называется полиморфизмом. Полиморфный код может работать со значениями любой формы, если они поддерживают определенный интерфейс.

Пример широко используемого интерфейса для массиво-подобных объектов - это свойство length. Свойство length доступно и для массивов, и для строк, а также для ряда других объектов

### static

Ключевое слово static используется в классах для определения статических методов и свойств, которые принадлежат самому классу, а не экземплярам этого класса.

```js
class MathUtils {
  static square(x) {
    return x * x;
  }
}

console.log(MathUtils.square(5)); //  25

const utils = new MathUtils();
console.log(utils.square);  // undefined (это НЕ метод экземпляра)
```

Пример использования статического метода в производстве:

```js
class Car {
    constructor(make, model) {
        this.make = make;
        this.model = model;
    }

    static createFromLicensePlate(licensePlate) {
        const make = licensePlate.slice(0, 2);
        const model = licensePlate.slice(2);
        return new Car(make, model);
    }
}

const ford = Car.createFromLicensePlate('AB123CD');
```

Статический метод createFromLicensePlate() используется для создания экземпляра класса Car из лицензионного номера автомобиля. Он не используется позже с объектом ford.

Статический метод или свойство можно также задать через присвоение его самому имени класса:

```js
Car.createFromLicensePlate = function(licensePlate){
    ...
}
```

#### Singleton

Синглтон (Singleton) - это паттерн проектирования, который гарантирует, что класс может иметь только один экземпляр. В JavaScript синглтон можно реализовать с помощью класса и статического метода, который возвращает единственный экземпляр класса.

```js
class Singleton {
  static instance;

  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this;
    }
    return Singleton.instance;
  }

  someMethod() {
    console.log('Это метод синглтона');
  }
}

const singleton1 = new Singleton();
const singleton2 = new Singleton();

console.log(singleton1 === singleton2); // true
```

При попытке создать несколько экземпляров класса Singleton, мы получаем всегда один и тот же экземпляр, что полезоно для:

- Хранения глобальных переменных в одном месте
- Логирования всех ошибок в одном месте
- Хранения конфигурации в одном месте
- Централизованного кэширования
- Упрощения тестирования, где все зависимости в одном месте 

### Symbol()

Конструктор Symbol() создает всегда уникальный объект, нельзя создать два одинаковых Symbol():

```js
const test = Symbol('Mytest');
const test2 = Symbol('Mytest');
console.log(test === test2); // false
```

Значение (описание) символа `Mytest` посмотреть напрямую нельзя, но можно с помощью свойства `description`:

```js
alert(test); // TypeError: Cannot convert a Symbol value to a string
console.log(test); // Symbol(Mytest)
console.log(test.toString()); // Symbol(Mytest)
console.log(String(test)); // Symbol(Mytest)
console.log(test.description); // Mytest
```

`Symbol` был добавлен в ES6 для решения следующих проблем:

- Дублирующихся имен ключей внутри объектов, с помощью symbol можно задавать ключи с одинаковыми именами
- Для создания приватных свойств внутри объектов, symbols не отображаются в Object.keys() и for/in циклах:

```js
const test = Symbol('test');

const obj = {
    [test]: 'testValue'
}

console.log(Object.keys(obj)); // []
console.log(Object.getOwnPropertySymbols(obj)); //[ Symbol(test) ] 
console.log(Reflect.ownKeys(obj)); // [ Symbol(test) ] 
console.log(obj[test]); // testValue 
```

`Object.assign` копирует все свойства, в том числе, символьные:

```js
Object.assign(NewObj, Obj); //
console.log(NewOb); // { test: 'testValue' }
``` 

Возможно добавление символьного свойства в объект или класс обрамив имя свойства ("не строку со свойстом") квадратными скобками, как при использовании скобочной нотации при вызове свойств объекта:

```js
const myTrip = {
    length: 2,
    0: 'New York',
    1: 'San Francisco',
    [length]: 21500

};
console.log(myTrip[length], myTrip.length); // 21500 2
```

Через Symbol можно задавать свойства прототипам:

```js
const mySymbol = Symbol('mySymbol');

Array.prototype[mySymbol] = function () {
    console.log('This function added to the Arrays prototype');
}

const myArray = [1, 2, 3];
myArray[mySymbol](); // This function added to the Arrays prototype
```

Недостатки symbols:

- Не достаточно распространен
- Нельзя изменить после создания
- Одинаково названные symbols могут запутать
- Не удаляются сборщиком мусора, в отличие от других примитивов

(adjs 1)

Многие библиотеки, в частности, библиотека управлениями состояний **Redux** использует его в полной мере.

#### Symbol.for()

Служит для повторного создания уникального индентификатора, т.е. два объекта будут эквивалентны:

```js
const test1 = Symbol.for('Mytest');
const test2 = Symbol.for('Mytest');
console.log(test1 === test2); // true
```

В данном случае Symbol.for() не создает новый объект в случае наличия, а возвращает уже существующий. Если же объекта еще нет то он при создании заносится в **глобальный реестр символов**:

```js
let id = Symbol.for('id');
let idAgain = Symbol.for('id');
cosole.log(id === idAgain); // true
```

Глобальный реестр, помтому что такие символы создаются в глобальной области видимости.

#### Symbol.keyFor()

Возвращает описание глобального (созданного с помощью Symbol.for()), а не обычного, символа по идентификатору:

```js
console.log(Symbol.keyFor(idAgain)); // id
```

Но, при любом символе, глобальном или обычном можно использовать свойство `Symbol.description`:

```js
console.log(test1.description); // Mytest
console.log(idAgain.description); // id
```

#### Системные символы

Они вшиты внутри JavaScript:

- Symbol.hasInstance - используется для настройки поведения оператора instanceof.
- Symbol.isConcatSpreadable - указывает, может ли объект быть развернут при использовании метода Array.prototype.concat.
- Symbol.iterator - определяет итератор по умолчанию для объекта.
- Symbol.toPrimitive - позволяет переопределить преобразование объекта к примитивному значению.
- Symbol.toStringTag - используется для настройки значения, возвращаемого при вызове Object.prototype.toString.
- Symbol.unscopables - используется для указания, какие свойства должны быть исключены из привязки с помощью with.

##### Symbol.iterator

Добавленный в ES6 цикл for/of ожидает итерируемого объекта, имеющего символьный метод `[Symbol.iterator]()` (символьное значение определенное самим языком, хранящееся в функции Symbol). 

Объект является итератором, если он умеет обращаться к элементам коллекции по одному за раз, при этом отслеживая своё текущее положение внутри этой последовательности.

По умолчанию массивы, строки и многомерные массивы являются итерируемыми объектами.

Когда метод вызван он должен вернуть объект предоставляющий собой интерфейс **итератор**, вот эта штука и занимается итеррированием. Объект имеет метод **next()**, который возвращает следующий результат, который тоже объект, имеющий свойство **value**, которое в свкою очередь будет иметь следующее значение, в случае наличия или свойство **done** имеющее значение true, указывающее что итерация завершена.
Свойства объекта **next**, **value** и **done** являются строками, не символьным типом. Только `Symbol.iterator`, который предполагается будет добавлен в большниство объектов, является символьным типом данных:

```js
const iterator = [1, 2, 3][Symbol.iterator]();
console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

Создадим сами и итеррируемый объект на основе односвязного списка:

```js
class List{
    constructor(value, rest){
        this.value = value;
        this.rest = rest;
    }
    get length(){
        return 1 + (this.rest ? this.rest.length : 0);
    }
    static fromArray(array){
        let result = null;
        for(let i = array.length - 1; i>=0; i--){
            result = new this(array[i], result);
        }
    }
}
```

В статическом методе класса **this** ссылается на конструктор текущего класса, не экземпляра, пока еще нет экземпляров, когда данный метод вызван.

Итерирование по спику должно возвращать все элементы от начала до конца. Для этого напишем отдельный класс-итератор:

```js
class ListIterator{
    constructor(list){
        this.list = list
    }

    next(){
        if(this.list == null){
            return {done: true};
        }
        let value = this.list.value;
        this.list = this.list.rest;
        return {value, done: false};
    }
}
```

Класс отслеживает прогресс итерации по списку обновляя свое свойство **list**, до тех пор пока значения возвращаются.

Теперь сделаем класс **List** итерируемым:

```js
List.prototype[Symbol.iterator] = function(){
    return new ListIterator(this);
}
```

Данный кусок кода можно поместить непосредственно в класс. Теперь можем итерироваться по списку с помощью for/of:

```js
let list = List.fromArray([1, 2, 3]);
for(let element of list){
    console.log(element);
}
// 1
// 2
// 3
```

Пример реализации итератора внутри объекта:

```js
const myIterable = {
  data: [1, 2, 3, 4],

  [Symbol.iterator]: function () {
    let index = 0;
    return {
      next: () => {
      if(index < this.data.length){
        return { value: this.data[index++], done: false };
        } else {
        return { done: true };
        }
      }
    }
  }
}

for(el of myIterable){
    console.log(el);   // 1 2 3 4
}
```

Плюсы интерфейса (т.е. публичного метода) iterator:

- Итерация по любым объектам
- Итерация в соответствии с заданной логикой
- Инкапсуляция - спрятаны детали структуры данных, поэтому итерирооваться можно незная фнутренней организации данного объекта

###### Symbol.iterator + rest

Блягодаря наличию `[Symbol.iterator]()` cинтаксический сахар ... (rest оператор упаковки в массив) работает с любым итеррируемым объектом, позволяя превратить его в обычный массив:

```js
console.log([..."PCI"]); // ["P", "C", "I"]
```

###### Symbol.iterator для диапазонов

Есть диапазонв от 1 до 17

```js
let range = {from: 1, to: 17};
```

Создадим итератор:

```js
range[Symbol.iterator] = function(){
    return {
        current: this.from,
        last: this.to,
        next(){ // next() - метод итератора, который вызывается на каждой итерации цикла for of
            if(this.current <= this.last){
                return {done: false, value: this.current++};
            } else {
                return {done: true};
            }
        }
    }
}
```

Проверка работы:

```js
for(let num of range){
    console.log(num);
}
```

Когда цикл for(… of …) запускается, он вызывает Symbol.iterator один раз (или выдаёт ошибку, если метод не найден). Этот метод должен вернуть итератор — объект с методом next. Далее цикл работает только с возвращённым объектом от `Symbol.iterator`. Для получения следующего значения, цикл запускает метод `next()`, который должен возвратить данные в формате объекта `{done: boolean, value: any}`. Если `done` имеет значение `true`, цикл завершается.

##### Разделение ответственности

У объекта range нет метода next, этот метод есть у другого объекта — итератора, именно его next и генерирует значения.

Предположим что next() был бы свойством самого объекта range:

```js
let range = {
    from: 1,
    to: 17,
    [Symbol.iterator](){
        this.current = this.from;
        return this;
    },
    next(){
        if(this.current <= this.to){
            return {done: false, value: this.current++};
        } else {
            return {done: true};
        }
    }
}

for(let num of range){
    console.log(num);
}
```

Первый подход, когда next() является свойством итератора лучше по следующим причинам:

1. Каждый вызов for...of создает новый объект итератора с собственным состоянием, можно безопасно использовать несколько параллельных итераций
2. Разделение ответственности: объект range хранит данные, итератор - логику обхода
3. Нельзя случайно сломать итерацию, изменив свойства исходного объекта во время работы цикла.

Но, и первый пример не идеален, можно сделать код более коротким и читаемым с помощью генераторов.

##### Генераторы

Пример с диапазоном, но с генератором:

```js
let range = {
    from: 1,
    to: 17,
    *[Symbol.iterator](){
        for(let i = this.from; i <= this.to; i++){
            yield i;
        }
    }
}

for(const num of range){
    console.log(num);
}
```

Генератор современный стандарт, который автоматически создает объект итератора с методами next(), return(), throw() объектом {value, done}.

Можно сделать код универсальным и переиспользуемым с помощью класса:

```js
class Range{
    constructor(start, end){
        this.start = start;
        this.end = end;
    }
    *[Symbol.iterator](){
        for(let i = this.start; i <= this.end; i++){
            yield i;
        }
    }
}

const myRange = new Range(1, 5);

for (const num of myRange){
    console.log(num);
}
```

Обратите внимание на добавление * перед [Symbol.iterator], что указывает на то, что метод является генератором.

## Наследование

Предположим нам нужен класс такой же как List, но мы не хотим дожидаться подсчета всех элементов, чтобы получить размер списка с помощью **length**. Хотим чтобы актуальный размер списка был всегда доступен для каждого экземпляра. Такое возможно с помощью механизма **наследования**. Можно наследовать все свойства объекта и добавить еще какие-то отличные от **супер-класса**, получив таким образом **подкласс**.

```js
class LengthList extends List{
    #length;
    constructor(value, rest){
        super(value, rest);
        this.#length = super.length;
    }
    get length(){
        return this.#length;
    }
}

console.log(LenghtList.fromArray([1, 2, 3]).length); // 3
```

Ключевое слово **super** это ссылка на родительский класс. Используется при наличие extends. Внутри constructor super должен идти первым иначе будет ошибка.

Наследование фундаментальная часть ООП, так же как и инкапсуляция или полиморфизм, но в отличии от них, которые упрощяют и прячут подробности, наследование усложняет и делает больше взаимосвязей. Т.к. чтобы понять подкласс, нужно знать друге классы от которых он произошел.

Наследования объектов можно добится следующими способами:

- Object.create
- с помощью конструктора
- ключевого слова extends

### Object.create()

Добиваемся наследования через цепочку прототипов:

```js
const animalPrototype = {
    makeSound: function(){
        console.log('Generic Animal sound');
    }
};

const birdPrototype = Object.create(animalPrototype);
birdPrototype.fly = function(){
    console.log('The bird is flying');
};

const myBird = Object.create(birdPrototype);
myBird.name = "Sparrow";
console.log(myBird.name); // Sparrow
myBird.fly(); // The bird is flying
myBird.makeSound(); // Generic Animal sound

birdPrototype.makeSound = function () {
    console.log('Tweet, tweet!');
}
```

### Функция конструктор

```js
function Animal(name) {
    this.name = name;
}
// добавили метод к прототипу конструктора Animal
Animal.prototype.makeSound = function(){
    console.log('Generic Animal Sound');
};
// создали дочерний класс Bird
function Bird(name, wingspan){
    Animal.call(this, name); // унаследуем свойства от конструктора Animal, передав this
    this.wingspan = wingspan; // передадим спицифичные для птицы свойства
}

Bird.prototype = Object.create(Animal.prototype);
Bird.prototype.fly = function(){
    console.log('The bird is flying');
}

const myBird = new Bird('Sparrow', '20 cm');
console.log(myBird.name); // Sparrow
console.log(myBird.wingspan); // 20 cm
myBird.fly(); // The bird is flying
myBird.makeSound(); // Generic Animal sound
```

### class extends

Заменим предыдущий код современным способом, создадим родителя:

```js
class Animal{
    constructor(name){
        this.name = name;
    }
    makeSound(){
        console.log('Generic Animal Sound');
    }
}

class Bird extends Animal{
    constructor(name, wingspan){
        super(name);
        this.wingspan = wingspan;
    }
    fly(){
        console.log('The bird is flying');
    }
}

const myBird = new Bird('Sparrow', '20 cm');
console.log(myBird.name); // Sparrow
console.log(myBird.wingspan); // 20 cm
myBird.fly(); // The bird is flying
myBird.makeSound(); // Generic Animal sound
```

На примере пылесосов:

```js
// Класс робот-пылесос.
class VacuumCleaner {
    model = "vacuum cleaner";
    counterOfStarts = 0;
    isFull = false;
    isObstacle = false;
    // Для создания конструктора, нужно создать метод constructor.
    constructor() {
    }
    startCleaning() {
        this.counterOfStarts++;
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of VacuumCleaner');
        console.log('I am cleaning... I have been started: ', this.counterOfStarts, 'times.');
    }
    goCharge() {
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of VacuumCleaner');
        console.log('I am going to charge...');
    }
}
// Попробуем создать экземпляр класса и посмотреть как онработает.
const BaseRobot = new VacuumCleaner;
console.log(BaseRobot.constructor); // class VacuumCleaner {
// model = "vacuum cleaner";
// counterOfStarts = 0;
// isFull = false;
// isObstacle = false;
// Для создания конструктора, нужно создать метод constructor.
// constructor() {
// }
// ...
console.log(BaseRobot.model); // vacuum cleaner
console.log(BaseRobot.startCleaning()); // I am the method of VacuumCleaner
// I am cleaning... I have been started: 1 times.
```

Cоздадим расширенную новым методом серию:

```js
// Расширенный класс DancingSeries. C помощью extends мы указываем от какого класса будем наследоваться.
class DancingSeries extends VacuumCleaner {
    // Объявляем новые свойства и переопределяем свойство model.
    model = "dancing series";
    power = 200;
    batterySize = 2100;
    boxSize = 0.5;
    workTime = 45,
    isUVLampOn = false;
    // Добавляем новый метод.
    switchUVLamp() {
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of DancingSeries');
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    }
};

// Создадим новый экземпляр класса, чтобы посмотреть как он работает и что в нем есть.
const DancingRobot = new DancingSeries;
console.log(DancingRobot.__proto__); // VacuumCleaner
{constructor: ƒ, switchUVLamp: ƒ}
console.log(DancingRobot.model); // dancing series
console.log(DancingRobot.switchUVLamp()); // I am the method of DancingSeries
// lamp is working.
```

Под капотом все ранее описанные действия. Объявляя класс движок JS:

- создает функцию конструктор по имени класса
- берет для конструктора код из метода constructor, если метода нет то конструктор тоже будет пустым.
- Если есть расширение, то в конструкторе будет служебное свойство prototype
- прописывает все методы в свойство prototype конструктора

```js
// Созданный конструктор является функцией, код которой взят из конструктора.
console.log(DancingSeries === DancingSeries.prototype.constructor); // true
// В созданном конструкторе есть свойство prototype и оно содержит все методы.
console.log(DancingSeries.prototype); // VacuumCleaner {constructor: ƒ, switchUVLamp: ƒ}
```

### Оператор instanceof

Чтобы знать от какого класса произошел объект, используется оператор бинарный instanceof (аналог typeof у переменных):

```js
function Car(make, model){
    this.make = make;
    this.model = model;
}

var myCar = new Car('Toyota', 'Camry');

console.log(myCar instanceof Car); // true
console.log(myCar instanceof Object); // true
console.log(myCar instanceof Array); // false
```

## Асинхронность

(04.Lecture)

В классическом JS код выполняется последовательно, т.е. синхронно. Это касается и функций. Но, существуют ситуации, когда нужно где-то сохранить контекст функции, т.е. ее внутренную область видисомсти с переменными и объектами внутри него. Такими ситуациями являются рекурсии и вызовы из нашей функции других вложенных функций.
Для хранения конекстов используют стек вызовов (LIFO), т.е. функция которая последняя в цепочке рекурсий или во вложенности вызовов выполняется первой. Так обеспечивается синхронность, но не обеспечивается асинхронность, т.е. безпрерывное выпол. Весь стек функций будет ждать пока не выполнится последняя добавленная в него функция.

Асинхронная операция - это функция, которая не блокирует текущее выполнение кода и после запуска этой операции выполнение других задач продолжается, возвращение к медленной операции происходит тогда когда она выполенна, с помощью функций-колбэков, которые будут вызваны после завершения медленной операции.

Если асинхронных фукнций виполняется несколько, то они помещаются в очереди FIFO. Первая, при равных условиях, выполнится та функция, которая пришла первой.

### Асинхронность в браузере

БРАУЗЕР
    ├── ДВИЖОК JS
    │       └── Парсер
    │       └── Интерпретатор
    │       └── Компилятор
    │       └── Сall stack
    │       └── Garbage collector
    │
    └── СРЕДА:
        ├── ДВИЖКИ
        │    └── Rendering Engine (Blink)
        │       └── Rendering queue
        │    └── DOM Engine
        │       └── DOM queue
        │    └── CSS Engine
        │       └── CSS queue
        │    └── Audio Engine
        │       └── Audio queue
        │    └── Video Engine
        │       └── Video queue
        │    └── WebAssembly
        │       └── WebAssembly queue
        │    └── other engines
        └── API
        │   └── DOM API
        │   └── CSS API
        │   └── Canvas API
        │   └── Crypto API
        │   └── Network API
        │   └── other APIs
        └──МЕХАНИЗМЫ
            └── Event Loop
            └── Microtask Queue
            └── Callback Queue
            └── CORS (cross origin resource sharing)
            └── SOP (same origin policy)
            └── CSP (content security policy)
            └── SS (sandbox security)
            └── Cache Management
            └── Cookie Management
            └── other mechanisms

Интерпретатор JS (interpreter) движка (см. [Введение](#intro)) при чтении кода определяет (по имени, контексту и т.д.) какие функции куда направить:

1. синхронные в call stack
2. асинхронные в специализированный движок (видео, аудио и т.д.) конкретной среды (браузер, node.js), которая в своею очередь распределяет их:
    - microtask queue
    - callback queue
    - other queues

После выполеннения асинхронной операции одним из движков среды колбеки с помощью event loop в нужное время (при свободном секе) перемещаются из очередей в стэк вызовов где их обрабатывет сам JS-движок.

### Event Loop

**Цикл Событий** (Event Loop) - механизм среды (браузер или node).

Цикл событий является диспетчером операций, принимающего решения куда ее направить:

1. Call Stack - **стек вызовов** синхронного кода
2. Microtask Queue - **очередь микрозадач** (Promise, MutationObserver, requestAnimationFrame, setImmediate, process.nextTic)
3. Macrotask Queues - **очерди марозадач** (Очереди движков среды):
   - Callback Queue - **очередь отложенных задач** (setTieout, setInterval)
   - Video Queue
   - Audio Queue
   - WebAssembly Queue
   - other queues

```js
console.log("Start algorithm!");
setTimeout(function timeout() {
console.log("This will be printed after 5 seconds!");
}, 5000);
console.log("End synchronous code.");
console.log("End synchronous code.");
console.log("End synchronous code.");
console.log("End synchronous code.");
console.log("End synchronous code.");
```

Первая строка синхроная, она попадает в Call Stack, выполняется JS-движком.
Вторая строка setTimeout() это асинхронная фукнция API браузера попадающя в Callback Queue, через 5 секунд ее каллбек timeout() помещается в Call Stack, с пощью Event Loop при условии, что стек свободен.
Пока длятся 5 секунд, синхронный код (функция console.log) продолжает выполнятся дальше выведя сообщение из 5 строк.
Все это время цикл событий смотрит за стеком вызовов, если он пустой (т.е. нет синхронных функций) то он берет первую задачу из очереди отложенных асинхронных задач и помещает функцию timeout() в стек синхронных вызвов и из стека вызовов JS-движок берет и выполняет timeout().

Цикл событий тупо делает два действия: следит когда освободится стек и сразу берет функцию из очереди и помещает в стек.

При занятой медленной синхронной операцией и следовательно забытым ей стеке нет гарантии, что функция timeout() выполнится в течении 5 секунд.

Асинхронными делают функции, которые чем-то могут быть заняты и потенциальном могут заблокировать основной поток, например:

- доступ к БД
- чение или запись файлв
- оптарвка или получание данных по сети

В вебе часто код для подгрузки картинок делают асинхронным, чтобы пользователю не дожидаясь были доступны текст и элементы упралвения.

Встроенные функции и методы могут быть синхронными или асинхронными, а есть в двух исполнениях сразу.

Каждый отедльно взятый движок (JS, DOM, CSS) выполняет свои задачи синронно в своих потоках, за общей асинхронностью следит цикл событий.

Циклы for, while - является синхронным. Но, есть способ сделать код с такими операторами асинхронным

#### Promise

Промис - основной класс асинхронных операции в JS. Мы "обещаем", что скоро нам придут данные, а пока продолжаем выполнять синхронные задачи.

Идея промисов возникла еще в 70-80-х годах в теории языков программирования, но в JavaScript они появились ES6 (2016). 

Конструктор промиса принимает функцию-исполнитель (executor), являющаюся колбэком, вызывается в момент создания промиса. Функция-исполнтиель принимает в качестве аргументов другие две функции менеющие состояние промиса:

- resolve - выполняется в случае успеха, возвращаюет результат value, тогда с объектом Promise можно работать с помощью then
- reject - выполняется в случае ошибки, возвращаюет результат error, тогда с объектом Promise можно работать с помощью catch

```js
let promise = new Promise(function(resolve, reject) {
    // тело функции-исполнителя
})
```

Функции меняют состояния внутренних слотов объекта Promise:

1. [[PromiseState]] - состояние промиса с одним из трех значений
    - pending (ожидание) когда асинхронная операция выполняется
    - fulfilled (выполнено) когда асинхронная операция завершена успешно
    - rejected (отклонено) когда асинхронная операция завершена с ошибкой
2. [[PromiseResult]] result - может иметь одно из трех значений
    - undefined (по умолчанию)
    - value (результат resolve)
    - error (результат reject)

resolve и reject в теле промиса могут быть вызваны только один раз. Они принимают по одному аргументу (число, булево значение, строка или объект)

Создадим промис с задержкой помощью функции таймаута:

```js
let promise = new Promise(function(resolve, reject) {
    setTimeout(() => Math.random() *2 < 1 ? resolve(console.log("Выполнено"))
    : reject(new Error("Ошибка")), 1000);
});
```

Функция-исполнитель завершается сразу после создания промиса.

- Math.random() возвращает число от 0 до 1
- Math.random() * 2 дает число от 0 до 2
- Math.random() * 2 < 1 вернет true примерно в 50% случаев

Программисты редок создают собственные промисы, они как правило пользуются уже существующими, следующие сущности возращают промисы:

- метод fetch
- объект XMLHttpRequest
- библиотека axios

Упрощенная реализация fetch:

```js
function fetch(url, options) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest(); // или другой HTTP-клиент
    xhr.onload = function() {
      if (xhr.status >= 200 && xhr.status < 300) {
        resolve(new Response(xhr.responseText, {
          status: xhr.status, // ✅ Успешный HTTP-статус
          statusText: xhr.statusText
        }));
      } else {
        reject(new Error(`HTTP error: ${xhr.status}`));// ❌ HTTP-ошибка (404, 500 и т.д.)
      }
    };
    xhr.onerror = function() {
      reject(new Error('Network request failed'));  // ❌ Сетевая ошибка
    };
    xhr.open('GET', url);
    xhr.send();
  });
}
```

Для взаимодействия с промисами используются методы:

- then
- catch
- finally
- all
- allSettled
- any
- race

##### then

Это основной строительный блок для работы с асинхронностью до появления async/await, метод then нужен для:

- Обработки успешного выполнения промиса
- Создания последовательных преобразований данных
- Построения цепочек асинхронных операций
- Композиции асинхронной логики в функциональном стиле

then имеет синтаксис:

```js
promise.then(onFulfilled, onRejected)
```

then принимает два коллбека-обработчика (callback handlers), которые могут быть переданы по одному, чаще используют только первый, выполняется только один из двух:

1. onFulfilled выполняется если статус промисаfulfilled
2. onRejected выполняется если статус промиса rejected

Колбеки-обработчики (стрелочные фукнции)нужны для того, чтобы совершить действие по резуллтату промиса. Данной действие нельзя выполнить в синхронной операции.

Коллбеки-обработчики принимает только по одному параметру, поэтому можно не указывать аргумент (result, error) в скобках:

```js
promise.then(
    result => {console.log(result);}
)
```

Если обработчиков передано в then два, то можно записать так:

```js
promise.then(
    result => {console.log(result);},
    error => {console.log(error);}
)
```

Вополнится только один обработчик, в зависимости от состояния промиса. Т.е. console.log это функция, то она сама может быть передана как коллбек-обработчик:

```js
new Promise(resolve => resolve(1)).then(console.log);
```

##### Цепочки промисов

Если обработчик возвращает также объект промис, то для него можно вызвать then и так по цепочке:

```js
new Promise(resolve => setTimeout(() => resolve(1), 1000))
    .then(result => new Promise(resolve => setTimeout(() => resolve(result + 1), 1000)))
    .then(result => new Promise(resolve => setTimeout(() => resolve(result + 1), 1000)))
    .then(console.log);
```

##### catch

При использовании then, обработчик onRejected можно вынести в метод catch:

```js
promise.then(
    result => console.log(result),
).catch(error => console.log(error))
```

В цепочке промисов достаточно одного вызова catch, что бы отловить ошибку из любого промиса в цепочке.

##### finally

##### Статические методы промисов

Методы которые не принадлжета экземплярам (объектам) на основе Promise, а относятся к самому классу Promise

##### all

##### allSettled

##### any

##### race

#### AJAX

Asynchronous JavaScript And XML (AJAX) - механизм, который позволяет обновлять страницу без перезагрузки: чаты, мессенджеры, уведомления и т.д.

##### XMLHttpRequest

Объект XMLHttpRequest позволяет создать объект запроса на сервер и ответа от него (через браузер как html-файл):

```js
// XHR GET запрос
// Для создания запроса сначала нужно создать объект XMLHttpRequest, конструктор вызывается без аргументов.
const xhr = new XMLHttpRequest();
// Открываем запрос. Первый аргумент это метод (GET, POST ...), второй адрес, куда нужно отправить запрос. У данного метода есть еще аргументы, которые мы рассмотрим позже.
xhr.open('GET', 'https://api.github.com/users/octocat');
// Отправляем запрос на сервер. Метод send() может принимать один аргумент - это тело запроса, если оно есть. Для методов POST мы бы передавали тут тело запроса, наш запрос GET не имеет тела запроса.
xhr.send();
// После отправки запроса нам нужно использовать методы слушатели, которые будут асинхронно выполнены при наступлении соответствующего события. Это методы onload, onerror и onprogress - мы сами определяем их функции.
// onload - будет вызван, когда сервер вернет ответ. Это может быть положительный ответ сервера с кодом 200 (все хорошо), так и ошибка, например страница не найдена, тогда код будет 404. Мы должны обрабатывать такие ситуации сами.
xhr.onload = function() {
    if (xhr.status != 200) { // если статус не 200, то произошла ошибка
        console.log(`Error ${xhr.status}: ${xhr.statusText}`);
    } else {
        console.log(`user: ${xhr.response}`); // response - это ответ сервера
    }
};
// onprogress - функция будет вызываться пока запрос находится в процессе, и позволяет отслеживать ход процесса отправки запроса и получения ответа от сервера. Бывает полезна при отладке сложных запросов.
xhr.onprogress = function(event) {
    console.log(`Get from server: ${event.loaded} bytes`);
};
// onerror - функция будет вызываться если в запросе пошло что-то не так. НАпример нет соединения с сервером или ошибка в адресе запроса.
xhr.onerror = function() {
    console.log("Request error");
};
// Вывод из функции onprogress.
// Get from server: 1319 bytes
// Вывод из функции onload, приведен не полностью.
user: {`
"login": "octocat",
"id": 583231,
"node_id": "MDQ6VXNlcjU4MzIzMQ==",
"avatar_url":
"https://avatars.githubusercontent.com/u/583231?v=4",
"gravatar_id": "",
"url": "https://api.github.com/users/octocat",
"html_url": "https://github.com/octocat",
"followers_url":
"https://api.github.com/users/octocat/followers",
"following_url":
"https://api.github.com/users/octocat/following{/other_user}",
...`
}
```

С помощью node.js:

```js
const XMLHttpRequest = require('xhr2');

const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.github.com/users/strogino');
xhr.send();

xhr.onload = function() {
  if (xhr.status !== 200) {
    console.log(`Error ${xhr.status}: ${xhr.statusText}`);
  } else {
    console.log(`user: ${xhr.response}`);
  }
};

xhr.onprogress = function(event) {
  console.log(`Get from server: ${event.loaded} bytes`);
};

xhr.onerror = function() {
  console.log("Request error");
};
```

Объект XMLHttpRequest имеет ряд других полезных методов, но его применение с каждым годом становится менее актуальным, т.к. есть метод fetch.

#### async/await

Async/await был предложен в языке C# еще в 2007 году, и его идея была заимствована другими языками.

В JavaScript async/await был добавлен в стандарт ES8 (ECMAScript 2017)

**async** - превращает любую функцию в обещание и позволяет использвать await внутри нее.

**await** - останавливает выполнение функции, пока она не вернет результат.

```js
const getUser = async (url) => {
    // Делаем запрос, и ждем его результат (указание await), который будет сохранен в константу response.
    const response = await fetch(url);
    // Выполняем еще один асинхронный метод, преобразования в текст, также ждем результат, который сохраняется в константу пользователь.
    const user = await response.text();
    console.log(user);
}
getUser('https://api.github.com/users/octocat');
// Вывод в консоль.
// {
// "login": "octocat",
// "id": 583231,
// ...
// }
```

#### setTimout(), setInterval()

Запланированная асинхроность - это когда нужно синхронный код превратить в асинхронный. Например, для имитации задержки ответа от сервера:

```js
let counter = 0; // объявляем переменную counter
const amount = 100000; // объявляем переменную amount
const timerId = setInterval(() => {
    if (counter > amount) {
    // После того как наш счетчик достигнет нужного количества итераций, мы должны очистить таймер, чтобы итерации больше не выполнялись.
    clearInterval(timerId);
        console.log('End long calculations');
    }
    // Добавим вывод нашего счетчика через каждые 10000 итераций, чтобы видеть что наш код работает.
    if (counter % 10000 === 0) {
        console.log('working: ', counter);
    }
    const newDate = new Date(counter);
    counter++;
}, 0);
// Start long calculations
// working: 0
// working: 10000
// working: 20000
...
// End long calculations
```

Вышеперечисленные функции помещают колбеки в очерь отоложенных задач, поэтому они становятся асинхронными

## Ошибки

Это классы рассширяющие Error. Они бывают:

1. Системными (генерируются движком JavaScript)
    С обработкой:
    - ReferenceError (ссылочная ошибка) - при попытке обращения к несуществующему объекту
    - TypeError (типовая ошибка) - при попытке выполнить операцию с неправильными операндами
    - RangeError - при попытке выполнить операцию вне диапазона
    - URIError - при неправильном использовании кодирования или декодирования URI
    - AggregateError - несколько ошибок сразу, например Promise.all
    - EvalError - при неправильном использовании операцию eval (deprecated)
    Без обработки:
    - InternalError - внутренняя ошибка из-за реализации программы
    - SyntaxError (синтаксическая ошибка) - при неправильном написании программы
2. Пользовательскими (генерируются программистом) с помощью оператора `throw`
    - Error - ошибки на основе класса `Error`
    - Пользовательские классы ошибок

Классами с обработкой можно управлять в момент ошибки. Без обработки нельзя, они только для информации.

По умолчанию JS проглатывает множество ошибок, прощая большинство из них, из-за этого трудно их обнаружить. Но, такое поведение можно отключить с помощью специальной интрукции строгого режима.

### Strict mode

Помещенная в начало файла или функции или файла инструкция `"use strict"` включает строгий режим, который:

- запрещает использовать не обхявленные переменные (объекты и функции) ReferenceError
- запрещает присваивать значения необъявленным переменным
- не возможно объявления переменных (объектов и их свойств, аргументов функций), которые уже был объевлены ранее
- нельзя числа начинать с нуля иначе SynaxError, т.е. с нуля нужно начинать восьеричные числа
- заприщает использование оператора delete вызовет SynaxError
- запрещает использование переменной arguments внутри функций
- запрещает использование оператора with
- запрещено использование eval()

```js
function canYouSpotTheProblem() {
  "use strict";
  for (counter = 0; counter < 10; counter++) {
    console.log("Happy happy");
  }
}

canYouSpotTheProblem();
// → ReferenceError: counter is not defined
```

Без `"use strict"` counter будет объявлен глобально, т.е. `var counter;`. Строгий режим не защитит от ошибки объявления переменной, если она была объявлено где-то ранее по коду.

По умолчанию строгий режим включен в классах и модулях.

Строгий режим c функциями если они вызываются не как методы (или без new) присвоит this undefined:

```js
"use strict";
function Person(name) { this.name = name; }
let ferdinand = Person("Ferdinand"); // forgot new
// → TypeError: Cannot set property 'name' of undefined
```

Без `"use strict"` this будет ссылаться на глобальную область видимости, т.е. `this` будет `window` в браузере.

```js
function Person(name) { this.name = name; } 
let ferdinand = Person("Ferdinand"); // oops
console.log(name);
// → Ferdinand
```

Т.е. у нас появилось не предвиденная нами переменная `name` в глобальной области видимости.

К счастью, конструкторы объявленные внутри class не будут иметь эту проблему.

### Отладка

Часто IDE подсвечивает ошибки, при выполенния кода интерпритатор выводит номер строики и сообщение об ошибке. Но, есть ситуации, когда первые два инструмента молчат: логические ошибки, неправильное использование переменных и т.д.

Код ниже должен конвертировать целое число в строку в заданной системе счисления:

```js
function numberToString(n, base = 10) {
  let result = "", sign = "";
  if (n < 0) {
    sign = "-";
    n = -n;
  }
  do {
    result = String(n % base) + result;
    n /= base;
  } while (n > 0);
  return sign + result;
}
console.log(numberToString(13, 10));
```

Исследование можно проводить с помщью размещения console.log в нужных местах, для выяснения значения переменных. Но, есть специальная инструкция `debugger`, которая при выполнении кода в браузере вызывает дебаггер с местом останова на данном месте. Node.js нужно запускать с ключом `--inspect`:

```bash
node --inspect index.js
```

Или с параметром `inspect`:

```js
node inspect index.js
```

#### Отладка в Node.js

Призапуске скрипта с ключом или параметром `inspect` Node.js запускает интерпретатор в режиме дебагара.

```bash
debuger>
```

Он имеет встроенную справку `help` из которой можно посмотреть основные команды управления:

- `s` - продолжить выполнение скрипта провалившись в фукнцию
- `n` - продолжить выполнение скрипта на следующую строчку без проваливания в функцию
- `c` - продолжить выполнение скрипта на текущую строчку
- `o` - выйти из функции
- `q` - выход из интерпретатора
- `whatch(expr)` - выводить и наблюдать значение выражения или переменной (нужно передовать в виде строки)

### Обработка ошибок

Не всегда ошибку зависят от собственного кода:

- могут быть введены пользователем
- могут приходить из внешнего источника по API
- источник данных вообще может не вернуть ничего из-за перегрузки

Тогда полученный результат надо проверить и обработать.

Например, мы ждем ввода числа от пользователя, а он передает строку:

```js
function promptNumber(question) {
  let result = Number(prompt(question));
  if (Number.isNaN(result)) return null;
  else return result;
}

console.log(promptNumber("How many trees do you see?"));
```

В данном случае, программа вернет `null` в случае, если пользователь ввел не число.

Но, такой подход имеет недостатки. Например, что если фукнцция и должна возвращать null и все остальные значения, кокой результат вернуть, чтобы было понятно, что происзошла ошибка? Можно обарачивать любой результат в объект:

```js
function lastElement(array) {
  if (array.length == 0) {
    return {failed: true};
  } else {
    return {value: array[array.length - 1]};
  }
}
```

Данный код усложняется особенно если нам нужно получить только один результат. На помощь приходят исключения

#### Распространение ошибок

Когда происходит ошибка оно выбрасывается останавливая текущую функцию и все другие вызвавшие ее функции **раскручивая стек** (unwinding the stack) до самого основного вызова вниз в стеке вызовов.
Термин **раскручивать** означает, что в момент ошибки программа останавливается, но объект ошибки с детальной информацией, распрастраняется назад по цепочке стека. Это позволяет поймать и обработать данный объект, на любом из этапов **раскрутки**.

#### Исключения

Exceptions - это механизмы сбора информации и обработки **исключительных**, нестандартных ситуаций в программе, называемых ошибками. Для них предусмотрен интерфейс по сохранению детальной информации о данном поведении и спобах их обработки.

Это объекты на основе класса `Error` или его потомков, которые создаются в момент ошибки, содержат детальную информацию об ошибке в свойствах:

- `message` — текстовое сообщение с описанием ошибки;
- `stack` — трассировка стека (stack trace), то есть структурированная информация о последовательности вызовов функций на момент генерации исключения, что крайне полезно для отладки.

Помимо произвольных ошибок мы можем генерировать свои, объект на базе класса `Error` может быть выброшен намеренно с помощью оператора `throw`:

```js
throw new Error('Something went wrong');
```

Чтобы выявить исключение (произвольные или намеренные) в конкретном участке кода, используется оператор `try`

##### try

Код в котором ловим ошибку оборачивается в блок `try`, кроме синтаксических и кроме асинхронных операций:

```js
try {
    
}
```

`try` должен сопровождаться как минимум одним блоком на выбор: `catch` или `finally`.
Даже при пустых блоках `catch` или `finally` код продолжит вополняться и не будет завершаться аварийно.

Переменные объявленные в `try` не видны в `catch` или `finally`, их нужно объявить на уровень выше.

##### catch

Иключения можно перехватить с помощью специальных конструкций, размещенных в стеке вызовов, — блоков `catch`. Перехватив исключение, его можно либо обработать локально, выполнив необходимый код для исправления ситуации, либо передать дальше по цепочке. После успешной обработки программа может продолжить свое выполнение в штатном режиме, избежав аварийного завершения.

```js
function promptDirection(question) {
  let result = prompt(question);
  if (result.toLowerCase() == "left") return "L";
  if (result.toLowerCase() == "right") return "R";
  throw new Error("Invalid direction: " + result);
}

function look() {
  if (promptDirection("Which way?") == "L") {
    return "a house";
  } else {
    return "two angry bears";
  }
}

try {
  console.log("You see", look());
} catch (error) {
  console.log("Something went wrong: " + error);
}
```

`catch` ожидает в качестве опционального параметра `error` объект `Error` с детальной информацией об исключении. Начиная с ES2019 параметр `error` можно не указывать, если его не используют.

##### finally

При выбрасывании исключения создают побочне эффекты в виде изменния хода выполенения программы, например код плохого интернет-банкинга:

```js
const accounts = {a: 100, b: 0, c: 20};

function getAccount() {
  let accountName = prompt("Enter an account name");
  if (!Object.hasOwn(accounts, accountName)) {
    throw new Error(`No such account: ${accountName}`);
  }
  return accountName;
}

function transfer(from, amount) {
  if (accounts[from] < amount) return;
  accounts[from] -= amount;
  accounts[getAccount()] += amount;
}
```

`getAccount` выполняется после списания денег с одного счета, что может приветси к потере денег.

Подобные ситуации следуюет учитывать и изменить последовательность и логику пргаммы, вернув прежнее состояние счета:

```js
function transfer(from, amount) {
  if (accounts[from] < amount) return;
  let progress = 0;
  try {
    accounts[from] -= amount;
    progress = 1;
    accounts[getAccount()] += amount;
    progress = 2;
  } finally {
    if (progress == 1) {
      accounts[from] += amount;
    }
  }
}
```

`finally` выполняется в любом случае, даже если исключений не было перехвачено и даже если `try` содержал оператор `return`.

##### Поведение движков

Поведение движков на различные исключения может быть разным.

Например, исключение которое не было перехвачино и дошло до самого низа стека отобразится в консоли браузера не остановив выполнение программы. В node.js такое жи исключение остановит прогармму.

###### Выборочный перехват

Выборочный перехват (selective catching), нужен в подобных ситуациях:

```js
for (;;) {
  try {
    let dir = promtDirection("Where?"); // ← typo!
    console.log("You chose ", dir);
    break;
  } catch (e) {
    console.log("Not a valid direction. Try again.");
  }
}
```

В бесконечном цикле ожидается пока пользователь не введет правильное направление движения, но ошибка совсем не будет свазанна с выбором набравления, она связана c опечаткой в названии функции. Программист будет долго думать, что он неправильно вводит направления движения, а по факт происходит другое исключение. Поэтому необхомо предусматривать возможные действия при различных исключениях.

Во многих языках программирования (Java, C++, C#) можно сделать выборочный перехват исключений:

```js
    // Пример в Java
try {
    // код, который может выбросить разные исключения
} catch (IOException e) {
    // обработать только ошибки ввода-вывода
} catch (SQLException e) {
    // обработать только ошибки SQL
} catch (Exception e) {
    // обработать все остальные исключения
}
```

В JavaScript нет такого синтаксиса. Блок `catch` может быть только один, и он перехватывает все исключения, которые произошли в блоке try. Нельзя на уровне синтаксиса указать, что хотите поймать только TypeError, а, например, SyntaxError пусть пробрасывается дальше.

В JS возможность выборочного перехвата исключений не предусмотрена, но никто не отменял условного перехвата исключений:

```js
try {
    someFunctionThatMightCauseRangeError();
    someOtherFunctionThatMightCauseTypeError();
} catch (e) {
    if (e instanceof RangeError) {
        // Обрабатываем RangeError
        console.log("RangeError: " + e.message);
    } else if (e instanceof TypeError) {
        // Обрабатываем TypeError
        console.log("TypeError: " + e.message);
    } else {
        // Если это неизвестная ошибка, перебрасываем её дальше,
        // чтобы её мог обработать внешний обработчик или среда выполнения.
        throw e;
    }
}
```

В конечном блоке else предусматривают возможность повторного выбороса, которое в случае непредвиденной ошибки передастся на уровень выше в надежде, что его перехватит другой блок catch.

### Тестирование

Все что было описано выше в разделе ошибок, является борьбой и обработкой уже существующих ошибок или которые мы могут произойти по нашему мнениню. Все варианты развития ошибок предусмотреть очень сложно и чем больше программа, тем тяжелее.
Для выявления ошибок в уже написанном коде, либо свеже изменненом используют направление под названием *тестирование*. Которое может быть:

1. Ручным
    - с примененим небольшых блоков самописного кода
    - с использованием специальных инструментов - тестовыых наборов 
2. Автоматическим
    - тестовые исполнители

#### Утверждения

Для нахождения ошибок можно написать собственные фукнции, проверяющая код на ошибки, например тест-раннер для проверки метода `toUpperCase`:

```js
function test(label, body) {
  if (!body()) console.log(`Failed: ${label}`);
}

test("convert Latin text to uppercase", () => {
  return "hello".toUpperCase() == "HELLO";
});
test("convert Greek text to uppercase", () => {
  return "Χαίρετε".toUpperCase() == "ΧΑΊΡΕΤΕ";
});
test("don't convert case-less characters", () => {
  return "مرحبا".toUpperCase() == "مرحبا";
});
```

Но, данные функции не оповещают пользователя об ошибках, их нельзя обработать, он возвращают true или false, что явно не указывает на ошибку, т.к. много фукнции могут возвращать именно булевы значения. Поэтому используют похожий на данные функции механизм утверждений.

Assertions (утверждения, суждение, предположения) - конструкции проверки кода, на условие, в случае невыполнения которого выбрасываются исключения.

Предположим нам надо проверить что переданный в функцию массив данных не пустой:

```js
function firstElement(array) {
  if (array.length == 0) {
    throw new Error("firstElement called with []");
  }
  return array[0];
}
```

В случае отсутствия такой проверки, функция просто вернет `undefined`, которое не говорит о суде ошибки или проверки и может вернуться из-за множества причин. Утверждение (ассерт), в случае пустого массива, вернут исключение.

## Регулярные выражения

(09 eloquent)

Regular expressions - это объекты для поиска и замене символов в строках по определенному шаблону.

Объекты RE можно создать двумя способами:

- с помощью литералов `let re1 = /abc/;`
- с помощью конструктора `let re2 = new RegExp("abc");`

### Литеральное выражение

Создается с помощью строки внутри обычных слешей. После слеша может указываться служебный флаг:

```js
let re1 = /abc/i;
let re2 = /\dabc/g;
```

Специальные метасимволы, типа `\d` используются с одним слешем.

### RE конструктор

В регулярке созданной конструктором, шаблон задается в виде обычной строки в кавычках.

```js
let re1 = new RegExp("abc", i);
let re2 = new RegExp("\\dabc", g);
```

Специальные метасимволы, типа `\d` используются с двумя слешами.

Вторым, необязательным параметром, можно передать флаги.

Конструкторы принято использовать для создания динамических выражений, т.е. меняющихся в коде [(см. Динамические регулярки)](#динамические-регулярные-выражения).

### Флаги RE

| Флаг | Расшифровка | Описание |
| --- | --- | --- |
| i | case-Insensitive | без учета регистра |
| g | Global | Глобальное совпадение - возвращает все совпадения, а не только первое |
| m | Multiline | Все строки совпадают с регуляркой, даже если они не заканчиваются на конец строки. Возможно только с флагом `g` |
| s | DotSall | Точка считается как любой символ, включая перенос строки. Возможно только с флагом `g` |
| u | Unicode | Для нелатинских символов |
| y | stickY | Привязка к началу строки, вместо начала предыдущего совпадения. Возможно только с флагом `g` |

### RegExp методы

#### test

Возвращает true, если в строковом параметре есть совпадение, иначе false.

```js
console.log(/abc/.test("abcde")); // → true
console.log(/abc/.test("abxde")); // → false
```

- Шаблон состоит из 3-х символов `abc`
- Строковой параметра метода `test` `abcde`

#### exec

Возвращает массиво-подбный объект, с подробной информацией о совпадение с регулярным выражением, иначе null.

```js
let re = /abc/;
console.log(re.exec("abcde")); // → [ "abc", index: 0, input: "abcde", groups: undefined ]
console.log(re.exec("abxde")); // → null
```

Возвращенном объект содержит следующие свойства:

- 'abc' — строка, соответствующая шаблону регулярного выражения.
- index: 0 — позиция в строке, где начинается совпадение (0 означает начало строки).
- input: 'abcde' — исходная строка, в которой производился поиск.
- groups: undefined — информация о именованных группах захвата (в данном случае отсутствует).

[См.подробнее](#совпадения)

### Специальные символы

#### Эранаирование специальных символов

<table>
    <thead>
        <tr>
            <th>Символ</th>
            <th>Когда экранировать</th>
            <th>Литеральная форма /.../</th>
            <th>Конструктор RegExp</th>
            <th>Примеры и пояснения</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>\</td>
            <td>Всегда когда нужен буквальный \</td>
            <td>\\</td>
            <td>\\\\</td>
            <td>Литерал: /\\/ → \<br>Конструктор: new RegExp("\\\\") → \</td>
        </tr>
        <tr>
            <td>. * + ? ^ $ | { } [ ] ( )</td>
            <td>Только когда нужен буквальный символ (не специальная функция)</td>
            <td>\. \* \+ и т.д.</td>
            <td>\\. \\* \\+ и т.д.</td>
            <td>Как метасимволы (не экранировать): /a+b/ → "a" 1+ раз, затем "b"<br>
                Как буквальные (экранировать): /a\+b/ → строка "a+b"</td>
        </tr>
        <tr>
            <td>-</td>
            <td>Внутри [...], если может быть интерпретирован как диапазон</td>
            <td>\-</td>
            <td>\\-</td>
            <td>/[a\-z]/ → "a", "-" или "z"<br>
                /[a-z]/ → буквы от a до z<br>
                Вне скобок экранирование не нужно</td>
        </tr>
        <tr>
            <td>' "</td>
            <td>Не являются спецсимволами РВ</td>
            <td>Не экранировать</td>
            <td>Учитывать как часть строки JS</td>
            <td>new RegExp('"') → поиск двойной кавычки<br>
                new RegExp("'") → поиск одинарной кавычки</td>
        </tr>
        <tr>
            <td>\n \t \r и т.д.</td>
            <td>Для использования как управляющие последовательности</td>
            <td>\n \t</td>
            <td>\\n \\t</td>
            <td>Литерал: /\n/ → перевод строки<br>
                Конструктор: new RegExp("\\n") → перевод строки</td>
        </tr>
    </tbody>
</table>

#### Cимвольные классы

Символьные классы определяют диапазон(ы) символов заключенные в квадратные скобки:

```js
console.log(/[0123456789]/.test("in 1992")); // → true
console.log(/[0-9]/.test("in 1992")); // → true
```

Символьный класс `[0123456789]` (любая цифра), ищется посимвольно (по одному символу) в строковом параметре метода `test`.

#### Сокращеия символьных классов

##### Для ASCII латиницы

- `\d` любая цифра
- `\w` любая цифра и буква (“word character”)
- `\s` любой пробельный символ (space, tab, newline, and similar)
- `\D` либой символ нецифра
- `\W` либой символ нецифра и не буква
- `\S` либой не пробельный символ
- `.` любой символ кроме перевода строки

Сокращения символьных классов можно сочетать:

```js
console.log(/[\d.]/.test("2d")); // → true
console.log(/[\d.]/.test("dd")); // → false
```

Шаблон `[\d.]` совпадает со строковым параметром `2d` и не совпадает с `dd`.

##### Для ASCII нелатиницы

- `\p{L}` Любая буква (letter)
- `\p{N}` Любое число (number)
- `\p{P}` Любой знак препинания (punctuation)
- `\P{L}` Любоая не буква (большая P инвертирует)
- `\p{Script=Hangul}` Любая буква китайского языка

##### Для Unicode

- `\p{Script=Hangul}\u` Любая буква китайского языка в кодировке Unicode

где `u` - это кодировка Unicode

#### Инвертирование классов

Символ каретки (циркумфлекс) `^` в начале класса внутри квадратных скобок инвертирует его:

```js
console.log(/[^0-9]/.test("123")); // false
console.log(/[^0-9]/.test("123d")); // true
```

Циркумфлекс должен быть именно первым, если его передвинуть, то он потеряет свою инверсию.

#### Квантификаторы

Квантификатор в RE JS это специальный символ(ы), определяющий количество повторений предыдущего элемента в шаблоне.

`+` укзывает на то, что знак после которого он идет может повторятся более одного раза подряд:

```js
console.log(/a+/.test("aaa")); // true
console.log(/\d+/.test("12345")); // false
```

`*` (жадный квантификатор) укзывает на то, что знак после которого он идет может повторятся ноль или более раз:

```js
console.log(/a*/.test("")); // true
```

`?` (символ опциональности) укзывает на то, что знак после которого он идет может повторятся ноль или всего один раз:

```js
console.log(/a?/.test("")); // true
console.log(/a?/.test("a")); // true
console.log(/a?/.test("aa")); // false
```

`{N}`, где N это количество повторений предыдущего элемента в шаблоне:

```js
console.log(/a{4}/.test("aaaa")); // true
```

`{N,M}`, где от N до M это диапазон повторений

```js
console.log(/a{1,2}/.test("a")); // true
console.log(/a{1,2}/.test("aa")); // true
console.log(/a{1,2}/.test("aaa")); // false
```

`{N,}` - квантификатор с открытым диапазоном

```js
console.log(/a{1,}/.test("a")); // true
console.log(/a{1,}/.test("aaaaaaaaaa")); // true
```

##### Группировка выражений с квантификаторами

При использовании нескольких квандификторов в одном выражении, для четкой логики используют скобки:

```js
console.log(/boo+(hoo+)+/i.test("Boohooohoohooo")); // true
```

где, `i` - это игнорирование регистра.
Первый и второй плюсы выражения относятся только к букве `o`.
Третий плюс к (hoo+) целиком, поэтому данному раблону соотвествует 3 `hoo` подряд.

(hoo+) выражение в скобках - называют **группой захвата**

### Совпадения

Метод регулярного выражения [`exec`](#exec) имеет аналог в строчном методе [`match`]:

```js
console.log("one two 100".match(/\d+/)); // [ '100', index: 8, input: 'one two 100', groups: undefined ]
```

У возвращаемого объекта:

1. первым всегда идет полное совпадение регулярного выражения
   - может содержать не полные совпадения
2. index: позиция в строке, где начинается совпадение
3. input: сама строка
4. groups: если регулярка содержит сгруппированные выражения

В возвращаемом объекте можно обращаться к свойствам по их имени:

```js
 console.log("one two 100".match(/\d+/).index); // 8
```

Если регулярка содержит сгруппированные выражения то, помимо полного совпадения за ним возвращается совпадения в группах захвата:

```js
console.log(quotedText.exec("she said 'hello'"));
[
  "'hello'",        // [0] - полное совпадение со всем regex /'([^']*)'/
  'hello',          // [1] - текст, захваченный группой ([^']*)
  index: 9,         // позиция начала совпадения в строке
  input: "she said 'hello'",  // исходная строка
  groups: undefined // именованные группы отсутствуют
]
```

Если группа захвата не содержит никаких совпадений, то возвращается `undefined`:

```js
console.log(/bad(ly)?/.exec("bad")); // → ["bad", undefined]
```

Если для группы захвата есть несколько совпадений, то возвращается последнее совпадение:

```js
console.log(/bad(ly)?/.exec("badly")); // [ 'badly', 'ly', index: 0, input: 'badly', groups: undefined ]
```

Если нужно вывести в массив только совпадения без группировки, то можно в начало группы добавить `?:`:

```js
console.log(/(?:na)+/.exec("banana")); // [ 'nana', index: 2, input: 'banana', groups: undefined ]
```

## Класс даты

Объект на основе класса `Date` хранить много свойств и методов: getFullYear(), getMonth(), getDate(), getHours().

Данный объект своего рода календарь-оргонайзер, который знает сколько в каком месяце дней с учетом высокосных лет и т.д.

Вывод текущей даты:

```js
console.log(new Date); // 2025-09-23T18:43:36.596Z
```

Дата в формате ГОД-МЕСЯЦ-ДЕНЬ T ЧАСЫ:МИНУТЫ:СЕКУНДЫ.МИЛЛИСЕКУНДЫ Z, где:

- `T` означает Time и является разделителем между датой и временем
- `Z` означает Zero, т.е. смещение 0 часов от UTC

JS использует архаизм пришедший из JAVA, в котором первый месяц это ноль 0, следовательно декабрь - 11 месяц. Но, числа начинаются с единицы 1.

Для создания объекта с конкретной датой используют минимум 3 обязательных параметра (год, месяц, день):

```js
console.log(new Date(2013, 11, 19)); // 2013-12-18T20:00:00.000Z
```

Часы, минуты, секунды и миллисекунды являются опциональными, и при отсутствии при создании объекта даты они будут равны нулю.

В отличие от объекта Data, существует понятие временная метка (timestamp). Это 32-битное целое число, представляющее количество миллисекунд, прошедших с 1 января 1970 года. Временная метка может быть и отрицательной, т.е. можно отображать даты ранее 1970 года.

Чтобы получить из Date временную метку, используется метод `getTime()`:

```js
let date = new Date();
let timestamp = date.getTime();
console.log(timestamp); // 1758653203717
```

Конструктору Date можно передать временную метку:

```js
console.log(new Date(1387407600000)); // 2013-12-18T23:00:00.000Z
```

### Дата и регулярка

```js
function getDate(string) {
  let [_, month, day, year] = /(\d{1,2})-(\d{1,2})-(\d{4})/.exec(string);
  return new Date(year, month - 1, day);
}
console.log(getDate("1-30-2003"));
```

Передаем в функцию строку в виде перевернутой даты.

В `getDate` создается объект от регулярки: `[ '1-30-2003', '1', '30', '2003', index: 0, input: '1-30-2003', groups: undefined ]`

В этом объекте нужны только свойства 1, 2, 3. Нулево свойства, т.е. полное совпадение не нужно, оно попадает в переменную `_`.

Создаем на основе распарсенных данных объекта `Date` с переданной датой в него в парвильном формате датой.

### Границы (якоря)

#### Границы текста

В отличии от Python и Perl в JavaScript метасимволы \A и \Z не поддерживаются, вместо них используют:

- `^` - начало текста
- `$` - конец текста

```js
const text = `First line
Second line
Third line
Fourth line`;

console.log(text.match(/line$/)); // [ 'line', index: 41, input: 'First line\nSecond line\nThird line\nFourth line', groups: undefined ]
```

Указывает на индекс 41, т.е. начало последнего слова line/

#### Границы строк

Похож на границы текста

- `^` - начало строки
- `$` - конец строки

```js
console.log(/^\d+$/m.test("9")); // true
console.log(/^\d+$/m.test("9a")); // false
```

Но в многострочном тексте нужно использовать флаг m (multiline)

На прошлом примере с многостроничным текстом:

```js
console.log(text.match(/line$/m)); //['line', index: 6, input: 'First line\nSecond line\nThird line\nFourth line', groups: undefined]
```

Теперь матчится первая строка, а не весь текст, а именно индес 6, т.е. начало первого слова line.

Нельязя чтобы перед кореткой (циркумфлекс) были знаки, иначе циркумфлекс не будет воспринят как начало строки

Найдем строку, которая от начала до конца должна состоять из любого количества цифр:

#### Границы слов

`\b` — (word boundary) граница слова

```js
console.log("cat dog".match(/\bcat\b/));    // ✅ найдет "cat"
console.log("category dog".match(/\bcat\b/)); // ❌ не найдет (cat внутри слова)
```

Но, `\b` не работает для нелатинских символов, например, кириллицы:

```js
console.log(/\bпривет\b/iu.test("привет world")); // false
console.log(/\bworld\b/iu.test("привет world")); // true
```

Можно решить с помощью lookbehind:

```js
/(?<!\p{L})привет(?!\p{L})/u.test("привет мир"); // true
```

`\B` — не-граница слова

```js
console.log("cat dog".match(/\Bcat\B/)); //  null
console.log("thecategory dog".match(/\Bcat\B/)); //  [ 'cat', index: 3, input: 'thecategory dog', groups: undefined ]
```

### Опережающая проверка

Lookahead - Регулярное выражение использует опережающую проверку, чтобы найти X, за которым следует Y.

#### Позитивный lookahead

`?=` Ищем X если после него есть Y

Ищем `a` если после него есть `e`:

```js
/a(?=e)/.exec("braeburn") // Находит "a" из "ae", но возвращает только "a"
```

#### Негативный lookahead

`?!` Ищем X если после него НЕТ Y

Ищем `a` если после него НЕТ `пробела`:

```js
/a(?! )/.exec("ab")  // Найдет "a" (после "a" нет пробела)
```

Look-ahead проверяет условие, но не "съедает" символы - они остаются доступными для дальнейшего поиска.

```js
"abc".match(/ab/)  // Обычный матчинг находит `ab`, съедает `b` и продолжает поис с `c`
"abc".match(/a(?=b)/)  // lookahead находит `a` и `b` возращает только `a`, не съедая `b` продолжает поиск именно с `b`.
```

### Шаблонс с выбором

Предположим мы ищем в тексте любое количество животных (цифра + вид): pig, pigs, cow, cows, chiken, chickens. Можно написать для каждого слова свой регулярное выражение, и если хотябы одно true, значит какое-то слово есть. Но, есть более удобный механизм "шаблонс с выбором":

```js
let animalCount = /\d+ (pig|cow|chicken)s?/;
console.log(animalCount.test("15 pigs")); // true
console.log(animalCount.test("1 pig")); // true
console.log(animalCount.test("15 cows")); // true
console.log(animalCount.test("1 cow")); // true
console.log(animalCount.test("15 chickens")); // true
console.log(animalCount.test("1 chicken")); // true
console.log(animalCount.test("15 dogs")); // false
console.log(animalCount.test("1 dog")); // false
```

### Механизмы сравнивания

#### Откат

Ищем совпадения либо бинарного числа с `b` на конце, либо шестнадцатеричного числа с `h` на конце, либо десятичного числа без постфикса.

```js
/^([01]+b|[\da-f]+h|\d+)$/.test("103")
```

Данный шаблон имеет 3 ветки (одна на систему счисления). Первая ветка ищет бинарное число, если даже заведомо передано 103 - десятичное.
Только после того как проверка дойдет до тройки будет ясно что первая ветка не матчится. Тогда происходит "откат", т.е. возврат на начальную позицию для сравленния с другой веткой. Механизм запоминает позицию с которой начиналось сравнение и возвращается в нее при неудачном сравнении.
В случае если несколько веток могут совпасть с тестовой строкой. Сравнивание заканчивается на первом успехе.

Отказ, также происходит на метасимволах повторения (+, *):

```js
/^.*x/.test("abcxe") // true
```

Первая ветка `.*`, но не найдя `x` в конце строки произойдет откат и строка уменьшится с конца на один симовл, и так до тех пор пока не будет найдена соответствие `abcx`.

Механиз отката имеет отрицательный эффект у плохо написанного выражения. Например:

```js
/([01]+)+b/.test("101001100001")
```

Если мы передадит не двоичное число (без постфикса `b`), то при сравеннии всей строки не будет найден `b` и откат будет происходить до самого начала строки, что приведет к большому числу иттераций, а по факту нужно было бы проверить всего один символ `b` с помощью одной иттерации.

### RE в методе replace

В отличие от питона в JS метод reaplace() заменяет только первое вхождение:

```js
console.log("papa".replace("p", "m")); // mapa
```

Чтобы добиться замены всех вхождений (как при repalceAll()) нужно использовать глобальные регулярные выражения:

```js
console.log("papa".replace(/p/g, "m")); // "mama
```

#### Ссылки на группы

Ссылки на группы позволяют ссылаться на конкретные части, которые были найдены в регулярном выражении.

```js
console.log("pama".replace(/(pa)(ma)/g, "$2$1")); // mapa
```

Ссылки `$1` и `$2` соответствуют первой и второй скобочной группам.

`$&` - ссылка на все группы сразу.

#### Функция как параметр String.replace

Переданная в качестве аргумента фукнция будет вызываться для каждого совпадения регулярного выражения:

```js
let stock = "1 lemon, 2 cabbages and 101 eggs";

function minusOne(match, amount, unit) {
    amount = Number(amount) - 1;
    if (amount == 1) unit = unit.slice(0, unit.length-1);
    else if (amount == 0) amount = "no";
    return amount + " " + unit;
}

console.log(stock.replace(/(\d+) (\p{L}+)/gu, minusOne));
```

- `match` - текущее совпадение
- `ammount` - первая группа
- `unit` - вторая группа

### Жадность

`+`, `*`, `?`, `{}` - жадные операторы, они пытаются захватить максимальное количество символов, желательно всю строку. Если им это не удается, то происходит **откат** на один символ назад с каждым циклом сравнивания.

`+?`, `*?`, `??`, `{}?` - не жадные операторы, они пытаются захватить минимальное количество символов.

Функция удаляющие все коментарии в коде:

```js
function stripComments(code) {
    return code.replace(/\/\/.*|\/\*[^]*\*\//g, '');
}
console.log(stripComments("1 + /* 2 */3")); // → 1 + 3
console.log(stripComments("x = 10;// ten!")); // → x = 10;
console.log(stripComments("1 /* a */+/* b */ 1")); // → 1  1
```

Первая часть до `|` сравнивает на наличие однострочного коментария `//`, а вторая часть до `|` сравнивает на наличие многострочного коментария `/*`

`[^]` - любой не пустой символ, включая перевод строки `\n` и каретки `\r`. В данном случае можно использовать точку с флагом **s** `/./s`.

Как писалось ранее оператор * жадный, поэтому в поледний вовод `1 1` не имеет плюса между единицами. Т.к. при откате назад на 4 символа патерн уже совбадает с объявленным.

Если после жадных операторов поместить `?` - то будет **нежадный** оператор, то есть он будет захватывать минимальное количество символов. Поэтому код должен быть:

```js
function stripComments(code) {
  return code.replace(/\/\/.*|\/\*[^]*?\*\//g, "");
}
console.log(stripComments("1 /* a */+/* b */ 1")); // → 1 + 1
```

Предпочтительно использовать нежадные операторы по умолчанию, чтобы избежать подобных проблем.

### Динамические регулярные выражения

Регулярные выражения могут быть созданы во время выполнения программы.

Предположим хотим узнать есть ли заданное имя с тексте:

```js
let name = "harry";
let regexp = new RegExp("(^|\\s)" + name + "($|\\s)", "gi");
console.log(regexp.test("Harry is a dodgy character.")); // → true
```

`(^|\\s)` соотвествует началу строки или пробелу
`($|\\s)` - конец строки или пробел

Но, что если переменная `name` будет содержать специальные символы?

```js
let name = "dea+hl[]rd";
let escaped = name.replace(/[\\[.+*?(){|^$]/g, "\\$&");
let regexp = new RegExp("(^|\\s)" + escaped + "($|\\s)", "gi");
let text = "This dea+hl[]rd guy is super annoying.";
console.log(regexp.test(text)); // → true
```

Необходимо экранировать специальные символы: 

`[\\[.+*?(){|^$]` - перечисление всех специальных символов, их поиск и замена на `\\$&` прикрепление слеша к специальному символу, где `$&` - это плейсхолдер, т.е. найденный ранее спецсимвол.

`$` в методе `replace()` не является якорем конца строки, а является началом специальной ссылки:

```js
let text = "Hello World";
// $& - вся найденная подстрока
text.replace(/World/, "($&)") // "Hello (World)"
// $` - текст до совпадения
text.replace(/World/, "($`)") // "Hello (Hello )"
// $' - текст после совпадения  
text.replace(/World/, "($')") // "Hello ()"
// $1, $2... - группы захвата
text.replace(/(Hello) (World)/, "$2 $1") // "World Hello"
```

### RE в методе String.search

Методе `indexOf` не поддерживает регулярные выражения, но есть аналог - метод `search()`, он также позвращает индекс первого совпадения или -1 если ничего не нашлось:

```js
console.log("  word".search(/\S/)); // → 2
console.log("    ".search(/\S/)); // → -1
```

Но, метод `search()` не поддерживает смещение поиска offset.


### Свойство RegExp.lastIndex

Метод `exec()` не предоставляет удобного способа поиска с заданной позиции. Поэтому объект RegExp имеет свойства:

- `lastIndex`
- `source`
- `index`

### Флаг `g`

`g` не обнуляет `lastIndex`, которое позволяет задать место откуда начатинается/продолжается поиск.

```js
let pattern = /y/g;
pattern.lastIndex = 3;
let match = pattern.exec("xyzzy");
console.log(match.index); // → 4
console.log(pattern.lastIndex); // → 5
```

Если вызов метода exec() у объекта RexExp был успешным и первое совпадение найдено, то свойство `index` будет содержать индекс первого совпадения, а свойство `lastIndex` будет содержать индекс следующего символа после данного совпадения.
Если же совпадений не найдено, то `lastIndex` сбрасывается на 0.

### Метод String.match

`g` в сочетании с методом `match()` вместо того, чтобы выводить классический массиво-подобный объект, возвращается массив со всеми найденным совпадениями:

```js
console.log("Banana".match(/na/g)); // [ 'na', 'na' ]
```

### Метод String.matchAll

Метод возвращает массив массивов совпадений:

```js
let matches = "A string with 3 numpers in it... 42 and 88.".matchAll(/\d+/g);
for (let match of matches) {
  console.log(match);
}
// ['3', index: 14, input: 'A string with 3 numpers in it... 42 and 88.', groups: undefined]
// ['42', index: 33, input: 'A string with 3 numpers in it... 42 and 88.', groups: undefined]
// ['88', index: 40, input: 'A string with 3 numpers in it... 42 and 88.', groups: undefined]
```

### Флаг `y`

`y` начинает поиск в месте куда указывает lastIndex, т.е. если нужно искать шаблон из одной буквы в тексте, то будет искаться совпаднеие только в первой букве текста. Если в патерне несколько букв, то будет искать совпадение, в том количестве букв текста, которое в патерне

```js
let global = /abc/g;
console.log(global.exec("xyz abc")); // → [ "abc", index: 3, input: "xyz abc", groups: undefined ]
let sticky = /abc/y;
console.log(sticky.exec("xyz abc")); // → undefined
```

Если для одного регулярно выражение выполнить несколько `exec()`, то lastIndex будет меняться, что может привести к непредсказуемому поведению:

```js
let digit = /\d/g;
console.log(digit.exec("here it is: 1")); // → [ "1", index: 16, input: "here it is: 1", groups: undefined ]
console.log(digit.exec("here it is: 1")); // → null
```

### Метод String.split

Большой тест можно преобразовать в массив строк: 

```js
text.split(/\r?\n/)
```

`\r?\n/` - шаблон позволят найти совпадения для любого переноа строки: Windows `\r\n` и Unix `\n`. 

### Кодовые единицы в регулярных выражениях

Операторы подобные `.` и `?` работают с кодовыми единицами, но не с сурогатными парами:

```js
console.log(/🍎{3}/.test("🍎🍎🍎")); // → false
console.log(/<.>/.test("<🌹>")); // → false
```

В первом примере 🍎 воспринимается как 2 символа (55356, 57166), следовательно квантификатор {3} применяется к ближайшей слевой кодовой единице 57166, которая и ищется три раза в тесте.

Во втором примере точка также ожидает одного символа, но вместо этого приходят два.

Необходимо использовать флаг `u` для использования Unicode в регулярных выражениях:

```js
console.log(/🍎{3}/u.test("🍎🍎🍎")); // → true
console.log(/<.>/u.test("<🌹>")); // -> true
```

### Модель регулярных выражений

В регулярных выражениях испоьлзуются объекты на основе класса RegExp. Данные объекты работают как автоматы, которые используют состояния.
Например для /cat/ объект выглядит так:

```js
const regexAutomaton = {
  states: {
    0: { input: 'c', next: 1 },  // Начальное состояние: ждем 'c'
    1: { input: 'a', next: 2 },  // Состояние 1: после 'c' ждем 'a'  
    2: { input: 't', next: 3 }   // Состояние 2: после 'a' ждем 't'
  },
  currentState: 0,
  process(char) {
    if (this.states[this.currentState].input === char) {
      this.currentState = this.states[this.currentState].next;
      return true;
    }
    return false; // Не совпало - сброс к началу
  }
};

const automaton = createAutomaton(["c", "a", "t"]);

automaton.process("c") // state 0 → 1 ✅
automaton.process("a") // state 1 → 2 ✅  
automaton.process("t") // state 2 → 3 ✅ (успех!)

automaton.process("c") // state 0 → 1 ✅
automaton.process("b") // ❌ сброс к state 0 (ожидалась 'a')
```

## Модули

(eloquent 10)

Это куски программы, которые можно экспортировать иимпортировать из/в другие модули.
Интерфейсы модулей схожи с интерфейсами классов (объектов). Интерфесы других модулей прописываются в текущем как зависимости.

На заре JavaScript модули не были реализованы, и подключение дополнительных скриптов осуществлялось с помощью дополнительных `<script>`-тегов.

Чтобы использовать уже ранее написанный код в других скриптах использвовались библиотеки наподобие jQuery.

Со временм, когда написанного стало очень много и было неудобно добавлять код в глобальную область, как делает тег script, появились сборщики скриптов типа Webpack, затем появились и полноценные среды со своей экосистемой. Они и научились первыми собирать модули JavaScript, а с новыми стандартами ECMAScript, этому научился и сам язык.

Существет два основных подхода в организации модулей:

- CommonJS
- ES-модули

### CommonJS модули

До ES2015 для организации модульности сообщество node.js разработало собственную систему поверх языка JavaScript.

Данная система использует функцию для создания локальной области видимости для модулей и стандартных объектов, для создания модульных интерфейсов.

В начале программисты оборачивали весь код модуля в функцию:

```js
const weekDay = function() {
  const names = ["Sunday", "Monday", "Tuesday", "Wednesday",
                 "Thursday", "Friday", "Saturday"];
  return {
    name(number) { return names[number]; },
    number(name) { return names.indexOf(name); }
  };
}();

console.log(weekDay.name(weekDay.number("Sunday")));
```

Такая модульная система предоставляет изолированность, но не позволяет объявлять зависимости и не имеет унификации.

Поэтому родилась система CommonJS модулей, которая используется Node.js с самого начала (но там можно сейчас использовать и ES-модули).
CommonJS используется многими пакетами NPM.

Модуль CommonJS выглядит как обычный скрипт, имеющий доступ к двум сущностям, которые применяются для взаимодейтсвия с другими модулями:

1. Функция require()
2. Объект exports

Для среды nodje.js принятор использовать расширение `.cjs` для CommonJS модулей.

Ниже приводится код модуля **format-date** и его функцции форматирования даты, который использует 2 npm-пакета:

- ordinal (конвертирует цифры в строки)
- date-names (имена дней недели и месяцев)

```cjs
const ordinal = require("ordinal");
const {days, months} = require("date-names");

exports.formatDate = function(date, format) {
  return format.replace(/YYYY|M(MMM)?|Do?|dddd/g, tag => {
    if (tag == "YYYY") return date.getFullYear();
    if (tag == "M") return date.getMonth();
    if (tag == "MMMM") return months[date.getMonth()];
    if (tag == "D") return date.getDate();
    if (tag == "Do") return ordinal(date.getDate());
    if (tag == "dddd") return days[date.getDay()];
  });
};
```

Интерфейс пакета **ordinal** предоставляет единственную функцию, в то время как **date-names** экспортирует много сущностей, две из которых - **days** и **months** представляют массивы названий.
Модуль **format-date** экспортирует единственную функцию **formatDate**, которую мы импортируем в другом модуле:

```cjs
const formatDate = require("./format-date.js");
console.log(formatDate(new Date(2017, 9, 13), "dddd the Do"));
```

Загрузка модулей в CoomonJS реализована, с помощью оборачивания всего кода в функцию (со своей областью видимости), которая в качестве аргументов принимает функцию require и объект exports.

Если предположить что у нас есть функция readFile, читающая содержимое файла по его имени, то можно представить очень упрощунный код для функции **require**:

```cjs
function require(name) {
    if (!(name in require.cache)) {
        let code = readFile(name);
        let exports = require.cache[name] = {};
        let wrapper = new Function("module, exports", code);
        wrapper(exports, exports);
    }
    return require.cache[name];
}
require.cache = Object.create(null); // инициализация кэша вне функции, чтобы он был общим для всех модулей, исключая дубликаты зависимостей
```

где, конструктора Function() предсталвяет собой встроенную JS функцию (типа eval()), которая принимает 2 аргумента:

1. строка с разеделнными запятыми параметрами `"module, exports"`
2. тело функции `code`

Конструктора возвращает новую функцию, в которую переданы параметры из стороки в качестве аргументов, и тело функции.

Опасность данного конструктора, такая же как у eval(), из переданной в качестве аргумента строки можно получить исполняемый код, т.е. подменив входную строку, можно поменять исполняемый код.

`readFile` - подобной функции в стандарном JS нет. Но, различные среды (Node.js, Browser) предоставляют свои реализации доступа к файлам.

Во избажании загрузки модулей несколько раз, при дублировании одинаковых require(), можно использовать require.cache, которая хранит кэш загруженных модулей и их экспорты.

Важные отличия ES-модулей от CommonJS модулей:

- **exports** в ES-модуле является объектом, а не функцией
- в ES-модуле нет require, но есть импорт import
- import происходит до начала выполенния скрипта, а require выполняется в процессе его выполнения
- require можно объявлять внутри блоков (функции, условаия и т.д.), но import только в начале скрипта
- require в качестве аргументов может быть вычисляемым выражением, а в import только строкою

### ECMAScript модули

Классический JS не имеет модульной концепции. Все скрипты запускаются в одной области, подключенные например на одной странице браузера (современные браузеры поддерживают ES-модули).

В ES2015 произошло разделение на два вида программ JS:

- JS-Скрипты (все переменные в глобальной области, и они не могут напрямую ссылаться на другие скрипты)
- ES-Модули (имеют собственные области видимости, имеют ключевые слова import и export)

чтобы node.js вопринимал скрипты как ES-модули можно:

- `.mjs` - переиментовать расширение скрипта
- `--input-type=module` - использовать специальный ключ при запуске node.js

для браузера можно не переименовывать расширение, но в `<script>` прописать атрибут `type="module"` в теге `<script>`, как и с обычным скриптом, код модуля можно всставлять не файл а в теге `<script>`:

```html
<script type="module">
  import {dayName} from "./dayname.js";
  let now = new Date();
  console.log(dayName(now.getDay()));
</script>
```

ES-модуль внутри .mjs скрипта:

```mjs
const names = ["Sunday", "Monday", "Tuesday", "Wednesday",
               "Thursday", "Friday", "Saturday"];

export function dayName(number) {
  return names[number];
}
export function dayNumber(name) {
  return names.indexOf(name);
}
```

ES-модуль константа names не является частью интерфейса.

Ключевое слова export можно ставить перед функцией, классом или переменой, обозная их как часть **интерфейса** взаимодействия с данным модулем.
В другом модуле для взаимодействия с экспорируемым интерфейсом, нужно использовать ключевое слово import со списком импортируемых сущностей в фигурных скобках, что является **зависимостью** от других модулей:

```mjs
import {dayName} from "./dayname.js";
let now = new Date();
console.log(`Today is ${dayName(now.getDay())}`);
```

#### Import и Export

Имя модуля из которого нужно импортировать указыввается в выде ссылки в кавычках. Браузер воспринимает такую ссылку как URL, а Node.js как путь к файлу.

- **Import** импортирует **зависимости** в текущей модуль

- **Export** делает видимым **интерфейс** взаимодействия для других модулей

**Import** и **export** не может объявлятся внутри блочных эелементов (функций, циклов, условий, и т.д.).

Импортируемые пермеменные могут быть переименованны с присвоением им желаемого названия с помощью ключевого слова **as**:

```mjs
import {dayName as nomDeJour} from "./dayname.js";
console.log(nomDeJour(3));
```

Для импорта всех экспортируемых сущностей можно использовать ключевое слово **import** без фигурных скобок со зездочкой:

```mjs
import * as dayName from "./dayname.js";
console.log(dayName.dayName(3));
```

Для устранения конфликтов с существующими сущности при импорте можно с помощью `as` присвоить им другие названия:

```mjs
import {dayName as nomDeJour, dayNumber as numeroDeJour} from "./dayname.js";
console.log(nomDeJour(3));
console.log(numeroDeJour("Tuesday"));
```

##### Способы экспортов

1. Именованные
    - Индивидуальный - export ставится перед каждой сущностью
    - Групповой - экспортинование объекта сущностей: `export {dayName, dayNumber}`
2. По умолчанию

**export default** может быть использовано в одном модуле для объявления единственного экспортируемого интерфейса.

```mjs
export default ["Winter", "Spring", "Summer", "Autumn"];
```

Данный экспорт может быть импортирован в другом модуле без ключевого слова **as**:

```mjs
import seasonNames from "./seasonname.js";
```

где **seasonNames** может быть любым именем без привязки к реальному имени экспортируемого интерфейса.

Любой экспортированный объект, т.е. с ключевым словом export, является константой, т.е. его изменить нельзя, но его элементы можно изменить, в случае массивов и объектов.

#### Особенности модулей

- Модули работают по умолчанию в строгом режиме `use strict`.
- С модлями чаще может возникать ошибка CORS
- В теге `<script>` при указания атрибута `type="module"` автоматически подключается и атрибут `defer`
- Модули подключаются только один раз, даже если есть несколько ссылок в тегах script для их подключения
- Объекты из модуля добавляются в область видимости одного скрипта. В глобальной области они не видны.
- Динамическая загрузка модуле (самый свежак) с помощью промиса import(). Они загружаются именно тогда, когда они необходимы.

## Пакеты

Для среды node.js использовать ES-модули можно и без переименования расширения скриптов в `.mjs` и без ключа `--input-type=module`.
Для этого необходимо создать файл **package.json** с минимальным содержимым внутри папки с ES-скриптами:

```json
{
  "type": "module"
}
```

Данная директория станет пакетом, что позволит выполнять скрипты без переименования и специальных ключей. А также будет доступен другой функционал с помощью полей файла `package.json`:

- `dependencies` - Установка зависимостей с помощью поля 
- `version` - Контроль версий пакетов с помощью поля
- `scripts` - Определение команд для сборки, тестирования и запуска
- `main` - Определение главного модуля
- `exports` - Определение экспортов
- `name` - Определение имени пакета для публикации в репозитории сообщества NPM

Популярное место для обмена пакетами - [NPM](https://www.npmjs.com/).

### Компиляция и бандлинг

Building and bundling - процесс компиляции и упаковки кода для обратной совместимости со старыми версиями JS.

Компиляция необходима при использовании новых функций языка, либо при исползовании языков типа TypeScript, данный код переводится в понятный для браузеров исторический JS.

Упаковка нужна для сокращения времени загрузки файлов по сети. Т.к. загрузка 200 модулей занимает времени в несколько раз больше, нежели абсолютно тотже код но в одном модуле.

Минификаторы уменьшают размер кода в модуле, следующим образом:

- Сокращают названия переменных до минимально возможных
- Сокращают куски кода эквивалентным, но менее словесным
- Удаляют лишние пробелы и переносы строк
- Убирают ненужные комментарии
- Оптимизируют записи кода
- Объединяют схожие действия

## Сборка мусора

(advjs 01)

Движки JS обрабатывают функции, циклы, объекты, под которые выделяется память для хранения данных. 
Когда объект или примитив становится не нужен он удаляется из памяти.

Главный принцип организации памяти JS - достижимость.
Все объекты JS по достижимости можно разделить:

1. Корневые объекты
    - Глобальные переменные
    - Выполняемая функция
    - Функции в текущей цепочке вызовов с их объектами в локальных областях видимости
2. Дочерние объекты
    - Объекты вычисляемые по ссылкам от корневых
    - Объекты вычисляемые по ссылкам от дочерних
    - И т.д.

В итоге, список достижимых значений напоминает ветвистое дерево. В этом дереве живет особый процесс - сборщик мусора garbage collector, отслеживающий все объекты, которые не достижимы по ссылкам:

```js
let obj = { animal: "cat" };
obj = null;
```

`obj` - не ссылается ни на один объект, поэтому он удаляется сборщиком. Но, если так:

```js
let obj = { animal: "cat" };
let obj2 = obj;
obj = null;
```

`obj2` - ссылается на `obj`, поэтому `obj` не удаляется.

Может возникнуть такая ситуация, когда несколько объектов имеют ссылки друг на
друга, но ссылки на корневые объекты удалены. Тогда все эти объекты тоже
удаляются.

```js
function createCycle() {
    let obj1 = {name: 'Первый объект'};
    let obj2 = {name: 'Второй объект'};
    // Создаем циклическую ссылку: obj1 ссылается на obj2, а obj2 ссылается на obj1
    obj1.ref = obj2;
    obj2.ref = obj1;
    // Возвращаем один из объектов, чтобы убрать локальные ссылки
    return 'Цикл создан';
}
createCycle(); // Вызываем функцию
// В этот момент сборщик мусора может удалить obj1 и obj2
```

### Алгоритмы сборщика

Алгоритм Mark-and-Sweep позволяет проходить сборщику по дереву достижимых ссылок от корневых объектов и "помечает" все достижимые. Наши obj1 и obj2 не будут помечены, так как до них невозможно добраться от корня. В результате, на следующем цикле сборки мусора (Sweep) память, занятая этими двумя объектами, будет освобождена, несмотря на наличие циклических ссылок между ними.
Когда объектов очень много, сборщик мусора разделяет обход на части, стараясь обойти крупные ветви дерева в
разное время. Вместо одного большого обхода получается множество маленьких и вместо одной большой потери производительности множество маленьких. Объекты разделяются по поколениям — на новые и на старые.
Новые объект проверяются чаще, т.к. чаще всего новая функция отработали и более ее объекты не нужны.
Lвижки JS постоянно совершенствуются, на смену одним оптимизациям приходят другие.
