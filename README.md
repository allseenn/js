# JavaScript Basics

This repo contains my JS code from lectures and labs by GeekBrains online university. 

## 01. Lecture

### Intro

01.Lecture

**HTML** - язык разметки для веб-страниц

**CSS** - язык оформления HTML

**JS** - язык программирования или движок для веба и бекенда

### Движки

- V8
- Rhino
- SpiderMonkey
- JSC
- Chakra

Движки написаны на C++. Они интерпретируют скрипты на JS. Как правило движки встроены в прикладное ПО:

- Браузеры
- Node.js, Electron, React Native, Deno
- ПО для встраиваемых систем (роботы, Falcon 9, Iskra)

В свою очередь прикладное ПО работает в системных средах:

- Браузер установленный на десктопные OC (Windows, Linux, macOS)
- Node.js, Electron установленные на серверные OC (Windows, Linux, FreeBSD, macOS)
- Киоски (банкоматы, терминалы оплаты и т.д.) - легкая версия ОС с браузером

### Стандарты

ECMA international -  European Computer Manufacturers Association - Европейская ассоциация по стандартизации компьютерного производства. 

Наиболее известные стандарты ECMA:

- ECMA-376(OOXML) - Office Open XML
- ECMA-119 (ISO9660) - формат CD-ROM и DVD-ROM 
- ECMA-267 (UDF) - перезаписываемый формат CD-ROM и DVD-ROM
- ECMA-262 (ECMAScript) - язык программирования JavaScript

ECMAScript состоит из релизов:

- ES5
- ES6
- ES2022
- ES6+ - современный JS

### Этапы выполнения кода в браузере

1. Создается структура HTML-документа
2. Применяются стили
3. Добавляется контент (картинки, мультимедиа)
4. К странице подключается скрипт и выполняется

Браузер начинает выполнять JS-код в момент обнаружения его в html, поэтому рекомендуется помещать его в конце документа. Либо использовать специальные атрибуты.
Если произошла ошибка в коде, то браузер выдает сообщение в консоли, но продалжает загрузку контента, html и дальнейшего JS-кода.
Код выполнятся даже после того как все загрузилось, все время пока страница открыта.

### Переменные

- let
- const
- var

#### let и const

Ключевые слова let и const появились в ES2015:

- let для объявления переменных с блочной областью видимости

```js
let age = 10;
age = 15;
```

- const для объявления констант с блочной областью видимости их нельзя изменять

```js
const GAP_SIZE = 10;
GAP_SIZE = 15; // TypeError
```


#### var

До ES5 с помощью ключевого слова **var** инициализировали переменные. В современном релиза **var** осталась, но используется немного по другому:

1. Для инициализации переменной без присвоения значения:

```js
var a;
```
Значением переменной a будет undefined.

2. Для объявления глобальных переменных.


### Всплытие

**Hoisting** (всплытие) - уникальный механизм JS, позволяющий обращаться к значению переменной до ее объявления с помощью **var**. Значением при всплытии такой переменной будет undefined.

```js
console.log(age); // underfined
var brotherAge = age + 12
console.log(brotherAge) // Nan
var age = 10

console.log(name)
let name = "Ivan" // Uncaught ReferenceError
```

### Типы данных

В JS есть 8 типов данных:

1. string (строка)
2. number (число)
3. boolean (булевый)
4. undefined (неопределенный)
5. object (объект)
    - array (массив)
    - function (функция)
6. null (нуль)
7. BigInt (большое число)
8. symbol (символьный)

Примитивные типы данных в JavaScript не являются объектами и не имеют методов или свойств. Однако, когда вы пытаетесь использовать метод или свойство примитивного типа данных, JavaScript автоматически оборачивает его в объект, чтобы предоставить доступ к методам и свойствам.
Например, когда вы пытаетесь использовать метод toUpperCase() на строке, JavaScript оборачивает строку в объект String и предоставляет доступ к методу toUpperCase().

Для определения типа данных используют typeof:

```js
console.log(typeof 10); // number
```

Все типы данных отличаются:

- встроенными методами
- методами сравнения

#### Строка

Строка это текст в кавычках (одинарных, двойных или обратных):

```js
let name = "Ivan";
let lastName = 'Petrov';
let fullName = `Ivan Petrov`;
```

#### Шаблонный литерал

Строки внутри обратных кавычек называют **шаблонным литералом**

#### Числа

**Number** - это целое или дробное число, как в десятичной так и в других системах счисления, включая шестнадцатеричную. Для чисел есть ограничения от -2^53 до 2^53 не включительно.

Есть специальны значения, которые также имеют тип **number**:

- Infinity
- -Infinity
- NaN

Infinity, это число, которе получается в математических операциях, типа деления на ноль. 

```js
10 / 0 // Infinity
```

NaN поглощает арифметические операции, которые не могут быть выполнены, например операция нат разными типами данных.

```js
5 - '5' // NaN
```

#### Boolean

**Boolean** - это логический тип данных, который может иметь два значения: **true** и **false**.

#### Undefined

**Undefined** - значение не определено, как правило при пустой инициализации переменной или при возвращении функций без ключевого слова return.

```js
let name;
console.log(name); // undefined
```

#### Объект

Набор данных, к которым можно обратиться по имени объекта через точку:

```js
let person = {
    name: 'Ivan',
    age: 10
}
console.log(person.name); // Ivan
```

Или через квадратные скобки по ключу:

```js
console.log(person['name']); // Ivan
```

Объекты задаются пользователям, но есть 2 типа данных, которые являются встроенными объектами:

- Array
- Function

##### Array

Массив это список значений, которые можно обратиться по индексу, он может хранить неограниченное количество значений.

```js
let arr = [1, 2, 3];
console.log(arr[0]); // 1
```

##### Function

Функция - имеет свои методы и свои свойства. Она может быть сохранена в переменную или передана в качестве значения другому объекту.

Например, встроенный методе toString() возвращает строковое представление функции.

```js
const add = function(a, b) {
    return a + b;
}

console.log(add.toString()); // function add(a, b) { return a + b; }
```

Встроенные методы объектов, могут быть переопределены.


#### Null

**Null** - примитив, который возвращает **object**. [Неустранимый баг JS](https://habr.com/ru/sandbox/200708/)

```js
let name = null;
console.log(typeof name); // object
```

Null часто используют в API и при работе с DOM, когда ожидают возврата объекта, но возвращается null.

#### Symbol

**Symbol** - это встроенный тип данных, который используется для создания уникальных идентификаторов. Даже при одинаковых значениях они будут различаться.

```js
let id1 = Symbol("test");
let id2 = Symbol("test");
console.log(id1 === id2); // false
```

Добавлен в ECMASCript 2015.

#### BigInt

Супербольшие целые числа. Они записываются как обычные целые, только в конце есть литера n:

```js
let bigNum = 9007199254740991n;
console.log(typeof bigNum); // bigint
```

Используются например для меток времени с микросекундами.

## 03. Lecture

### Приведение типов

Явное приведение типов:

```js
let number = 10;
let string = number.toString();
console.log(typeof string); // string
```

2. Неявное приведение

```js
let number = 10;
let string = '10';
console.log(number + string); // 1010
```

Арифметические операции кроме сложения всегда приводят типы к одному.

#### Булево приведение

При приведении к булевому типу, у следующих значений будет **false**:

- ""
- 0, -0, NaN
- null
- undefined
- false

При приведении к булевому типу, у следующих значений будет **true**:

- "Hello"
- 42
- {} - объекты
- [] - массивы
- function foo() { ... } - функции

Булево приведение происходит автоматически при условных операторах. 
Любой тип данных можно привести к булеву с помощью отрицания !. Но, чтобы небыло инвертированного значения, можно использовать два отрицания !!.

```js
let value = 1;
console.log(!!value); // true
```

### Равенства

**==** нестрогое равенство, при котором происходит приведение типов:

```js
let a = 10;
let b = "10";
console.log(a == b); // true
```

**===** строгое равенство, при котором не происходит приведение типов и происходит сравнение типов данных:

```js
let a = 10;
let b = "10";
console.log(a === b); // false
```

Движки JS приводят типы по умолчанию к числу, поэтому нестрогое сравнение пустых массивов false, а сравнение тех же массивов, но с отрицанием true.
А вот сравнение пустого массива и инвертированного, тоже true:

```js
[] == []; // false
![] == ![] // true
[] == ![]; // true
// Потому, что:
+[] // 0 - в соответствии с правилами приведения выше пустой массив это false => +false = 0
![] // false - в соответствии с таблицей [] = true => !true = false => +false = 0
// 0 == 0 is true
```

Непустые объекты или непустые массивы между собой сравниваются по ссылкам, не сравнивая значения. Но, если сравнить объект с примитивом, то объект приводится к конкретному примитиву.

### Сравнения

Когда сравнивются строки, то это происходит посимвольно, слева направо:

```js
let a = '43';
let b = '42';
console.log(a > b); // true
```

Такое сравнение называют - **лексикографическим**.

В JS нет строго сравнения типа (>>), как это есть у равенств. Поэтому, у сравнений происходит приведение типов:

Если при приведении строка не можыть быть преобразована в число, то возвращается NaN, который не может быть ни больше, ни меньше. Поэтому при сравнении c участием NaN, всегда возвращается false.

```js
let a = 10;
let b = '9cc';
console.log(a > b); // false
```

### Унарные операторы

- Унарный минус -a (отрицательное число)
- Унарный плюс +a (приведение к числу)
- Инкремент a++
- Декремент a--
- Конкатенация 'a'+'b'
- Побитовое отрицание ~a
- Побитовая инверсия (исключающее или) ^a
- Логическое отрицание !a
- Побитовое и &a
- Побитовое или |a
- Побитовый сдвиг влево <<a
- Побитовый сдвиг вправо >>a
- Оператор доступа к свойству объекта (точка) a.b
- Оператор разделения элементов или вычисления выражений ,
- Деструктуризация ...a
- void 
- typeof
- delete

### Проверки и приведение

Если переменная не путая строка "" и не ноль 0:

```js
let a = "John";
if (a) {
    console.log(a);
}
```

Чтобы привести число к строке можно сложить его с пустой строкой:

```js
let a = 10;
console.log("" + a); // "10"
```

Проверка в условии пустой ли массив:

```js
let a = [];
if (a.length) {
    console.log(a);
}
```

### Методы ввода

У объекта window есть методы ввода:

1. windows.alert()
2. window.prompt()
3. windows.confirm()

Т.е. window - это глобальная область видимости, то методы можно указывать без window.
Методы вызывают диалоговые окна в браузере, которые нельзя изменить и определить их положение.


### Условные конструкции

Условие - любое выражение возвращающее болевое значение (true или false). Если условие верно, то выполняется блок кода, иначе - нет. Если выражение условия возвращает не булевый тип, то он будет приведен к булевому.

false:

- ""
- 0, -0, NaN
- null
- undefined

true:

- любое другое значение

#### Тернарный оператор

```js
let a = 10;
let b = 20;
let c = a > b ? a : b;
console.log(c); // 20
```

### Консоль браузера

CTRL+SHIFT+C - открыть инструменты разработчика
CTRL+SHIFT+I - открыть инспектор
CTRL+SHIFT+J - открыть консокль

## 05. Lecture

### Функции

#### Классификация по всплытию

- Анонимные
- Именованные

**Анонимные** функции используют **функциональное выражение**, где функция создается в момент выполнения данного выражения

```js
const sum = function(a, b) {
    return a + b;
};
```

**Именованные** функции используют **декларативное объявление**, где функция создается до основной компиляции кода, т.е. всплывает вверх. Поэтому такая функция может быть расположена в конце кода, а вызываться в начале.

```js
function sum(a, b) {
  return a + b;
}
```

#### По параметрам

- С обязательными параметрами
- С опциональными параметрами
- Без параметров

**Параметр функции** - это имя переменной, которое находится внутри скобок после имени функции.

**Аргумент функции** - это значение передаваемое параметру функции.

По возвращаемому значению:

- Возвращающие значение
- Не возвращающие значение (всегда возвращает undefined)

##### Опциональные параметры

Если задать функцию с одним параметром, а передать несколько, то ошибки не будет:

```js
square = x => x*x;
console.log(square(4, 'a', "string"));
// 16
```

JS-это не строгий язык, т.е. можно передать несколько параметров, но не все параметры будут использоваться. Если же передать меньше параметров, то В таком случае остальные параметры будут undefined.

Можно использовать данный побочный эффект в своих целях, например:

```js
const minus = (a, b) => {
    if (b === undefined) {
        return -a;
    }
    return a - b;
}

console.log(minus(10)); // -10
console.log(minus(10, 5)); // 5
```

В случае отсутствия значения параметра b, посчитается условие.

Если написать = (равно), после параметра, то данный параметр будет иметь значение по умолчанию:

```js
const minus = (a, b = 0) => {
    return a - b;
}
console.log(minus(10)); // 10
console.log(minus(10, 5)); // 5
```

#### По побочному эффекту

**Чистые функции**без побочных эффектов, как правило возвращают значение:

```js
const sum = (a, b) => {
    return a + b;
}
```

**Функции с явными побочными эффектами**:

```js
const sum = (a, b) => {
    console.log(a + b);
}
```

**Гибридные функции**:

```js
const sum = (a, b) => {
    console.log(a + b);
    return a + b;
}
```

### Стрелочные функции

В ES2015 появились стрелочные функции, в них убрано ключевое слово function:

```js
const sum = (a, b) => 
{
    return a + b;
}
```

Если параметр функции один, то можно убрать скобки:

```js
const square = a => 
{
    return a * a;
}
```

Но, если параметров нет вообще, то пустые скобки нужны:

```js
const square = () => 
{
    return 2 * 2;
}
```

Если функция возвращает одно выражение, то можно убрать фигурные скобки и ключевое слово return:

```js
const square = () => 2 * 2;
```

Можно устанавливать параметры по умолчанию:

```js
const sum = (a = 0, b = 0) => 
{
    return a + b;
}
```

### Стек вызовов

ОЗУ в JS делится на 3 вида памяти:

- Стековая память (stack memory) - специализированная область памяти, предназначенная для хранения стека вызовов
- Динамическая память (dynamic memory) - область памяти, которая может быть выделена и освобождена динамически во время выполнения программы
- Куча (heap) - область памяти, которая используется для хранения данных, которые не имеют фиксированного размера

Стековая память используется для хранения **стека вызовов**

Когда вызывается функция, она добавляется на вершину стека вызовов, если внутри нее выполняется еще функция, то следующая добавляется выше и т.д.
Когда функция завершает свое выполнение, она удаляется из вершины стека и так до тех пор пока стек не освободится.

Если вызовов функций слишком много, например в случае неправильной рекурсии, то стек будет переполнен и программа завершится с ошибкой: **Maximum call stack size exceeded**

### Область видимости

- Глобальная область видимости
- Область видимости функции
- Область видимости блока
- Вложенная область видимости

Глобальные переменные являются свойствами объекта window для браузера или объекта global для Node.js

### Лексическая область видимости

Лексическая область видимости - это область видимости, которая определяется местом объявления переменной. Она имеет следующие правила:

1. Глобальные переменные видны во всех областях видимости
2. Все переменные любых локальных областей видят глобальную область
3. Переменные и объекты в локальной области видят все вложенные в нее области видимости

### Замыкания

Возможность передавать функцию как значение, плюс факт того, что каждый раз при вызове одной и тоже функции внутри области видимости каждого вызова создаются независимые переменные, открывает побочный эффект - **замыкание**:

```js
function makeCounter() {
    let count = 0;
    return () => count++;
}
const counter = makeCounter();
console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2
```

Тут стрелочная функция которая имеет доступ к внешней переменной count называется замыканием.
Легко сравнить замыкание как функцию которая запускается в среде окружения, в которой уже задана некая переменная, причем эта среда активируется именно в том месте из которого запустили замыкание.

### Рекурсивная функция

Функция которая сама себя вызывает называется **рекурсивная функция**

```js
function power(base, exponent){
    if (exponent === 0) {
        return 1;
    } else {
        return base * power(base, exponent - 1);
    }
}
console.log(power(2, 3)); // 8
```

Данная реализации вычисления степени числа в три раза медленнее чем вариант с циклом.

### Именование функций

Функции должны начинаться с глагола и с маленькой буквы.

```js
function getSum(a, b) {
    return a + b;
}
```

Не нужно давать слишком длинные имена функциям, типа **getSumOfTwoNumbers**


### Браузерные события

У HTML-тегов есть атрибут onclick, который выполняет код при нажатии мышью по тегу.

Для того чтобы не писать длинные инструкции в атрибуте onclick, можно использовать функцию-обработчик:

```html
<button onclick="buy()">Buy</button>
<script>
    function buy() { 
        alert('Congratulations! You have bought a good!');
        alert('Good luck!'); 
    }
</script>
```

## 07. Lecture

