# JavaScript Basics

This repo contains my JS code from lectures and labs by GeekBrains online university.

## 01. Lecture

### Intro

01.Lecture

**HTML** - язык разметки для веб-страниц

**CSS** - язык оформления HTML

**JS** - язык программирования или движок для веба и бекенда

### Движки

- V8
- Rhino
- SpiderMonkey
- JSC
- Chakra

Движки написаны на C++. Они интерпретируют скрипты на JS. Как правило движки встроены в прикладное ПО:

- Браузеры
- Node.js, Electron, React Native, Deno
- ПО для встраиваемых систем (роботы, Falcon 9, Iskra)

В свою очередь прикладное ПО работает в системных средах:

- Браузер установленный на десктопные OC (Windows, Linux, macOS)
- Node.js, Electron установленные на серверные OC (Windows, Linux, FreeBSD, macOS)
- Киоски (банкоматы, терминалы оплаты и т.д.) - легкая версия ОС с браузером

### Стандарты

ECMA international - European Computer Manufacturers Association - Европейская ассоциация по стандартизации компьютерного производства.

Наиболее известные стандарты ECMA Inc.:

- ECMA-376 (OOXML) - Office Open XML
- ECMA-119 (ISO9660) - формат CD-ROM и DVD-ROM
- ECMA-267 (UDF) - перезаписываемый формат CD-ROM и DVD-ROM
- ECMA-262 (ECMAScript) - язык программирования JavaScript

ECMAScript состоит из релизов:

- ...
- ES5
- ES6
- ES2022
- ES6+ - современный JS

### Этапы выполнения кода в браузере

1. Создается структура HTML-документа
2. Применяются стили
3. Добавляется контент (картинки, мультимедиа)
4. К странице подключается скрипт и выполняется

Браузер начинает выполнять JS-код в момент обнаружения его в html, поэтому рекомендуется помещать его в конце документа. Либо использовать специальные атрибуты.
Если произошла ошибка в коде, то браузер выдает сообщение в консоли, но продолжает загрузку контента, html и дальнейшего JS-кода.
Код выполнятся даже после того как все загрузилось, все время пока страница открыта.

### Операторы

#### Унарные операторы

- `-a` - Унарный минус (отрицательное число)
- `+a` - Унарный плюс  (приведение к числу)
- `a++` - Инкремент
- `a--` - Декремент
- `~a` - Побитовое отрицание
- `^a` - Побитовая инверсия (исключающее или)
- `!a` - Логическое отрицание
- `&a` - Побитовое И
- `|a` - Побитовое ИЛИ
- `<<a` - Побитовый сдвиг влево
- `>>a` - Побитовый сдвиг вправо
- `a.b` - Оператор доступа к свойству объекта (точка)
- `...a`- rest или spread операторы
- `a, b -` Оператор разделения элементов или вычисления выражений
- void - оператор пустого значения - возвращает undefined
- new - оператор создания объекта
- typeof - оператор получение типа объекта
- delete - удаление и возврат true, false в случае успеха, неуспеха

#### Бинарные операторы

- `a + b` - Сложение
- `a - b` - Вычитание
- `a * b` - Умножение
- `a / b` - Деление
- `a % b` - Остаток от деления (модуль)
- `a = b` - Оператор присваивания
- `a?.b` - Оператор опциональной цепочки
- `a ** b` - Возведение в степень
- `'a'+'b'`- Конкатенация
- `a && b` - Логическое И
- `a || b` - Логическое ИЛИ
- `a ^ b` - Исключающее ИЛИ
- `a in b` - Проверка наличия свойства в объекте
- `a of b` - В циклах for..of
- `a ?? b` - Нулевое слияние (Nullish Coalescing Operator) - удобен для задания значений по умолчанию. В нем берется правая часть, если слева null или undefined
- `a == b` - Сравнение по значению
- `a === b` - Сравнение по значению и типу
- `a != b` - Сравнение по значению
- `a !== b` - Сравнение по значению и типу
- `a > b` - Сравнение по значению
- `a < b` - Сравнение по значению
- `a >= b` - Сравнение по значению
- `a <= b` - Сравнение по значению

#### Тернарный оператор

- `a ? b : c`

Операторы сравнения, тернарный оператор,  возвращают булево значение: true, false

### Приоритет операторов

| Приоритет | Оператор | Описание |
| --- | --- | --- |
| 1 | `()` | Группировка выражений |
| 2 | `.` `[]` | Доступ к свойствам и индексам |
| 3 | `new` | Создание объектов |
| 4 | `++` `--` | Инкремент и декремент |
| 5 | `!` `~` `+` `-` `typeof` `void` | Унарные операторы |
| 6 | `*` `/` `%` | Умножение, деление и остаток |
| 7 | `+` `-` | Сложение и вычитание |
| 8 | `<<` `>>` `>>>` | Битовые сдвиги |
| 9 | `<` `<=` `>` `>=` | Сравнения |
| 10 | `==` `!=` `===` `!==` | Проверка равенства |
| 11 | `&` | Битовая операция И |
| 12 | `^` | Битовая операция XOR |
| 13 | `\|` | Битовая операция ИЛИ |
| 14 | `&&` | Логическое И |
| 15 | `\|\|` | Логическое ИЛИ |
| 16 | `?:` | Условный оператор |
| 17 | `=` `+=` `-=` `*=` `/=` `%=` `**=` | Присваивание |
| 18 | `,` | Запятая (разделитель выражений) |

### Переменные

- let с ES2015
- const c ES205
- var

#### let

Используется для объявления переменных с блочной областью видимости:

```js
let age = 10;

if (true) {
    let age = 20;
    console.log(age); // 20
}

console.log(age); // 10
```

**let** можно переопределять, но не переобъявлять:

```js
let age = 10;
age = 20;
console.log(age); // 20

let age = 30; // SyntaxError
```

#### const

Используется для объявления констант с блочной областью видимости их нельзя изменять

```js
const GAP_SIZE = 10;
GAP_SIZE = 15; // TypeError
```

Часто используется для инициализации изменяемых типо данных (массивы, объекты):

```js
const arr = [1, 2, 3];
const obj = {name: "Ivan", age: 10};

arr = 4 // TypeError: Assignment to constant variable. 
obj = "hello" // TypeError: Assignment to constant variable. 
```

где, используется для защиты от случайного затирания с помощью других типов данных.

#### var

До ES5 с помощью ключевого слова **var** инициализировали переменные. В современном релиза **var** осталась, но используется немного по другому:

1. Для объявления глобальных переменных.
2. Для инициализации переменной без присвоения значения:

```js
var a;
```

Значением переменной **a** будет **undefined**.

var имеет область видимости в пределах функций:

```js
function test() {
    if (true) {
        var a = 10;
        console.log(a); // 10
    }
    console.log(a); // 10
}
```

Т.е. переменная **a** видна внутри функций и за пределами блока if, что не работает с let и const.

Переменную типа var можно переобъявить:

```js
var a = 10;
var a = 20;
console.log(a); // 20
```

При объявлении переменной **a** с помощью var, значение **a** будет являться свойством глобального объекта **window** или **global** в Node.js, что позволять создавать глобальные переменные даже вне текущего модуля.

Переменную типа var можно переобъявить:

```js
var a = 10;
var a = 20;
console.log(a); // 20
```

Переобъявление **var** работает благодаря **hoisting**.

### Всплытие

**Hoisting** (всплытие) - уникальный механизм JS, позволяющий обращаться к значению переменной до ее объявления с помощью **var**. Значением при всплытии такой переменной будет undefined.

```js
console.log(age); // undefined
var brotherAge = age + 12
console.log(brotherAge) // Nan
var age = 10

console.log(name)
let name = "Ivan" // Uncaught ReferenceError
```

### Типы данных

В JS есть 8 типов данных:

1. string (строка) - неизменяемый примитив
2. number (число) - неизменяемый примитив
    - Infinity (бесконечность)
    - NaN (Not A Number)
3. bigInt (большое число) - неизменяемый примитив
4. boolean (булев) - неизменяемый примитив
    - true
    - false
5. symbol (символьный) - неизменяемый примитив
6. undefined (неопределенный) - неизменяемый примитив
7. null (нуль) - неизменяемый примитив, но при проверке указывает на то, что это объект
8. object (объект) - изменяемые типы данных
   - array (массив)
   - function (функция)

Примитивные типы данных в JavaScript не являются объектами и не имеют методов или свойств. Однако, когда вы пытаетесь использовать метод или свойство примитивного типа данных, JavaScript автоматически оборачивает его в объект, чтобы предоставить доступ к методам и свойствам.
Например, когда вы пытаетесь использовать метод toUpperCase() на строке, JavaScript оборачивает строку в объект String и предоставляет доступ к методу toUpperCase().

Для определения типа данных используют typeof:

```js
console.log(typeof 10); // number
```

Все типы данных отличаются:

- встроенными методами
- методами сравнения

#### 1. string

Строка это текст в кавычках (одинарных, двойных или обратных):

```js
let name = "Ivan";
let lastName = 'Petrov';
let fullName = `Ivan Petrov`;
```

##### Шаблонный литерал

Строки внутри обратных кавычек называют **шаблонным литералом**

#### 2. number

**Number** - это целое или дробное число, как в десятичной так и в других системах счисления, включая шестнадцатеричную. Для чисел есть ограничения от -2^53 до 2^53 не включительно.

```js
let целоеЧисло = 42;
let дробноеЧисло = 3.14;
let двоичноеЧисло = 0b1010;
let восьмеричноеЧисло = 0o12;
let шестнадцатеричноеЧисло = 0xA;
let экспоненциальноеЧисло = 1.5e2;
```

Есть специальны значения, которые также имеют тип **number**:

- Infinity
- -Infinity
- NaN

##### Infinity

Infinity, это число, которе получается в математических операциях, типа деления на ноль.

```js
10 / 0 // Infinity
```

##### NaN

NaN поглощает арифметические операции, которые не могут быть выполнены, например операция нат разными типами данных.

```js
5 - '5' // NaN
```

Tип **number** имеет встроенные методы

##### toFixed

```js
let number = 10.123456789;
console.log(number.toFixed(2)); // 10.12
```

##### toExponential

```js
let number = 10.123456789;
console.log(number.toExponential(2)); // 1.01e+1
```

##### toLocaleString

```js
let number = 10.123456789;
console.log(number.toLocaleString()); // 10.123457
```

##### toPrecision

```js
let number = 10.123456789;
console.log(number.toPrecision(2)); // 10.1
```

##### toString

```js
let number = 10.123456789;
console.log(number.toString()); // 10.123456789
```

##### valueOf

```js
let number = 10.123456789;
console.log(number.valueOf()); // 10.123456789
```

##### isFinite

```js
let number = 10.123456789;
console.log(isFinite(number)); // true
```

##### isNaN

```js
let number = 10.123456789;
console.log(isNaN(number)); // false
```

#### 3. bigInt

Супербольшие целые числа. Они записываются как обычные целые, только в конце есть литера n:

```js
let bigNum = 9007199254740991n;
console.log(typeof bigNum); // bigint
```

Используются например для меток времени с микросекундами.

#### 4. boolean

**Boolean** - это логический тип данных, который может иметь два значения: **true** и **false**.

#### 5. Symbols

**Symbol** - это встроенный примитивный неизменяемый тип данных (не объект), для создания уникальных идентификаторов, которые даже при одинаковых значениях будут различаться.

```js
let id1 = Symbol("test");
let id2 = Symbol("test");
console.log(id1 === id2); // false
```

#### 6. undefined

**undefined** - значение не определено, как правило при пустой инициализации переменной или при возвращении функций без ключевого слова return.

```js
let name;
console.log(name); // undefined
```

#### 7. null

**null** - примитив, который возвращает **object**. [Неустранимый баг JS](https://habr.com/ru/sandbox/200708/)

```js
let name = null;
console.log(typeof name); // object
```

Null часто используют в API и при работе с DOM, когда ожидают возврата объекта, но возвращается null.

null и undefind имеют одинаковый смисл но разный тип данных

#### 8. object

Набор данных, к которым можно обратиться по имени объекта через точку:

```js
let person = {
    name: 'Ivan',
    age: 10
}
console.log(person.name); // Ivan
```

Или через квадратные скобки по ключу:

```js
console.log(person['name']); // Ivan
```

Объекты задаются пользователям, но есть 2 типа данных, которые являются встроенными объектами:

- Array
- Function

##### array

Массив это список значений, которые можно обратиться по индексу, он может хранить неограниченное количество значений.

```js
let arr = [1, 2, 3];
console.log(arr[0]); // 1
```

##### function

Функция - имеет свои методы и свои свойства. Она может быть сохранена в переменную или передана в качестве значения другому объекту.

Например, встроенный методе toString() возвращает строковое представление функции.

```js
const add = function(a, b) {
    return a + b;
}

console.log(add.toString()); // function add(a, b) { return a + b; }
```

Встроенные методы объектов, могут быть переопределены.

## 03. Lecture

### Приведение типов

#### Явное приведение типов

```js
let number = 10;
let string = number.toString();
console.log(typeof string); // string
```

#### Неявное приведение

```js
let number = 10;
let string = '10';
console.log(number + string); // 1010
```

Арифметические операции кроме сложения всегда приводят типы к одному.

#### Булево приведение

При приведении к булеву типу, у следующих значений будет **false**:

- ""
- 0, -0, NaN
- null
- undefined
- false

При приведении к булеву типу, у следующих значений будет **true**:

- "Hello"
- 42
- {} - объекты
- [] - массивы
- function foo() { ... } - функции

Булево приведение происходит автоматически при условных операторах.
Любой тип данных можно привести к булеву с помощью отрицания !. Но, чтобы не было инвертированного значения, можно использовать два отрицания !!.

```js
let value = 1;
console.log(!!value); // true
```

### Равенства

**==** нестрогое равенство, при котором происходит приведение типов:

```js
let a = 10;
let b = "10";
console.log(a == b); // true
```

**===** строгое равенство, при котором не происходит приведение типов и происходит сравнение типов данных:

```js
let a = 10;
let b = "10";
console.log(a === b); // false
```

Движки JS приводят типы по умолчанию к числу, поэтому нестрогое сравнение пустых массивов false, а сравнение тех же массивов, но с отрицанием true.
А вот сравнение пустого массива и инвертированного, тоже true:

```js
[] == []; // false
![] == ![] // true
[] == ![]; // true
// Потому, что:
+[] // 0 - в соответствии с правилами приведения выше пустой массив это false => +false = 0
![] // false - в соответствии с таблицей [] = true => !true = false => +false = 0
// 0 == 0 is true
```

Непустые объекты или непустые массивы между собой сравниваются по ссылкам, не сравнивая значения. Но, если сравнить объект с примитивом, то объект приводится к конкретному примитиву.

### Сравнения

Когда сравниваются строки, то это происходит посимвольно, слева направо:

```js
let a = '43';
let b = '42';
console.log(a > b); // true
```

Такое сравнение называют - **лексикографическим**.

В JS нет строго сравнения типа (>>), как это есть у равенств. Поэтому, у сравнений происходит приведение типов:

Если при приведении строка не может быть преобразована в число, то возвращается NaN, который не может быть ни больше, ни меньше. Поэтому при сравнении c участием NaN, всегда возвращается false.

```js
let a = 10;
let b = '9cc';
console.log(a > b); // false
```

#### Ленивые вычисления

short-circuit evaluation - по аналогии с "коротким замыканием" в электронике, где ток течет по наименьшему сопротивлению. Аналогично при ленивом вычислении логических операторов (&& и ||) в JavaScript (и других языках), при котором второй операнд вычисляется только при необходимости.

### Проверки и приведение

Если переменная не пустая строка "" и не ноль 0:

```js
let a = "John";
if (a) {
    console.log(a);
}
```

Чтобы привести число к строке можно сложить его с пустой строкой:

```js
let a = 10;
console.log("" + a); // "10"
```

Проверка в условии пустой ли массив:

```js
let a = [];
if (a.length) {
    console.log(a);
}
```

### Методы ввода

У объекта window есть методы ввода:

1. windows.alert()
2. window.prompt()
3. windows.confirm()

Т.е. window - это глобальная область видимости, то методы можно указывать без window.
Методы вызывают диалоговые окна в браузере, которые нельзя изменить и определить их положение.

### Условные конструкции

Условие - любое выражение возвращающее болевое значение (true или false). Если условие верно, то выполняется блок кода, иначе - нет. Если выражение условия возвращает не булевый тип, то он будет приведен к булевому.

false:

- ""
- 0, -0, NaN
- null
- undefined

true:

- любое другое значение

#### Условный тернарный оператор

```js
let a = 10;
let b = 20;
let c = a > b ? a : b;
console.log(c); // 20  
```

#### Switch

```js
let a = 10;
switch (a) {
    case 10:
        console.log('10');
        break;
    case 20:
        console.log('20');
        break;
    default:
        console.log('default');
        break;
}
```

### Комментарии

```js
// однострочный комментарий
/* многострочный комментарий */
```

### Консоль браузера

CTRL+SHIFT+C - открыть инструменты разработчика
CTRL+SHIFT+I - открыть инспектор
CTRL+SHIFT+J - открыть консокль

## 05. Lecture

### Функции

Функция это кусок кода (программы), которая являются объектным типом данных.

#### Встроенные функции

- Object() - создает объект
- Array() - создает массив
- Number() - конвертирует аргумент в число
- String() - в строку
- Boolean() - к булеву типу


Данные функции в сочетании с оператором new используются как [конструкторы](#конструктор-объекта) для создания объектов.

#### Функции конструкторы

Пользовательские функции конструкторы, используемые для создания пользовательских объектов принято именовать с большой буквы:

```js
function Person(name, age) {
    this.name = name;
    this.age = age;
}
```

Т.к. конструкторы это функции, то присваивание переменных (свойств) происходит с помощью знака равно, а не двоеточия, как у объектов.

Для создания объекта с помощью функции-конструктора используется оператор new:

```js
let person = new Person('John', 30);
console.log(person); // {name: "John", age: 30}
```

##### Встроенные функции конструкторы

- Date() - конструктор даты
- RegExp() - конструктор регулярных выражений
- Function() - конструктор функций
- Error() - конструктор ошибок
- Map() - конструктор карт
- Set() - конструктор множеств
- WeakMap() - конструктор слабых карт
- WeakSet() - конструктор слабых множеств

Конструкторы могут иметь встроенные свойства и методы:

```js
let today = new Date().getDay();
```

#### Именование функций

Функции должны начинаться с глагола и с маленькой буквы.

```js
function getSum(a, b) {
    return a + b;
}
```

Не нужно давать слишком длинные имена функциям, типа **getSumOfTwoNumbers**

С большой буквы именуются функции-конструкторы

#### Классификация по всплытию (hoisting)

- Невсплывающие (Анонимные) функции
- Всплывающие (Именованные) функции

##### Невсплывающие функции

**Анонимные** функции используют **функциональное выражение**, где функция создается в момент выполнения данного выражения

```js
const sum = function(a, b) {
    return a + b;
};
```

##### Всплывающие функции

**Именованные** функции используют **декларативное объявление**, где функция создается до основной компиляции кода, т.е. всплывает вверх. Поэтому такая функция может быть расположена в конце кода, а вызываться в начале.

```js
function sum(a, b) {
  return a + b;
}
```

#### По возвращаемому значению

- Возвращающие значение
- Не возвращающие значение (всегда возвращает undefined)

#### По параметрам

- С обязательными параметрами
- С опциональными параметрами
- Без параметров

**Параметр функции** - это имя переменной, которое находится внутри скобок после имени функции.

**Аргумент функции** - это значение передаваемое параметру функции.

##### Обязательные параметры

JS-это не строгий язык, т.е. можно передать несколько параметров, но не все параметры будут использоваться.

```js
const minus = (a, b) => {
    return a - b;
}
console.log(minus(10, 5, 8, 9)); // 5
```

Если же передать меньше параметров, то недостающим параметрам присвоится undefined:

```js
const minus = (a, b) => {
    if (b === undefined) {
        return -a;
    }
    return a - b;
}

console.log(minus(10)); // -10
console.log(minus(10, 5)); // 5
```

В случае отсутствия значения параметра b, выполнится условие if.

##### Опциональные параметры

Если написать = (равно), после параметра, то данный параметр будет иметь значение по умолчанию:

```js
const minus = (a, b = 0) => {
    return a - b;
}
console.log(minus(10)); // 10
console.log(minus(10, 5)); // 5
```

#### По наличию побочного эффекта

- Чистые функции
- Функции с побочным эффектом
- Гибридные функции

##### Чистые функции

Чистая функция:

- не контактирует с глобальными переменными
- не связаны со сторонними побочными эффектами от других функций
- получает данные только чрез аргументы
- возвращает одно и тоже (ожидаемое) значение
- легко переиспользуемы в других местах или коде

При создании чистой функции следует быть внимательным к изменяемым типам данных, например объектам,
т.к. свойства объекта легко изменить извне, следует создавать копию объекта внутри функции:

```js
const addPropToObj(object, key, value){
    return {
        ...object,
        [key]: value
    }
}
```

Функции без побочных эффектов, как правило возвращают значение:

```js
const sum = (a, b) => {
    return a + b;
}
```

##### Функции с явными побочными эффектами

```js
const sum = (a, b) => {
    console.log(a + b);
}
```

Нечистые функции использующие **побочные эффекты** - получение данных по сети или из БД, тоже нужны и без них нельзя. Но, нужно стараться по максимуму использовать чистые, а обращения по сети и к БД выносить в грязные функции.

##### Гибридные функции

```js
const sum = (a, b) => {
    console.log(a + b);
    return a + b;
}
```

### Классификация по способу объявления

- Декларативные функции
- Функциональные выражения
- Стрелочные функции

#### Декларативные функции

Декларативная функция состоит:

- ключевого слова function
- имени функции
- параметров
- тело функции

```js
function sum(a, b) {
    return a + b;
}
```

Декларативно объявленные функции могут не завершаться точкой с запятой.

Декларативные функции могут быть объявлены раньше вызывающего их кода. Причину смотри в **Hoisting** всплытии функции.

#### Функциональное выражение

Функциональное выражение состоит:

- ключевого слова function
- параметров
- тело функции

```js
const sum = function(a, b) {
    return a + b;
}
```

Функциональные выражения часто присваивают переменной.

#### Стрелочные функции

В ES2015 появились стрелочные функции, в них убрано ключевое слово function, они состоят:

- параметров
- стрелки
- тело функции

() => {}

```js
const sum = (a, b) => 
{
    return a + b;
}
```

Можно устанавливать параметры по умолчанию:

```js
const sum = (a = 0, b = 0) => 
{
    return a + b;
}
```

Если параметр функции один, то можно убрать скобки:

```js
const square = a => 
{
    return a * a;
}
```

Но, если параметров нет вообще, то пустые скобки нужны:

```js
const square = () => 
{
    return 2 * 2;
}
```

Стрелочной функции нельзя присвоить имя типа sum(), ее можно присвоить переменной.

##### Неявный возврат

Если функция возвращает одно выражение, то можно убрать фигурные скобки и ключевое слово return (неявный возврат):

```js
const square = () => 2 * 2;
```

Вид стрелочной функции с неявным возвратом: `() =>`

##### Стрелочная функция с одним параметром без скобок

Если стрелочная функция имеет один параметр, то можно убрать скобки:

```js
const square = a => a * a;
```

Вид стрелочной функции с параметром без скобок: `=>`

#### Наращиваемые функции

Может использоваться как отдельная фукнция или в составе других функций, наращивая их фукнционал:

```js
function zeroPad(number, width) {
  let string = String(number);
  while (string.length < width) {
    string = "0" + string;
  }
  return string;
}

function printFarmInventory(cows, chickens, pigs) {
  console.log(`${zeroPad(cows, 3)} Cows`);
  console.log(`${zeroPad(chickens, 3)} Chickens`);
  console.log(`${zeroPad(pigs, 3)} Pigs`);
}

printFarmInventory(7, 16, 3);
// Output:
// 007 Cows
// 016 Chickens
// 003 Pigs
```

### Стек вызовов

ОЗУ в JS делится на 3 вида памяти:

- Стековая память (stack memory) - специализированная область памяти, предназначенная для хранения стека вызовов
- Динамическая память (dynamic memory) - область памяти, которая может быть выделена и освобождена динамически во время выполнения программы
- Куча (heap) - область памяти, которая используется для хранения данных, которые не имеют фиксированного размера

Стековая память используется для хранения **стека вызовов**

Когда вызывается функция, она добавляется на вершину стека вызовов, если внутри нее выполняется еще функция, то следующая добавляется выше и т.д.
Когда функция завершает свое выполнение, она удаляется из вершины стека и так до тех пор пока стек не освободится.

Если вызовов функций слишком много, например в случае неправильной рекурсии, то стек будет переполнен и программа завершится с ошибкой: **Maximum call stack size exceeded**

### Области видимости

1. Глобальная область видимости
    - window
    - global
2. Локальная область видимости
    - Область видимости функции
    - Область видимости блока
    - Вложенная область видимости

Глобальные переменные являются свойствами объекта window для браузера или объекта global для Node.js

### Лексический контекст

Лексический контекст или окружение - это область видимости, которая определяется местом объявления переменной. Она имеет следующие правила:

1. Глобальные переменные видны во всех областях видимости
2. Все переменные любых локальных областей видят глобальную область
3. Переменные и объекты в локальной области видят все вложенные в нее области видимости

Каждый раз при вызове любой функции создается структура данных похожих на объект - **лексический контекст. Данная структура содержит все переменные функции и вне ее, к которым она будет обращаться:

```js
const lastName = "Petrov"
// lexical env: { lastName: "Petrov" }
function getFullName(firstName) {
    // lexical env: { lastName: "Petrov", firstName: <будет определено в момент запуска функции> }
    const fullName = firstName + " " + lastName;
    // lexical env: { lastName: "Petrov", firstName: <будет определено в момент запуска функции>, fullName: <будет вычислено в момент запуска функции> }
    return fullName;
}

getFullName("Ivan"); // "Ivan Petrov"
// lexical env в момент вызова стал таким: { lastName: "Petrov", firstName: "Ivan", fullName: "Ivan Petrov" }
```

Когда функция определена но, не выполнена, в ее лексическом контексте нет многих переменных, но есть для них задел (ключи). В момент запуска функции пробелы заполняются значениями.

#### Неправильное использование контекста

```js
const houses = [];

let i = 0;
while (i<10){
    let house = function(){
        console.log(i); // вывод номера дома по порядку
    }
    houses.push(house) 
    i++;
}

houses[0](); // 10 
houses[9](); // 10
```

Видим, что первый дом имеет номер 10 и последний тоже. Это потому-что лексический контекст общий у всех функций в массиве. Контекст содержит общую переменную i, которая к концу цикла выросла до 10. А т.к. вызов функций происходит мосле цикла, то они все видят десятку: `{ i: 10 }`

Для исправления ситуации нужно номер дома (текущее значение i) сохранять внутри блока цикла:

```js
const houses = [];

let i = 0;
while (i<10){
    let houseNumber = i
    let house = function(){
        console.log(houseNumber); // вывод номера дома по порядку
    }
    houses.push(house) 
    i++;
}

console.log(houses[0]()); // 0
```

Или еще глубже, в теле функции.

### Замыкания

Возможность передавать функцию как значение, плюс факт того, что каждый раз при вызове одной и тоже функции внутри области видимости каждого вызова создаются независимые переменные, открывает побочный эффект - **замыкание** (closures):

```js
function makeCounter() {
    let count = 0;
    return () => count++;
}
const counter = makeCounter();
console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2
```

Тут стрелочная функция которая имеет доступ к внешней переменной count называется замыканием.
Легко сравнить замыкание как функцию которая запускается в среде окружения, в которой уже задана некая переменная, причем эта среда активируется именно в том месте из которого запустили замыкание.

Этапы создания замыкания:

- создать функцию
- внутри объявить замкнутые переменные
- вернуть из функции функцию

Замыкания очень полезны:

1. для кеширования или хранилищ данных, защищенных из внешнего кода
2. скрытие переменных в модулях (когда подключено несколько скриптов с одинаковыми именами)
3. создание счетчиков

#### 1. Кеширование

Функция вычисляющая квадрат числа и сохраняющая результат в кэше:

```js
function closureFunction{
    const cache = {};
    return (x) => {
        if (cache[x]) return cache[x];
        const result = x * x;
        cache[x] = result;
        return result;
    }
}

const square = closureFunction();

console.log(square(5)); // 25
console.log(square(5)); // 25
```

#### 2. Модули

```js
(function (){
    const sliderTexts = ['Promo', 'Brands', 'Best'];
    function showSlider(text){
        console.log(text[0]);
        console.log(text[1]);
        console.log(text[2]);
    }
    showSlider(sliderTexts);
}());
```

Данная функция сразу вызывается и исполняется. Переменная sliderTexts - не видна другим и может быть переиспользована.

#### 3. Счетчики

```js
const createCounter = () => {
    let count = 0;
    return () => count++;
}

const counter = createCounter();

console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2
```

#### Недостатки замыканий

Каждый раз при новом вызове любой функции создается лексическое окружение, которе удаляется после выполнения функции. Т.к. часто для замыкания присваивают некой переменной функцию, в результате лексическое окружение остается в памяти, до завершения работы программы или до закрытия браузера, т.к. наличие ссылки (переменной) на функцию препятствует удалению лексического окружения и замкнутых в нем переменных. Поэтому большое количество замыканий приводит к утечке памяти.

### Рекурсия

Функция которая сама себя вызывает называется **рекурсивная функция**

Рекурсию применяют для воспроизведения повторяющихся действий:

1. Для обхода вложенной структуры дерева каталога или документа (DOM)
2. Для математических вычислений, которые поддаются разбиению типа:
   **Сложное вычисление = простая операция, примененная к вычислению попроще**
   $2^{10} = 2^9 \times 2 => b^{e} = b^{e-1} \times b$

```js
function power(base, exponent){
    if (exponent === 0) { // Главное задавать условие выхода иначе будет бесконечная рекурсия
        return 1;
    } else {
        return base * power(base, exponent - 1);
    }
}
console.log(power(2, 3)); // 8
```

Данная реализации вычисления степени числа в три раза медленнее чем вариант с циклом.

### Браузерные события

У HTML-тегов есть атрибут onclick, который выполняет код при нажатии мышью по тегу.

Для того чтобы не писать длинные инструкции в атрибуте onclick, можно использовать функцию-обработчик:

```html
<button onclick="buy()">Buy</button>
<script>
    function buy() { 
        alert('Congratulations! You have bought a good!');
        alert('Good luck!'); 
    }
</script>
```

## 07. Lecture

### Циклы

Цикл - набор инструкций, который выполняется несколько итераций до удовлетворения условий выхода.

Тело цикла - набор инструкций.

Итерация - повторение тела цикла.

Условие выхода из цикла - условие, при котором цикл завершается.

#### Цикл while

Цикл с предусловием:

```js
let i = 0;
while (i < 10) {
    console.log(i);
    i++;
}
```

Очень удобен для бесконечных циклов.

#### Цикл do-while

Цикл с постусловием:

```js
let i = 0;
do {
    console.log(i);
    i++;
} while (i < 10);
```

Тело цикла проверяется на условие после выполнения. Следовательно минимум один раз цикл выполнится. Полезно например при вводе пароля, а потом его проверки до тех пор пока не введут верный.

#### Цикл for

Цикл с инициализацией, условием и инкрементом:

```js
for (let i = 0; i < 10; i++) {
    console.log(i);
}
```

Самый популярный цикл.

#### Прерывание цикла

Выход из цикла происходит:

- если условие выхода из цикла возвращает **false**
- если встречается инструкция **break**

Выход из итерации цикла, но не выход из цикла:

- при достижении конца тела цикла, если условие выхода из цикла возвращает **true**
- если встречается инструкция **continue**

### Массивы

Массив - упорядоченная коллекция элементов одного и того же типа, но в JS типы данных элементов могут быть разными:

```js
let arr = [1, "string", true, null, undefined, { name: 'John' }, [1, 2, 3]];
console.log(arr); // [1, "string", true, null, undefined, { name: 'John' }, [1, 2, 3]]
```

Массив также можно создать с помощью конструктора Array:

```js
let arr = new Array(1, 2, 3, 4, 5);
console.log(arr); // [1, 2, 3, 4, 5]
```

Максимальная длина массива:

- $2^{30}=$ 1_073_741_823 элементов в браузерах 
- $2^{31}=$ 2_147_483_647 элементов в Node.js
- $2^{32}=$ 4_294_967_295 элементов в спецификации ES6+

Имя массива (переменная) - это указатель на область памяти объекта. Т.к. массив это наследник объекта:

```js
typeof [] // object
```

Чтобы случайно не переименовать или удалить имя массива делают константным, элементы массива все еще могут быть изменены:

```js
const arr = [1, 2, 3];
arr[0] = 10;
console.log(arr); // [10, 2, 3]
```

Элементы массива хранятся как значения свойств объекта. А индексы как ключи свойств объекта.
К свойствам любого объекта можно обращаться через точечную нотацию или квадратные скобки. Но, обращаться используя точечную нотацию можно только свойствам (переменным), которые начинаются с буквы или символа подчеркивания и не имеют пробелов, т.е. в имена переменных не могут быть только цифрами, иначе нужно обращаться через квадратные скобки:

```js
value[2] // нельзя value.2
value["John Doe"] // нельзя value.John Doe
```

Поэтому для доступа к элементам массива, как наследнику объекта, нельзя обращаться через точечную нотацию - индексы нужно обрамлять квадратными скобками.

Обратиться к последнему элементу массива, можно так:

```js
const arr = [1, 2, 3];
arr[arr.length - 1] // 3
```

#### Свойства массивов

##### length

Как и строки, массив имеет свойство **length** - количество элементов в массиве.

К свойствам массива можно обращаться через скобочную нотацию:

```js
arr.['length']
```

У массивов помимо встроенных свойств есть методы - это свойства, которые содержат функции.

#### Методы массивов

В зависимости от воздействия на массива методы могут быть:

1. Мутаторы (Mutators) - изменяют массив
2. Аксессоры (Accessors) - возвращают значения
3. Итераторы (Iterators) - могут работать только с итерируемы объектами (массивами, строками, Map, Set)

##### Мутаторы

#### fill

Метод заполняет массив указанным значением:

```js
const arr = [1, 2, 3];
arr.fill("a");
console.log(arr); // ["a", "a", "a"]
```

Если в методе fill не указано значение, то вместо него по умолчанию будет использоваться undefined.

```js
const arr = [1, 2, 3];
arr.fill();
console.log(arr); // [ undefined, undefined, undefined ]
```

Метод имеет второй и третий аргумент, которые определяют с какого и по какой индекс заполнять массив:

```js
const arr = [1, 2, 3];
arr.fill("a", 1, 2);
console.log(arr); // [1, "a", 3]
```

###### reverse

Метод переворачивает массив:

```js
const arr = [1, 2, 3];
arr.reverse();
console.log(arr); // [3, 2, 1]
```

###### push

Добавление одного или нескольких элементов в конец исходного массива (похож unshift):

```js
const arr = [1, 2, 3];
arr.push(4, 5);
console.log(arr); // [1, 2, 3, 4, 5]
```

###### unshift

Добавляет один или несколько элементов в начало исходного массива (похож push):

```js
const arr = [1, 2, 3];
arr.unshift(4, 5);
console.log(arr); // [4, 5, 1, 2, 3]
```

###### pop

Извлекает и удаляет последний элемент исходного массива (похож на shift):

```js
сonst arr = [1, 2, 3];
console.log(arr.pop()); // 3
console.log(arr); // [1, 2]
```

###### shift

Удаляет первый элемент исходного массива, сдвигая все остальные элементы влево (похож на pop):

```js
const arr = [1, 2, 3];
arr.shift();
console.log(arr); // [2, 3]
```

###### sort

Метод сортирует массив:

```js
const arr = [3, 2, 1];
arr.sort();
console.log(arr); // [1, 2, 3]
```

Может быть также итератором:

```js
const arr = [3, 2, 1];
arr.sort((a, b) => a - b);
console.log(arr); // [1, 2, 3]
```

###### splice

Удаляет элементы в текущем массиве:

```js
const arr = [1, 2, 3, 4, 5];
arr.splice(2, 1); // указываем индекс с которого начать удаление, количество символов для удаления
console.log(arr); // [1, 2, 4, 5]
```

Если метод splice вызывается без аргументов, то он может использоваться для полного клонирования массива:

```js
const arr = [1, 2, 3];
const arr2 = arr.splice();
console.log(arr2); // [1, 2, 3]
```

Также для клонирования, т.е. создания полной копии массива может использоваться метод высшего порядка map:

```js
const arr = [1, 2, 3];
const arr2 = arr.map(item => item);
console.log(arr2); // [1, 2, 3]
```

##### Аксессоры

###### slice

Slice (отрезать) в отличие от splice (латать) является персистентным, он копирует часть или весь массив:

```js
const arr = [1, 2, 3, 4];

const all = arr.slice();
console.log(all); // [1, 2, 3, 4]

const start = arr.slice(1);
console.log(start); // [2, 3, 4]

const overload = arr.slice(14);
console.log(overload); // []

const minus = arr.slice(-2);
console.log(minus); // [3, 4]

const range = arr.slice(1, 3);
console.log(range); // [2, 3]

const startMinus = arr.slice(1, -1);
console.log(startMinus); // [2, 3]
```

###### concat

Персистентная конкатенация массивов:

```js
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const arr3 = arr1.concat(arr2);
console.log(arr3); // [1, 2, 3, 4, 5, 6]
```

Вторым и далее аргументами concat() можно передать любой примитив или объект и они будут добавлена справа от первого массива:

```js
const arr3 = arr1.concat(arr2, {key: 1}, "string", [10, 11, 12]); 
console.log(arr3); // [ 1, 2, 3, 4, 5, 6, { key: 1 }, 'string', 10, 11, 12 ]
```

concat() похож на push(), но не изменяет первоначальный массив, а создает новый

###### concat + slice

Можно создать функцию remove, которая удаляет нужный элемент массива по индексу:

```js
function remove(array, index) {
  return array.slice(0, index)
    .concat(array.slice(index + 1));
}
console.log(remove(["a", "b", "c", "d", "e"], 2));
// → ["a", "b", "d", "e"]
```

Похожего эффекта можно добится с помощью метода splice(2, 1)

###### indexOf

Метод возвращает индекс первого искомого вхождения (самого левого) элемента в массиве:

```js
const arr = [1, 2, 3];
console.log(arr.indexOf(2)); // 1
console.log(arr.indexOf(5)); // -1
```

Если элемент не находится в массиве, то возвращается -1.

В методе можно указать второй параметр, который определяет с какого индекса начать поиск:

```js
const arr = [1, 2, 3];
console.log(arr.indexOf(2, 1)); // 1
```

###### lastIndexOf

Метод возвращает индекс последнего искомого вхождения (самого правого) элемента в массиве:

```js
const arr = [1, 2, 3, 2];
console.log(arr.lastIndexOf(2)); // 3
console.log[arr.lastIndexOf(5)]; // -1
```

Метод, как и indexOf имеет второй необязательный параметра, место к которого начать поиск.

###### includes

Метод возвращает true если в массиве есть искомый элемент:

```js
const arr = [1, 2, 3];
console.log(arr.includes(2)); // true
```

###### join

Метод объединяет элементы массива в строку:

```js
console.log(['H', 'e', 'l', 'l', 'o'].join(" ")); // H e l l o  
```

Если сепаратор (разделитель) не указан в аргументе метода, то по умолчанию он равен пробелу.

#### Массивы с циклами

Цикл очень часть используется при работе с массивами:

##### for

```js
const arr = [1, 2, 3];

for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}
```

##### for of

Цикл для массива можно записать короче:

```js
for (let item of arr) {
   console.log(item); 
}
```

Цикл был разработан для решения проблемы **сурогатных пар** (см. строки), позволяет итерироваться по знакам занимающим две символьные единицы:

```js
let roseDragon = "🌹🐉";
for (let char of roseDragon) {
  console.log(char);
}
// → 🌹
// → 🐉
```

##### forEach

```js
arr.forEach(item => console.log(item));
```

### Строки

Строки - это примитивы. Поэтому, при работе с ними происходит приведение типов.

При обращении к методам строки, происходит оборачивание строки в объект.

#### Unicode

Содержит коды символов для  140 письменностей (81 живая, 59 нет) https://en.wikipedia.org/wiki/Script_(Unicode))

Кодовая единица (code unit) для одного символа в строке составляет 2 байта и он закодирован в UTF-16.
Некоторые символы (emoji или иероглифы) выходящие за 16-битный диапазон хранятся как два символа и называются **суррогатными парами**

```js
console.log(characterScript(121));

const emoji = "😊";

console.log(emoji.length); // ❗ 2, а не 1
console.log(emoji.charCodeAt(0)); // d83d (старший суррогат)
console.log(emoji.charCodeAt(1)); // de0a (младший суррогат)
console.log(emoji.codePointAt(0)); // полноценный суррогат
console.log(emoji[0]);  // � (неправильный символ)
```

Из-за суррогатных пар практически невозможно провильно итерироваться по строке используя классический цикл for. Когда была обнаружена проблема суррогатных пар появился цикл for/of

#### for/of

Пример корректной итерации по двум-юнитовым символам, т.е. по символам состоящим из суррогатных пар:

```js
let roseDragon = "🌹🐉";
for (let char of roseDragon) {
  console.log(char);
}
// → 🌹
// → 🐉
```
```

#### Строковые методы

При попытке добавить новый метод, ничего не получится в отличие от объекта.

```js
let kim = "Kim";
kim.age = 88
console.log(kim); // undefined
```

Но, встроенных методов предостаточно.

#### charCodeAt

Выводит в примере выше только кодовую единицу, т.е. старший суррогат

#### codePointAt

Возвращает полноценный Unicode код символа. Метод был разработан когда встала проблема **суррогатных пар**

#### slice()

```js
let str = 'Hello';
console.log(str.slice(1, 3)); // el
```

#### substr

```js
let str = 'Hello';
console.log(str.substr(1, 3)); // ell
```

#### substring

```js
let str = 'Hello';
console.log(str.substring(1, 3)); // el
```

#### replace

```js
let str = 'Hello';
console.log(str.replace('l', 'L')); // HelLo
```

#### split

Создает массив из строки по указанному разделителю:

```js
let str = 'Hello';
console.log(str.split('')); // ['H', 'e', 'l', 'l', 'o']
```

#### charAt

```js
let str = 'Hello';
console.log(str.charAt(1)); // e
```

#### indexOf()

```js
let str = 'Hello';
console.log(str.indexOf('ll')); // 2
```

В отличие от одноименного метода массива, для строки можно указывать несколько символов для поиска

#### length()

```js
let str = 'Hello';
console.log(str.length); // 5
```

#### toUpperCase()

```js
let str = 'Hello';
console.log(str.toUpperCase()); // HELLO
```

#### toLowerCase

```js
let str = 'Hello';
console.log(str.toLowerCase()); // hello
```

#### trim

Удаляет крайние пробелы, переносы строк, табуляцию и однотипные символы:

```js
let str = '   Hello   ';
console.log(str.trim()); // Hello
```

#### padStart

Дополняет строку до указанного количества символов в строке:

```js
let str = 'Hello';
console.log(str.padStart(10, '0')); // 00000Hello
```

#### repeat

Повторяет строку указанное в параметре метода количество раз:

```js
let str = 'Hello';
console.log(str.repeat(3)); // HelloHelloHello
```

#### Функции для строк

##### parseInt

Парсит целые числа как в десятичной системе, так и в шестнадцатеричной представленных в виде строк:

```js
let str = '123';
console.log(parseInt(str)); // 123
// если строка начинается с 0x
let str = '0x7b';
console.log(parseInt(str)); // 123
```

Можно парсить в других системах счисления от 2 до 36, указав систему в качестве второго параметра:

```js
let str = '0x7b';
console.log(parseInt(str, 16)); // 123
```

##### parseFloat

Может парсить как целое так и дробное число представленное в виде строки

```js
let str = '123.456';
console.log(parseFloat(str)); // 123.456
```

## 09. Lecture

### Объекты

Объекты это абстрактные структуры данных (Выразительный JS. Глава 6), которые обладают набором интерфейсов (методов.) Это справедливо как для встроенных типов данных Массивы, Функции, так и для пользовательских объектов. 

Правила создания объектов:

1. Объекты рекомендуют объявлять с помощью ключевого слова **const**.
2. Определение (тело) объекта заключается в фигурных скобках. Фигурные скобки обрамляют также начало и конец блока инструкций, например функции. Встречаются случаи когда надо явно отличить функцию от объекта:
   `n => { prop: value } // treated as function`
   `n => ({ prop: value }) // treated as object`
3. Имя (ключ) свойства отделяется от значения свойства двоеточием.
4. Имя свойства может быть любым
5. Объект не может содержать дублирующиеся имена свойств.
6. Все свойства объекта объявляются через запятую.

Пустой объект можно создать двумя способами:

- С помощью конструктора Object: `const obj = new Object();`
- С помощью литеральной нотации (литерал объекта): `const obj = {};`

Объекты имеют свойства (характеристики) и методы (действия).

```js
const user = {
    name: 'John',
    age: 30
    move: function() {
        console.log('move');
    }
};
```

#### Свойства объектов

Почти все типы данных в JS имеют свойства , за исключением null и undefined. Если обратиться к их свойствам, то получим ошибку:

```js
null.length; // TypeError: Cannot read properties of null (reading 'length')
null["length"]; // TypeError: Cannot read properties of null (reading 'length')
```

Имена свойств объектов это строки. К свойствам можно обратиться двумя способами:

- с помощью точечной нотации
- с помощью квадратных скобок
- смешанным способом

##### Точечная нотация

Обращение к свойству объекта через точечную нотацию:

```js
const user = {
    name: 'John',
    age: 30
};

console.log(user.name); // John
console.log(user.age); // 30
```

С помощью точечной нотации нельзя обратиться к свойствам, которое целиком состоят из цифр или имеют пробелы в именовании:

```js
const arr = [1, 2, 3]
for(let i=0; i < arr.length; i++) console.log(arr[i]); // вычисляемое имя поля i
```

Поэтому следует использовать квадратные скобки.

##### Квадратные скобки

В точечной нотации свойство это строка, а в скобках это может быть вычисляемое выражение:

```js
const user = {
    name: 'John',
    age: 30
};

const key = 'age';
console.log(user[key]); // 30
console.log(user.key); // undefined
```

##### Смешанная нотация

При обращении к свойствам вложенных объектов допускается использование квадратных скобок, точечной или смешанной нотации:

```js
const user = {
    name: 'John',
    age: 30,
    address: {
        city: 'New York',
        country: 'USA'
    }
};

console.log(user.address.country); // USA
console.log(user.address['country']); // USA
console.log(user['address'][country]); // USA
```

##### Добавление свойств

В любой момент можно добавить новое свойство:

```js
const user = {
    name: 'John',
    age: 30
};

user.isAdmin = true;
console.log(user); // {name: "John", age: 30, isAdmin: true}
```

Рекомендуется имена свойств (характеристики) объектов всегда заключать в кавычки, особенно:

- содержат пробелы
- состоят только из цифр
- содержат спецсимволы

Более того, это походит на JSON:

```js
const obj = {
  'hello world': 'value',
  '123': 'another value',
  '!@#$': 'yet another value'
};
```

Чтобы заменить значение свойства объекта используют знак равно =:

```js
const user = {
    name: 'John',
    age: 30
};

user.age = 40;
user.lastname = 'Smith';

console.log(user); // {name: "John", age: 40, lastname: "Smith"}
```

Если при присваивании значения свойству через знак равно такого нет, то оно создастся автоматом.

При обращении к несуществующему свойству возвращает **undefined**:

```js
console.log(user.age); // undefined
```

Но, есть разница между удалением свойства и присвоением ему **undefined**:

```js
user.age = undefined;
console.log(user.age); // undefined
```

##### delete

Для удаления свойства объекта применяется оператор **delete**:

```js
const user = {
    name: 'John',
    age: 30
};

delete user.age; // true
console.log(user); // {name: "John"}
```

При успешном удалении свойства возвращается true, иначе false (например защищенный объект браузера).

##### оператор in

Используется для поиска свойства в объекте, возвращая true или false:

```js
console.log("right" in {left: 1, right: 2});
// → true
console.log("center" in {left: 1, right: 2});
// → false
```

##### Особенности объектов

При сравнении объектов == сравниваются их указатели и проверяется их идентичность, но не содержание.

При указании переменных в качестве аргументов функции передаются только их значения, исходные переменные остаются нетронутыми. При указании имени объекта в качестве аргумента функции передает указатель на этот объект. Поэтому при изменении объекта внутри функции, изменится исходный объект.

##### Короткое присваивание свойств объекта

Если при создании объекта передаются переменные в качестве свойств и без значений, то значения берутся из переменных, а ключами свойств становятся имена переменных.

```js
let event = "hello";
let squirrel = "World";
const obj = {event, squirrel}; // same as - const obj = {event: "hello", squirrel: "World"}
console.log(obj); // { event: 'hello', squirrel: 'World' }
```

##### Опциональное обращение к свойству объекта

Если нет уверенности, что обращение к свойству объекта существует, то можно использовать **?.**  (оператор опциональной цепочки):

```js
const user = {
    name: 'John',
    age: 30
};

console.log(user?.name); // John
console.log(user?.lastName); // undefined
```

Можно использовать как точечную нотацию, так и квадратные скобки:

```js
const user = {
    name: 'John',
    age: 30
};

console.log(user?.['name']); // John
console.log(user?.['lastName']); // undefined
```

Данный механизм позволяет избежать выброса исключения при обращении к несуществующему свойству.

#### Методы объекта

Методы объекта это свойства которым присвоены функции:

```js
function speak(line){
    console.log(`The ${this.type} rabbit says: ${line}`);
}

let whitRabbit = {type: "white", speak};
let hungryRabbit = {type: "hungry", speak};

whiteRabbit.speak("oh my fur and whiskers")
// The white rabbit says: oh my fur and whiskers
hungryRabbit.speak("got any carrots?");
// The hungry rabbit says: got any carrots?
```

Для наглядности вызова метода, можно использовать встроенный в функции метод call:

```js
speak.call(whiteRabbit, "Hurry");
// → The white rabbit says 'Hurry'
```

В объекте принято методы объявлять после свойств:

```js
// Объект робот-пылесос
const Roomba = { // Есть негласное правило называть объекты в алгоритмах с большой буквы.
    // Обычно сначала объявляют свойства объекта.
    model: "Romba-1",
    power: 200,
    batterySize: 2100,
    boxSize: 0.5,
    workTime: 45,
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    isUVLampOn: false,
    // После свойств объявляют его методы.
    startCleaning: function () { // увеличивает счетчик стартов робота и выводит сообщение о старте
        this.counterOfStarts++;
        console.log('I am cleaning... I have been started: ', this.counterOfStarts, 'times.');
    },
    goCharge: function () { // отправка на зарядку
        console.log('I am going to charge...');
    },
    switchUVLamp: function () { // вкл.выкл ультрафиолетовой лампы
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    }
};

// Обращение к свойствам объекта.
console.log(Roomba.model); // "Romba-1"
console.log(Roomba.isFull); // false
// Вызов методов объекта.
Roomba.startCleaning(); // 'I am cleaning... I have been started: 1 times.'
// Установим свойства объекта isUVLampOn в true, чтобы продемонстрировать результат работы метода switchUVLamp.
Roomba.switchUVLamp(); // 'UV lamp is working.'
Roomba.goCharge(); // 'I am going to charge...'
```

Объявление методов в объекте можно делать разным синтаксисом:

- с ключевым словом function
- без ключевого слова function
- с использованием стрелочной функции

Каждый синтаксис имеет разные области видимости и наследование.

Методы могут обращаться к свойствам объекта с помощью ключевого слова **this**

#### this

Ключевое слово this ссылается на текущий объект, оно также доступно в любой функции:

```js
// Работа с this
const checkThis = function() {
    console.log(this);
}
checkThis(); // Window {0: global, window: Window, self: Window, document: document, name: "", location: Location, ...}
```

Из лексического контекста данной функции видно, что this (текущий объект) ссылается на глобальный объект window, в случае браузера или global в node.js

Внутри методов объекта this указывает на сам объект, в котором он был объявлен:

```js
const checkThisInObject = {
    testProperty: true,
    checkThis: function () {
        console.log(this);
    },
};
checkThisInObject.checkThis(); // {testProperty: true, checkThis: ƒ}
```

Контекст не указывает никаких глобальных объектов, следовательно this - это сам объект, но есть нюансы, т.к. this в JS отличается от других языков программирования. Например, стрелочные функции не имеют контекста, поэтому в них this будет ссылаться на глобальный объект по отношению к ним.

#### Одалживание методов

Создадим улучшенного робота-пылесоса, на основе первого:

```js
// Объект робот-пылесос модель Tango.
const Tango = { 
    model: "Tango-1",
    power: 300,
    batterySize: 3200,
    boxSize: 0.7,
    workTime: 60,
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    isUVLampOn: false,
    // После свойств объявляют его методы. А так как методы у новой модели такие же как и у старой, давайте позаимствуем их у объекта Roomba.
    startCleaning: Roomba.startCleaning,
    goCharge: Roomba.goCharge,
    switchUVLamp: Roomba.switchUVLamp,
};

console.log(Tango.model); // "Tango-1"
console.log(Tango.isFull); // false
// Вызов методов объекта.
Tango.startCleaning(); // 'I am cleaning... I have been started: 1 times.'
// Результат вызова следующего метода зависит от значения, хранящегося в свойстве объекта, а также от того как этот метод был вызван (об этом поговорим чуть ниже).
Tango.switchUVLamp(); // 'UV lamp working.'
Tango.goCharge(); // 'I am going to charge...'
```

Создадим третьего робота, но объекты экспортируем с помощью внешних способов:

```js
const Samba = {
    model: "Samba-1",
    power: 250,
    batterySize: 2500,
    boxSize: 0.5,
    workTime: 50,
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    isUVLampOn: false,
    // На этот раз мы не будем создавать методы в объекте, мы постараемся их заимствовать непосредственно перед использованием.
};

// Одолжим методы из объекта Roomba.
Samba.startCleaning = Roomba.startCleaning;
Samba.switchUVLamp = Roomba.switchUVLamp;
Samba.goCharge = Roomba.goCharge;
Samba.startCleaning(); // 'I am cleaning... I have been started: 1 times.'
// Результат вызова следующего метода зависит от значения, хранящегося в свойстве объекта, а также от того как этот метод был вызван (об этом поговорим чуть ниже).
Samba.switchUVLamp(); // 'UV lamp is working.'
Samba.goCharge(); // 'I am going to charge...'
```

Лампа работает по принципу одной кнопки (вкл/выкл). Сейчас лампа включена
Предположим мы хотим включить лампу по расписанию через пять секунд:

```js
setTimeout(Samba.switchUVLamp, 5000); // 'UV lamp is working.'
```

Но, лампа не выключается. Потому что через 5 секунд объекта Samba уже нет и внутренняя this ссылается несуществующий объект, т.е. undefined.

Можно обернуть метод в анонимную функцию, тогда ссылка на Samba сохраниться в лексическом контексте функции и объект не будет удален:

```js
setTimeout(function() {
    Samba.switchUVLamp();
}, 5000); // 'UV lamp in not working.'
```

Можно вместо анонимной функции использовать методы call, apply или bind

#### Встроенные методы объектов

##### call

Метод call позволяет вызвать метод в контексте другого объекта, на примере объекта Roomba:

```js
const notARobot = {
    counterOfStarts: 10,
}

Roomba.startCleaning.call(Roomba); // 'I am cleaning... I have been started: 1 times.'
Roomba.startCleaning.call(notARobot); // 'I am cleaning... I have been started: 10 times.'
```

В последнем вызове метода мы передали с помощью call контекст другого объекта и он выполнился со своим свойством counterOfStarts равным 10. Если в качестве второго и последующих аргументов call что-то передать, то данные параметры пойдут в вызываемый метод

##### apply

Аналогичен методу call, только второй параметр передается в виде массива:

```js
Roomba.startCleaning.apply(Roomba, [1, 2, 3]); // 'I am cleaning... I have been started: 10 times.'
```

##### bind

Позволяет привязать контекст к фукнции (методу) навсегда:

```js
Samba.startCleaning = Roomba.startCleaning.bind(Samba);
```

Методы можно добавить в объект, путем присвоения функции как значения свойства с ключевым словом function:

```js
const user = {
    make: 'Audi',
    model: "A6",
    year: 2008,
    startEngine: function() {
        console.log('Engine is started');
    }
};

user.startEngine(); // Engine is started
```

Если использовать стрелочную функции внутри объекта, то они не будут видеть объекта, т.к. стрелочные функции не имеют собственного контекста поэтому берется объект на уровень выше, т.е. global. Тут не помогут даже call, apply и bind.

Но, стрелочные функции очень полезны как анонимные внутри самого метода объекта:

```js
const Stand = {
    model: "Stand-1",
    robots: ['Roomba-1', 'Tango-1', 'Samba-1', 'Roomba-2'],
    // Метод, с использованием стрелочной функции в качестве функции обратного вызова.
    startTestingArrow: function() {
        console.log('Start testing...');
        this.robots.forEach((value) => {
            console.log('stand: ', this.model, 'is testing robot: ', value);
        })
    },
    // Метод, с использованием классической функции в качестве функции обратного вызова.
    startTestingClassic: function() {
        console.log('Start testing...');
        this.robots.forEach(function(value) {
            console.log('stand: ', this.model, 'is testing robot: ', value);
        })
    },
};
Stand.startTestingArrow();
// Start testing...
// stand: Stand-1 is testing robot: Roomba-1
// stand: Stand-1 is testing robot: Tango-1
// stand: Stand-1 is testing robot: Samba-1
// stand: Stand-1 is testing robot: Roomba-2
Stand.startTestingClassic();
// Start testing...
// stand: undefined is testing robot: Roomba-1
// stand: undefined is testing robot: Tango-1
// stand: undefined is testing robot: Samba-1
// stand: undefined is testing robot: Roomba-2
```

Получили двойную вложенность в двух методах: startTestingArrow() и startTestingClassic(). Первый метод со стрелочной функцией внутри отработал, т.к. стрелочная функция не имея собственного this ссылается через уровень к свойству model и отрабатывает хорошо. Вот второй метод не отрабатывает как надо, потому что внутри классического метода, классическая функция видит свой контекст и this в нем не видит свойства model в результате возвращается undefined.

#### Object.freeze

Делает объект неизменным (immutable). После применения этого метода к объекту невозможно:

- Добавить новые свойства
- Удалить существующие свойства
- Изменить значения уже имеющихся свойств

```js
const user = { name: "Иван", age: 30 };

Object.freeze(user);
user.age = 31; // Не изменится
user.email = "test@example.com"; // Не добавится
delete user.name; // Не удалится
console.log(user); // { name: "Иван", age: 30 }
```

Не применяется к вложенным объектам.

#### Клонирование объектов

##### С помощью for in

Цикл for in используется для перебора свойств объекта:

```js
const user = {
    name: 'John',
    age: 30
};

for (let key in user) {
    console.log(key); // name, age - вывод всех ключей свойств объекта
    console.log(user[key]); // John, 30 - вывод всех значений свойств объекта
}
```

Цикл for in часто используют для клонирования объекта:

```js
const user = {
    name: 'John',
    age: 30
};

const clonedUser = {};
for (let key in user) {
    clonedUser[key] = user[key];
}
console.log(clonedUser); // { name: 'John', age: 30 }
```

Для клонирования объекта удобнее использовать метод **Object.assign**

##### Object.assign

Для полного клонирования объекта:

```js
const user = {
    name: 'John',
    age: 30
};

const clone = Object.assign({}, user); // {name: "John", age: 30}
```

Или для частичного копирования свойств одного объекта в другой:

```js
const user = {
    name: 'John',
    age: 30
};

const phoneBook = Object.assign(user, {mobile: "+7916777777"}); // {name: "John", age: 30, mobile: "+7916777777"}
```

##### C помощью spread

Клонировать объект можно циклом for/in, методом Object.assign или с помощью оператора spread:

```js
const user = {
    name: 'John',
    age: 30
};

const clonedUser = {...user, city: "New York"}; // {name: "John", age: 30, city: "New York"}
```

После spread можно указывать дополнительные свойство которые добавятся в клонированный объект

#### Объект в массив

У массивов для преобразование его элементов и помещения результатов в новый массив можно использовать метод **map**. Но, у объектов такого метода нет, поэтому для преобразования объекта в массив необходимо использовать методы **Object.values** и **Object.keys**.

##### Object.keys

Для сохранения в массив ключей объекта используется метод **Object.keys**:

```js
const user = {
    name: 'John',
    age: 30
};

const array = Object.keys(user); // ["name", "age"]
```

##### Object.values

Для сохранения в массив значений объекта используется метод **Object.values**:

```js
const user = {
    name: 'John',
    age: 30
};

const array = Object.values(user)); // ["John", 30]
```

##### Object.entries

Для сохранения в массив пар ключ-значение используется метод **Object.entries**:

```js
const user = {
    name: 'John',
    age: 30
};

const array = Object.entries(user); // [["name", "John"], ["age", 30]]
```

Можно было бы использовать для итерации for in по объекту без конвертации в массив, но в итерацию могут попасть наследуемые свойства объектов, включая прототип, при их наличии.

```js
const user = {
    name: 'John',
    age: 30
};

for (let key in user) {
    console.log(key); // name, age, toString, constructor
    console.log(user[key]); // John, 30, [object Object], [object Object]
}
```

Поэтому лучше преобразовывать в массив с помощью Object.keys, Object.values или Object.entries и далее работать с данными внутри массива.

#### Math

Объект Math объединяет в себя математические методы, для того чтобы не плодить глобальные функции, дабы не засорять глобальное пространство имен. Иначе, велика вероятность что функции, либо переменные создаваемые пользователем могут случайно совпасть с библиотечными.

##### Математические константы

Такие как $\pi$, $e$ и другие, доступны в объекте Math. и записываются прописными буквами:

```js
console.log(Math.PI); // 3.141592653589793
console.log(Math.E); // 2.718281828459045
```

##### Math.random

Возвращает псевдослучайное число от 0 включительно до 1 не включительно:

```js
console.log(Math.random()); // 0.123456789
```

Если необходимо сгенерировать случайное целое число, то в купе с текущей функцией используют округление

##### Math.floor

Округляет до наименьшего целого числа, которое меньше или равно указанному числу:

```js
console.log(Math.floor(2.9)); // 2
```

##### Math.ceil

Округляет до наибольшего целого числа, которое больше или равно указанному числу:

```js
console.log(Math.ceil(2.1)); // 3
```

##### Math.round

Округляет до ближайшего целого числа по правилам математики:

```js
console.log(Math.round(2.4)); // 2
console.log(Math.round(2.6)); // 3
```

##### Math.abs

Возвращает модуль числа:

```js
console.log(Math.abs(-5)); // 5
console.log(Math.abs(5)); // 5
```

##### Math.pow

Возведение в степень:

```js
console.log(Math.pow(2, 3)); // 8
```

##### Math.sqrt

Возвращает квадратный корень числа:

```js
console.log(Math.sqrt(9)); // 3
```

##### Math.cbrt

Возвращает кубический корень числа:

```js
console.log(Math.cbrt(27)); // 3
```

##### Math.min и Math.max

Возвращает минимальное и максимальное значения:

```js
console.log(Math.min(1, 2, 3)); // 1
console.log(Math.max(1, 2, 3)); // 3
```

##### Math.trunc

Возвращает целую часть числа:

```js
console.log(Math.trunc(2.9)); // 2
```

##### Math.sign

Возвращает знак числа:

```js
console.log(Math.sign(-5)); // -1
console.log(Math.sign(0)); // 0
console.log(Math.sign(5)); // 1
```

##### Math.clz32

Возвращает количество знаков в двоичном представлении числа:

```js
console.log(Math.clz32(0b1001)); // 3
console.log(Math.clz32(0b1010)); // 2
```

##### Math.imul

Возвращает произведение двух целых чисел:

```js
console.log(Math.imul(2, 3)); // 6
```

##### Math.fround

Возвращает число с плавающей точкой в одинарной точности:

```js
console.log(Math.fround(2.9)); // 2.9000000953674316
```

##### Math.hypot

Возвращает гипотенузу треугольника:

```js
console.log(Math.hypot(3, 4)); // 5
```

##### Math.cosh

Возвращает гиперболический косинус числа:

```js
console.log(Math.cosh(1)); // 1.5430806348152437
```

##### Math.sinh

Возвращает гиперболический синус числа:

```js
console.log(Math.sinh(1)); // 1.1752011936438014
```

##### Math.tanh

Возвращает гиперболический тангенс числа:

```js
console.log(Math.tanh(1)); // 0.7615941559557649
```

##### Math.asinh

Возвращает аркгиперболический синус числа:

```js
console.log(Math.asinh(1)); // 0.881373587019543
```

##### Math.acosh

Возвращает аркгиперболический косинус числа:

```js
console.log(Math.acosh(1)); // 0
```

##### Math.atanh

Возвращает аркгиперболический тангенс числа:

```js
console.log(Math.atanh(1)); // 0.5493061443340549
```

##### Math.sin

Возвращает синус числа:

```js
console.log(Math.sin(1)); // 0.8414709848078965
```

##### Math.cos

Возвращает косинус числа:

```js
console.log(Math.cos(1)); // 0.5403023058681398
```

##### Math.tan

Возвращает тангенс числа:

```js
console.log(Math.tan(1)); // 1.5574077246545013
```

##### Math.asin

Возвращает арксинус числа:

```js
console.log(Math.asin(1)); // 1.5707963267948966
```

##### Math.acos

Возвращает арккосинус числа:

```js
console.log(Math.acos(1)); // 0
```

##### Math.atan

Возвращает арктангенс числа:

```js
console.log(Math.atan(1)); // 0.7853981633974483
```

### Глобальные объекты

В среде JS всегда есть один глобальный объект, от которого происходят остальные объекты.

Имя такого первичного объекта всегда зависит от среды исполнения JS:

- **window** в браузере
- **global** в Node.js
- **WorkerGlobalScope** в веб-воркере

Эти объекты не являются частью языка, они являются частью движка на котором ведется работа. Глобальный объект нужен для взаимодействия со средой в которой исполняется код.

Все методы и свойства глобального объекта доступны везде без указания window или global:

```js
console.log(this); // window
window.console.log(window); // window
console.log(global); // global
console.log(this === window); // true
console.log(this === global); // true
```

### Функции высшего порядка

ПО можно конструировать двумя способами, где:

1. Код простой и очевидно без дефектов
2. Код сложный и без очевидных дефектов

$\copyright$ Theories of Programming: The Life and Works of Tony Hoare

#### 1. Простой код

```js
function range{
    pass
}

function sum{
    pass
}

console.log(sum(range(1,10)));
```

Посчитать сумму о одно до десяти.

#### 2. Сложный код

```js
let total = 0;
let count = 1
while(count <= 10){
    total += count;
    count += 1;
}

console.log(total)
```

#### Абстракция

В пример 1.Простой код использованы словарь функций (sum, range) Словарь функций представляет собою набор функций которые выполняют определенную задачу.

Проблема в том, что невозможно создать словарь (функции), на все случаи жизни. Но, можно использовать абстрактный подход - **функции высшего порядка**:

Можно написать конкретный цикл для повторения конкретного действия, например для вывода элементов в консоль:

```js
for (let i=0; i<10; i++) console.log(i);
```

Если нужно данное действие выполнять желаемое количество раз (n), можно поместить цикл в функцию:

```js
function repeat(n){
    for (let i=0; i<n; i++) console.log(i);
}
```

Но, что если нужен не вывод в консоль, а другое действие? Тогда можно передавать функцию в качестве аргумента в повторяющую функцию:

```js
function repeat(n, action){
    for (let i=0; i<n; i++) action(i);
}

repeat(10, console.log);
```

Можно не передавать заранее описанную функцию в качестве параметра, можно в ее тело передать в качестве аргумента значения:

```js
let labels = [];
repeat(10, i => labels.push(i+1));

console.log(labels);
```

В примере выше, опущены фигурные скобки, т.к. тело функции короткое и однострочное.

#### Типы функций высшего порядка

Функции высшего порядка бывают двух типов:

1. Функции возвращающие другие функции (замыкания)
2. Функции принимающие другие в функции в качестве своих аргументов. Функция аргумент называют callback функцией.
   2.1. Функции меняющие другие функции
   2.2. Функции изменяющие поток выполнения

##### 1. Функции возвращающие другие функции

```js
function greaterThan(n){
    return m => m > n;
}

let greaterThan10 = greaterThan(10);
console.log(greaterThan10(11)); // true
```

##### 2 Функции меняющие другие функции

```js
function calc(x, action, y){
  return action(x, y);
}

function minus(x,y){
  return x-y;
}

console.log(calc(5, minus, 1)) // 1 
```
```

##### 2.1. Функции меняющие другие функции

```js
function noisy(f){
    return (...args) => {
        console.log('calling with', args);
        let result = f(...args);
        console.log('called with', args, ', returned', result);
        return result;
    }
}

noisy(Math.min)(3, 2, 1); 
// calling with [3, 2, 1]
// called with [3, 2, 1], returned 1
```

Функция `noisy` принимает другую функцию нахождения минимума в качестве аргумента и возвращает с помощью стрелочной конструкции "болтливую" версию, которая оповещает о начале и конце вызова. Для передачи аргументов болтливой функции используется цепочный вывоз:

```js
noisy(Math.min)(3, 2, 1);
```

##### 2.2. Функции изменяющие поток выполнения

```js
function unless(test, then){
    if (!test) then();
}

repeat(3, n => {
    unless(n%2 == 1, ()=>{
        console.log(n, 'is even');
    })
})
// 0 is even
```

Функции высшего порядка могут быть методами в стандартных структурах данных JavaScript их называют итераторами.

### Итераторы

Это методы высшего порядка, которые могут работать с итерируемыми структурами данных:

- массивы
- строки
- Map
- Set

Итераторы принимают в качестве аргумента предикат, т.е. функцию возвращающую true либо false.

Большинство итераторов, кроме reduce, могут принимать 3 аргумента:

- element текущий элемент массива, обязательный
- index текущий элемент массива, опциональный
- array исходный массив, опциональный

#### forEach()

Метод похожий на функцию `for of`:

```js
["A", "B", "C"].forEach(item => console.log(item));
```

Меняет текущий массив, возможен ранний выход через throw.

#### filter

Что бы отфильтровать элементы в массиве можно создать функцию высшего порядка принимающую два аргумента:

- массив
- условия отбора (тестирующая функция).

```js
function filter(array, test){
    let passed = [];
    for (let element of array){
        if(test(element)){
            passed.push(element);
        }
    }
    return passed;
}

console.log(filter(SCRIPTS, script => scripts.living));
```

Чистая функция не модифицирует массив SCRIPTS а создает новый в соответствии с тестовыми условиями (функцией).

Как и forEach, filter является стандартным методом массива.

Предположим у нас есть массив объектов, где каждый объект содержит имя студента и его оценку за экзамен:

```js
const students = [
    { name: 'John', score: 80 },
    { name: 'Jane', score: 90 },
    { name: 'Bob', score: 70 },
    { name: 'Alice', score: 85 },
    { name: 'Charlie', score: 95 },
    { name: 'Dave', score: 75 },
    { name: 'Eve', score: 85 },
    { name: 'Frank', score: 90 },
    { name: 'Grace', score: 80 },
    { name: 'Henry', score: 85 }
];
```

Мы хотим вывести только тех студентов, у которых оценка больше 80.

```js
const goodStudents = students.filter(student => student.score > 80);
```

Используя метод console.table() можно вывести массив в виде таблицы:

```js
console.table(goodStudents);
```

#### map

Создадим функцию высшего порядка, которая трансформирует элементы массива, по заданному условию (функции).
Предположим мы хотим вывести не объекты массива SCRIPTS а свойство name этих объектов:

```js
function map(array, transform){
    let mapped = [];
    for(let element of array){
        mapped.push(transform(element));
    }
    return mapped;
}

console.log(map(SCRIPTS, s => s.name))
```

**map** также стандартный метод массива.

Предположим, что мы хотим не просто вывести студентов которые набрали 80 и более баллов, но мы хотим вывести вообще всех студентов. У тех кто прошел экзамен должно быть слово "passed", а у тех кто не прошел должно быть "Not passed":

```js
const result = students.map(student => {
    if (student.score >= 80) {
        return { name: student.name, score: student.score, result: "passed" };
    } else {
        return { name: student.name, score: student.score, result: "Not passed" };
    }
});

console.table(result);
```

В данном примере мы передаем методу map анонимную функцию, таким образом метод является функцией высшего порядка.

#### reduce

Напишем функцию суммаризации (подсчет суммы значений массива) по заданным признакам:

```js
function reduce(array, combine, start){
    let current = start;
    for(let element of array)
        current = combine(current, element);
    return current;
}

console.log(reduce([1, 2, 3, 4], (a, b) => a+b, 0));
```

Встроенный в массив метод reduce на примере расчета общей сумму баллов всех студентов:

```js
const totalScore = students.reduce((acc, student) => acc + student.score, 0);
console.log(totalScore);
```

1. Первый аргумент в примере у метода reduce() это анонимная стрелочная функция обратного вызова. Данная функция принимает свои два аргумента:
   - acc - аккумулятор (временное хранилище которое передается при каждой итерации)
   - student - текущий элемент (student) из массива students
2. Второй аргумент - 0, это первоначальное значение аккумулятора.
3. Третий аргумент - индекс текущего элемента.
4. Четвертый аргумент - сам массив.

Чаще всего в reduce() используется первые два аргумента.

В качестве аккумулятора можно использовать объект и это расширяет возможности метода:

```js
const {sum, count} = SCRIPTS.reduce((acc,b) => {
    if(b.living == true) {
        acc.sum+=b.year
        acc.count++
    }
    return acc
},{sum: 0, count: 0})

console.log(Math.round(sum/count));
```

#### some

Используется для поиска хотя бы одного нужного элемента в массиве. Например, чтобы выяснить есть ли среди студентов прошедшие практику:

```js
const hasPassed = students.some(student => student.score >= 80);
console.log(hasPassed); // true
```

Функция обратного вызова вызывается для каждого элемента итерации и если один из них возвращает true, то some() возвращает true и завершает работу на первом попавшемся элементе.

#### every

Обратный методу some(). В массиве все элементы должны соответствовать заданному условию. Например, чтобы выяснить все ли студенты прошли практику:

```js
const hasPassed = students.every(student => student.score >= 80);
console.log(hasPassed); // false
```

#### find

Возвращает первый элемент, который соответствует условию. В противном случае возвращает undefined:

```js
const student = students.find(student => student.score >= 80);
console.log(student); // { name: 'Jane', score: 90 }
```

Возвращает первое найденное вхождение. Позволяет искать неточное совпадение.

#### findIndex

Возвращает индекс первого элемента, который соответствует условию. В противном случае возвращает -1:

```js
const index = students.findIndex(student => student.score >= 80);
console.log(index); // 1
```

Возвращает индекс первого вхождения. Позволяет искать неточное совпадение.

### Деструктуризация

Позволяет распаковать значения из объекта/массива в переменные.

#### Деструктуризация массива

Позволяет сохранять значения из массива в отдельные переменные:

```js
const numbers = [1, 2, 3];
const [a, b, c] = numbers;
console.log(a); // 1
console.log(b); // 2
console.log(c); // 3
```

При деструктуризации массива первый элемент пойдет в первую переменную, второй элемент - во вторую и т.д, т.е. порядок сохранится.
Переменных может быть меньше или больше чем в массиве, при этом переменным можно задать значение по умолчанию:

```js
const arr = [1, 2, 3];
let [a, b, c, d=10] = arr;
console.log(d); // 10

arr.push(4);
[a, b, c, d=10] = arr;
console.log(d); // 4
```

Можно даже пропускать переменные:

```js
const arr = [1, 2, 3];
let [a, , b] = arr;
console.log(b); // 3
```

Деструктуризировать можно и многоуровневый массив:

```js
const arr = [1, 2, [3, 4]];
let [a, b, [c, d]] = arr;
console.log(d); // 4
```

Можно задать значение по умолчанию:

```js
const arr = [1, 2, 3];
let [a, b, c, d=10] = arr;
console.log(d); // 10
```

#### Деструктуризация объекта

Можно использовать деструктуризацию значений из объектов, где порядок свойств не важен:

```js
const person = { name: 'John', age: 30, city: 'New York' };
let { name, age, city } = person;
console.log(name); // John
console.log(age); // 30
console.log(city); // New York
```

Название переменных должно совпадать с именами свойств объекта. Но, можно переименовать любое свойство при деструктуризации:

```js
const person = { name: 'John', age: 30, city: 'New York' };
let { name: userName, age: userAge, city: userCity } = person;
console.log(userName); // John
console.log(userAge); // 30
console.log(userCity); // New York
```

Можно деструктуризировать вложенные объекты:

```js
const user = { name: 'John', info: { age: 30, city: 'New York' } };
let { info: { age, city } } = user; // info тут не как свойство, а как путь внутрь другого объекта
console.log(age); // 30
console.log(city); // New York
```

При деструктуризации объекта можно задавать переменные по умолчанию:

```js
const person = { name: 'John', age: 30, city: 'New York' };
let { name: userName = 'John Doe', age: userAge = 0, city: userCity = 'New York' } = person;
console.log(userName); // John Doe
console.log(userAge); // 30
console.log(userCity); // New York
```

Значение по умолчанию можно задать и для вложенного объекта, которого не существует:

```js
const user = { name: 'John' };
let { name, old: { age = 30 } = {}} = user;
console.log(name, age); // John 30
```

#### Деструктуризация параметров функции

Удобно пользоваться деструктуризацией параметров функции переданных массивом:

```js
function pri([n0, n1, n2, n3]) {
    console.log( n1, n3);
}

pri([1, 2, 3, 4]); // 1 4
```

Или параметров функции переданных в виде объекта:

```js
function pri({n0, n1, n2, n3}) {
    console.log( n1, n3);
}

pri({n0: 1, n1: 2, n2: 3, n3: 4}); // 2 4
```

При передаче параметров функции при деструктуризации, можно задать значения по умолчанию:

```js
function pri({n0 = 1, n1 = 2, n2 = 3, n3 = 4}) {
    console.log( n1, n3);
}

pri({n0: 1, n1: 2, n2: 3, n3: 4}); // 2 4
pri({n1: 2, n3: 4}); // 2 4
pri({}); // 2 4
pri(); // TypeError: Cannot read properties of undefined (reading 'n1')
```

Ошибка возникала потому был передан неопределенный массив, что undefined, таже ошибка возникнет и при деструктуризации null:

```js
const obj = null;
let { name } = obj; // TypeError: Cannot destructure property 'name' from 'null'
```

#### Деструктуризация с rest

Деструктруризацию объекта в сочетатании с rest оператором:

```js
const obj = { name: 'John', age: 30, city: 'New York' };
let { name, ...rest } = obj;
console.log(rest); // {age: 30, city: 'New York'}
```

Деструктуризация массива в сочетатании с rest оператором:

```js
const arr = [1, 2, 3, 4];
let [a, b, ...rest] = arr;
console.log(rest); // [3, 4]
```

Оператор rest должен быть один и в конце, в него попадут все остальные свойства, включая вложенные объекты.

### Сериализация

Свойства объектов не содержат значения, а всего лишь захватывают их указатель. Если у нас есть массив объектов или массивов, тогда происходит двойная адресация ссылки ссылаются на ссылки памяти, содержащие реальные значения. Можно сделать дамп памяти для отправки содержимого по сети, но это не удобно и долго. Для того, что бы сохранить чистые данные без привязки к участками памяти, существует процедура сериализации. Сереализованные данные легко переносить по сети между разными устройствами или с разной архитектурой.

#### JSON

Java Script Object Notation

Формат очень похож на объекты JS, но имена свойств (ключи) обрамлены двойными кавычками, в нем не функций, не должно быть комментариев, в конце группы ключей не ставят запятые:

```json
{
    "name": "John",
    "age": 30
}
```

##### JSON.stringify

Для конвертации объекта JS в строкове представление JSON:

```js
const person = { name: 'John', age: 30 };
const json = JSON.stringify(person);
console.log(json); // {"name":"John","age":30}
```

Метод принимает 3 аргумента:

1. Объект, который нужно конвертировать в JSON (обязательный)
2. Функция-преобразователь, применится ко всем элементам(необязательный)
3. Количество пробелов, которое будет в качестве отступов в JSON (необязательный)

##### JSON.parse

Для конвертации JSON в объект JS:

```js
const json = '{"name": "John", "age": 30}';
const person = JSON.parse(json);
console.log(person); // { name: 'John', age: 30 }
```

## ECMAScript

### 01.Lecture

В ES2015 появились новые операторы:

- **spread** - распаковывает массив (объект) или другие структуры данных в атомарные элементы
- **rest** - принимает неограниченное количество параметров

#### оператор распаковки массива/объекта

**Spread** - расширять, распространять.

Любая функция содержит служебную переменную arguments, которая является псевдомассивом. Псевдомассив не имеет стандартных методов как настоящий массив, типа forEach. Поэтому при передаче в функцию неограниченного количества переменных, мы не сможешь по ним итерироваться как по массиву. Можно только с помощью классического for, что не всегда удобно. Использую spread оператор:

```js
function sum(a, b, c) {
    const args = [...arguments];
    console.log(args);
}
```

Распаковывает массив (объект) или другие структуры данных:

```js
const sum = (a, b, c) => {
    return a + b + c;
}
const arr = [1, 2, 3];
console.log(sum(...arr)); // 6
```

Можно распаковывать внутри другого массива или объекта:

```js
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const arr3 = [...arr1, ...arr2];
console.log(arr3); // [1, 2, 3, 4, 5, 6]
```

#### оператор упаковки

**Rest** - остальные, подобные, другие. Позволяет собрать другие оставшиеся аргументы в массив, тогда не нужно будет использовать встроенный псевдомассив функций arguments:

```js
let summa
function sum(...rest) {
    for (let i = 0; i < rest.length; i++) {
        summa += args[i];
    }
}

sum(1, 2, 3, 4, 5);
console.log(summa); // 15
```

rest можно комбинировать с обычными аргументами функции:

```js
function sum(name, lastname, ...rest) {
    console.log(`your name is ${name} surname is ${lastname} and other ${rest}`);
}
```

В последнем примере внутри переменной **rest** будет массив, если даже оставшееся значение всего одно.

Оператор упаковки можно использовать только в конце аргументов функции.

#### spread + rest

```js
function addOne(...ar){
    let sum = 0;
    for (let x of ar) sum+=x;
    return sum;
}

console.log(addOne(1, 2, 3)); // 6
let arr = [1, 2, 3]
console.log(addOne(arr)); // 01,2,3 
console.log(addOne(...arr)); // 6
```

При передачи отдельных цифр как аргументов функция addOne собирает их в один массив (rest), по которому пробегается цикл for of, суммируя элементы. В итоге возвращается сумма в виде числа.

Если же передать массив в addOne, то он упаковывается в еще один массив [arr], поэтому функция for of пробегается не по элементам массива arr, а по элементам внешнего для arr массива, где он сам элемент. Далее, идет приведение типов: цифрового sum и массива arr, которые приводятся к строке, поэтому функция возвращает конкатенированную строку "01,2,3".

Чтобы посчитать сумму массива к нему нужно применить оператор распаковки (spread).

## 06.Chapter of eloquent JS (3 edition)

### Инкапсуляция

In capsule *lat.* - в оболочке. Инкапсуляция это изолирование свойств и методов внутри объекта, чтобы они не могли быть изменены извне. 

Свойства и методы внутри объекта имеют 3 уровня доступа:

- public - публичные
- protected - защищенные
- private - приватные

#### Public

Публичные свойства и методы видны всему приложению и любая его функция может их использовать. Принято именовать такие свойство как обычные переменные.

```js
class Car {
    constructor(brand, model, distanceTraveled) {
        this.brand = brand;
        this.model = model;
        this.distanceTraveled = distanceTraveled;
        this.isRunning = false;
    }
    start() {
        this.isRunning = true;
    }
    stop() {
        this.isRunning = false;
    }
    getGasolineVolume() {
        
        console.log(this.distanceTraveled / 100 * 9);
    }
}

const car = new Car("Toyota", "Camry", 50000);
car.distanceTraveled = "qwer";
car.getGasolineVolume(); // NaN
```

В данном случае свойству `distanceTraveled` по ходу кода случайно присвоенно значение "qwer", что приводит к невозможности посчитать остаток топлива.

Что бы избежать случайного или непредвиденного воздействия извне, можно использовать специальные свойства и методы.

#### Protected

Защищенные свойства и методы доступны только внутри объекта (класса) или подкласса. Имкена таких свойств должны начинаться с одного подчеркивания `_`.

Добавим защищенное свойство `_driver`:

```js
class Car {
    _driver;
    constructor(brand, model, distanceTraveled, driver) {
        this.brand = brand;
        this.model = model;
        this.distanceTraveled = distanceTraveled;
        this.isRunning = false;
        this._driver = driver;
    }
    start() {
        this.isRunning = true;
    }
    stop() {
        this.isRunning = false;
    }
    getGasolineVolume() {
        
        console.log(this.distanceTraveled / 100 * 9);
    }
}

const car = new Car("Toyota", "Camry", 50000, "Jhon");
car._driver = "Jane";
console.log(car._driver); // Jane
```

`_driver` программно можно изменить, но знак подчеркивания говорит программисту, что это особое свойство, к которому нужно относится внимательнее.

#### Private

Доступ к приватным свойствам и методам возможен только внутри класса, которому они принадлежат. По соглашению приватные свойства и методы начинаются с символа решетки `#`.

Сделаем приватным свойство `#distanceTraveled`:

```js
class Car {
    _driver;
    #distanceTraveled;
    constructor(brand, model, distanceTraveled, driver) {
        this.brand = brand;
        this.model = model;
        this.#distanceTraveled = distanceTraveled;
        this.isRunning = false;
        this._driver = driver;
    }
    start() {
        this.isRunning = true;
    }
    stop() {
        this.isRunning = false;
    }
    getGasolineVolume() {
        
        console.log(this.#distanceTraveled / 100 * 9);
    }
}

const car = new Car("Toyota", "Camry", 50000);
car.#distanceTraveled = "qwer"; // Uncaught SyntaxError: Private field '#distanceTraveled' must be declared in an enclosing class
car.[#distanceTraveled] = "qwer"; // Uncaught SyntaxError: Private field '#distanceTraveled' must be declared in an enclosing class
```

Для изенения приватных свойств и методов успользуют геттеры и сеттеры.

### Геттеры и сеттеры

Каждый раз при использовании точечной нотации при обращении к свойству объекта под капотом используюется геттеры и сеттеры.

Геттеры и сеттеры в JavaScript — это специальные методы доступа к свойствам объекта, которые позволяют перехватывать чтение и запись значений.

```js
class Car {
    _driver;
    #distanceTraveled;
    constructor(brand, model, distanceTraveled, driver) {
        this.brand = brand;
        this.model = model;
        this.#distanceTraveled = distanceTraveled;
        this.isRunning = false;
        this._driver = driver;
    }

    get distanceTraveled() {
        return this.#distanceTraveled;
    }
    set distanceTraveled(value) {
        if(typeof value !== "number") console.log("its not number");
        this.#distanceTraveled = value;
    }
    start() {
        this.isRunning = true;
    }
    stop() {
        this.isRunning = false;
    }
    getGasolineVolume() {
        
        console.log(this.#distanceTraveled / 100 * 9);
    }
}

const car = new Car("Toyota", "Camry", 50000);

console.log(car.distanceTraveled); // 50000
car.distanceTraveled = "qwer"; // its not number
car.distanceTraveled = 100000;
console.log(car.distanceTraveled); // 100000
```

У геттеров нет аргументов, а сеттер наоборот должен иметь аргумент.
Геттеры и сеттеры должны иметь return, их нужно вызыват как свойства без круглых скобок.

#### Интерфейсы

Это ограниченный набор **публичных** свойств и методов (включая геттеры и сеттеры), которые предоставляют полезную функциональность на более абстрактном уровне, пряча тем самым их точную реализацию.

Основная идея ООП в разбиении программы на мелкие куски независимого кода, каждый кусок сам следит за своим состоянием и его изменением. Если другой программист будет работать со вторым куском, то ему не обязательно знать как работает первый.
Разные куски взаимодействуют между собой с помощью **интерфейсов**, т.е. публичных свойств.

У объекта могут быть и **приватные** свойства и методы, которые не являются частью интерфейса.

В отличии от других ЯП (например, java) в JS нет механизма разделения на публичные и приватные значения. Но, существует договоренность приватные свойства начинать с символа подчеркивания.

## 02.Lecture

### class

[Систему прототипирования](#prototype) удобно использовать для задания экземпляров, которые имеют абсолютно одинаковые свойства и методы иначе каждому экземпляру придется добавлять свои методы и свойства. Для создания экземпляров которые имеют часть одинаковых свойств и часть уникальных удобно применять классы (class). Классы в JS появился в ES2015.

```js
// Класс робот-пылесос.
class RobotVacuumCleaner {
    // Свойства класса.
    model = "Romba-1";
    power = 200;
    batterySize = 2100;
    boxSize = 0.5;
    workTime = 45;
    counterOfStarts = 0;
    isFull = false;
    isObstacle = false;
    isUVLampOn = false;
    // Конструктор класса
    constructor() {
    }
    // Методы класса.
    startCleaning() {
        this.counterOfStarts++;
        console.log('I am cleaning... I have been started: ',
        this.counterOfStarts, 'times.');
    }
    goCharge() {
        console.log('I am going to charge...');
    }
    switchUVLamp() {
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    }
}

const Roomba = new RobotVacuumCleaner();
Roomba.isUVLampOn = true;
setTimeOut(Roomba.switchUVLamp, 5000);
```

Все схоже с объектом, только добавился конструктор, свойства внутри присваиваются через равно и методы объявляются по другому. Но, ультрафиолетовая лампа не выключается, т.к. setTimOut запускает выключатель лампы через 5 секунд когда контекст методов класса исчезает и this начинает ссылаться на глобальный объект.

#### Способы создания классов

Ключевое слово class используеся для объявления двух видов классов:

1. именованного класса
2. анонимного классового выражения

Т.к. классы родственны функциям, то они имеют похожие механизмы всплытия.

##### Именованный класс

Данный способ не обладает всплытием:

```js
let classExpression = class { getWord() { return "hello"; } };
const obj = new classExpression();
console.log(obj.getWord());
```

Поэтому объявлять объекты и работать с ними можно только после объявления класса.

##### Анонимное классовое выражение

Выражение "всплывает", т.е. его можно использовать в любом месте программы, т.к. оно создается до выполениня основного кода.

```js
const obj = new classDeclaration();
console.log(obj.getWord());
class classDeclaration { getWord() { return "hello"; } };
```

Именнованный класс и анонимное выражение возвращает конструктор, который в свою очередь с помощью ключевого слова new создает объект.

#### bind()

Используя стандартный метод объектов bind можно сохранить контекст.

```js
// Класс робот-пылесос.
class RobotVacuumCleaner {
    // Свойства класса.
    model = "Romba-1";
    power = 200;
    batterySize = 2100;
    boxSize = 0.5;
    workTime = 45;
    counterOfStarts = 0;
    isFull = false;
    isObstacle = false;
    isUVLampOn = false;
    // Используем его, чтобы привязать все методы класса к контексту - текущему объекту (this).
    constructor() {
        this.startCleaning = this.startCleaning.bind(this);
        this.goCharge = this.goCharge.bind(this);
        this.switchUVLamp = this.switchUVLamp.bind(this);
    }
    // Методы класса.
    startCleaning() {
        this.counterOfStarts++;
        console.log('I am cleaning... I have been started: ',
        this.counterOfStarts, 'times.');
    }
    goCharge() {
        console.log('I am going to charge...');
    }
    switchUVLamp() {
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    }
}
// Создадим экземпляр класса.
const Roomba = new RobotVacuumCleaner();
Roomba.isUVLampOn = true;
setTimeout(Roomba.switchUVLamp, 2000); // UV lamp is not working.
```

Можно еще проще. В случае с классом хорошо работают стрелочные методы, которые не имеют своего контекста, и которые по умолчанию ссылаются через уровень к глобальному для них объекту, т.е. в наше случае к своему классу:

```js
// Класс робот-пылесос.
class RobotVacuumCleaner {
    // Свойства класса.
    model = "Romba-1";
    power = 200;
    batterySize = 2100;
    boxSize = 0.5;
    workTime = 45;
    counterOfStarts = 0;
    isFull = false;
    isObstacle = false;
    isUVLampOn = false;
    // Конструктор класса, мы изучим его подробнее на следующем уроке.
    constructor() {
    }
    // Методы класса.
    startCleaning = () => {
        this.counterOfStarts++;
        console.log('I am cleaning... I have been started: ',
        this.counterOfStarts, 'times.');
    }
    goCharge = () => {
        console.log('I am going to charge...');
    }
    switchUVLamp = () => {
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    }
}
// Создадим экземпляр класса.
const Roomba = new RobotVacuumCleaner();
Roomba.isUVLampOn = true;
setTimeout(Roomba.switchUVLamp, 2000); // UV lamp is not working.
```

Тут не нужно даже инициализировать конструктор, методы отрабатывают хорошо, с привязкой к контексту нашего класса.

#### Приватные свойства

Часта для класса можно создавать приватные свойства и методы, которые используются только самим классом внутри, без доступа из вне.

Наименование приватного метода начинается с символа решетки #:

```js
class SecretiveObject {
  #getSecret() {
    return "I ate all the plums";
  }
  interrogate() {
    let shallISayIt = this.#getSecret();
    return "never";
  }
}
```

Если в классе не задан конструктор, то он будет задан пустым: `constructor() {}`

Приватное свойство перед использованием должно быть объявлено:

```js
class RandomSource {
  #max;
  constructor(max) {
    this.#max = max;
  }
  getNumber() {
    return Math.floor(Math.random() * this.#max);
  }
}
```

### Переопределение методов

Когда определяется свойство к текущему объекту оно добавляется к текущему объекту, но если свойство есть в родителе, то оно переопределяется именно в текущем объекте, не затрагивая родителя:

```js
Rabbit.prototype.teeth = "small";
console.log(killerRabbit.teeth);
// → small
killerRabbit.teeth = "long, sharp, and bloody";
console.log(killerRabbit.teeth);
// → long, sharp, and bloody
console.log((new Rabbit("basic")).teeth);
// → small
console.log(Rabbit.prototype.teeth);
// → small
```

Код иллюстрирует, как выражение `new Rabbit("basic")).teeth` наследует отсутствующее изначально свойство teeth у родителя.

Переопределение использовано например в стандартном методе toString() массива:

```js
console.log(Array.prototype.toString ==
            Object.prototype.toString);
// → false
console.log([1, 2].toString());
// → 1,2
console.log({f: 1, s: 2}.toString());
// [object Object]
```

Как видно метод toString() у объекта и массива разные. В массиве метод переобределен чтобы выводит строку значений как это делает функция join().

## 03.Lecture

### `__proto__`

Устаревший способ наследования, но рабочий. Указывает на какой объект родитель ссылаться. 
Если свойство `__proto__` не задано, то оно по умолчанию ссылается на Object.

Зададим родителя:

```js
// Объект робот-пылесос.
const VacuumCleaner = {
    Model: "vacuum cleaner",
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    startCleaning: function () {
        this.counterOfStarts++;
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of VacuumCleaner');
        console.log('I am cleaning... I have been started: ', this.counterOfStarts, 'times.');},
        goCharge: function () {
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of VacuumCleaner');
        console.log('I am going to charge...');
    }
};
```

Зададим серию наследников:

```js
// Объект робот-пылесос.
const DancingSeries = {
    // Объявляем новые свойства и переопределить свойство model.
    model: "dancing series",
    power: 200,
    batterySize: 2100,
    boxSize: 0.5,
    workTime: 45,
    isUVLampOn: false,
    // Добавляем новый метод.
    switchUVLamp: function () {
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of DancingSeries');
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    },
    // Делаем ссылку на прототип от родителя.
    __proto__: VacuumCleaner,
};
```

Зададим наследника серии:

```js
// Объект робот-пылесос.
const Samba = {
    // Обновляем свойства под конкретную модель.
    model: "Samba-1",
    power: 250,
    batterySize: 2500,
    workTime: 50,
    // Делаем ссылку на прототип от родителя.
    __proto__: DancingSeries,
};
```

Обратимся к свойствам и методам родителя через серию:

```js
// Обращение к свойствам объекта.
console.log(Samba.model); // "Samba-1"
console.log(Samba.isFull); // false
// Вызов методов объекта.
Samba.startCleaning();
// I am the method of VacuumCleaner
// 'I am cleaning... I have been started: 1 times.'
Samba.isUVLampOn = true;
Samba.switchUVLamp();
// I am the method of DancingSeries
// 'UV lamp is not working.'
Samba.goCharge();
// I am the method of VacuumCleaner
// 'I am going to charge...'
```

Механизм прототипов позволяет использовать методы объекта Array в пользовательских массивах, который в свою очередь через свое **proto** ссылкается на Object.

Создадим еще одного конечного наследника и переобределим в нем метод startCleaning(), которые есть в родителе:

```js
// Объект робот-пылесос.
const Djaiv = {
    // Обновляем свойства под конкретную модель.
    model: "Djaiv-1",
    power: 250,
    batterySize: 2500,
    workTime: 50,
    // Переопределим метод startCleaning.
    startCleaning: function () {
        this.counterOfStarts++;
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of Djaiv');
        console.log('I am Djaiv, and I am cleaning... I have been started: ', this.counterOfStarts, 'times.');
    },
    // Делаем ссылку на прототип от родителя.
    __proto__: DancingSeries,
};

Samba.startCleaning();
// I am the method of VacuumCleaner
// 'I am cleaning... I have been started: 1 times.'
Djaiv.startCleaning();
// I am the method of Djaiv
// I am Djaiv, and I am cleaning... I have been started: 1 times.
```

startCleaning() для Djaiv является переопределенным, но у родителя и наследников остался прежним.

### [[Prototype]]

В ES2015 произошел отказ от свойства __proto__, ему на смену было введено внутреннее свойство [[Prototype]].
Это ссылка на прототип объекта, которая не доступна для просмотра и редактированию пользователю напрямую. В JS двойными квадратными скобками [[]] обозначают внутренние свойства языка, например: [[Configurable]], [[Get]], [[Set]], [[Value]], [[Writable]] и т.д.

Для работы с [[Prototype]] используют 2 метода: Object.getPrototypeOf и Object.setPrototypeOf.

#### Object.getPrototypeOf

Позволяет получить ссылки на прототип объекта по цепочке:

```js
// Получим прототип для объекта Djaiv.
const DjaivProto = Object.getPrototypeOf(Djaiv);
console.log(DjaivProto.model); // dancing series
const DjaivProtoProto = Object.getPrototypeOf(DjaivProto);
console.log(DjaivProtoProto.model); //vacuum cleaner
const DjaivProtoProtoProto =
Object.getPrototypeOf(DjaivProtoProto);
console.log(DjaivProtoProtoProto); // [object Object]
```

Object не имеет прототипов, т.к. является самым первым, поэтому он вернет null.

#### Object.setPrototypeOf

Зададим новоую серию наследников musicSeries:

```js
// Объект робот-пылесос.
const MusicSeries = {
    // Объявляем новые свойства и переопределяем свойство model.
    model: "music series",
    power: 200,
    batterySize: 2100,
    boxSize: 0.5,
    workTime: 45,
    // Добавляем новый метод.
    startWipe: function () {
    // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of MusicSeries');
        console.log('I am starting to wipe the floor...');
    },
    // Делаем ссылку на прототип от родителя.
    __proto__: VacuumCleaner,
};
```

Создадим конечного наследника и используем setPrototypeOf с двумя параметрами - объект наследник, объект родитель:

```js
// Объект робот-пылесос.
const Blues = {
    // Обновляем свойства под конкретную модель.
    model: "Bluees-1",
    power: 250,
    batterySize: 2500,
    workTime: 50,
};
// Установим прототип для робота.
Object.setPrototypeOf(Blues, MusicSeries);

console.log(Object.getPrototypeOf(Djaiv).model) // dancing series
console.log(Object.getPrototypeOf(Blues).model) // music series

Djaiv.startWipe(); // Uncaught TypeError: Djaiv.startWipe is not a function
```

### Конструктор объекта

Конструктор объекта - вызываемая с помощью оператора new функция, которая создает объект и проводит инициализацию.
Функцию конструктор объекта принято называть с большой буквы, внутри нее свойства и методы объявляют с помощью this.

Этапы создания объекта с помощью конструктора:

- создание нового пустого объекта;
- пустой объект присваивается свойству this;
- выполняется тело функции-конструктора;
- возвращается новый объект, либо this:

```js
function Test1(name) {
    this.a = 1;
    return {name};
}

const test1 = new Test1("test1"); // { name: 'test1' }

function Test2(name) {
    this.b = 2;
    this.name = name;
}

const test2 = new Test2("test2"); // { b: 2, name: 'test2' }
```

Обычная функция возвращающей без return undefined, а конструктор без return возвращает this, c return указанный объект.

Если попытаться веррнуть примитов, то объект не созадется:

```js
function Test3(name) {
    this.name = name;
    return 1;
}

const test3 = new Test3("test3"); // undefined
```

Создадим конечного наследника от первой серии пылесосов:

```js
// Конструктор объекта робот-пылесос.
function Samba(serailNumber) {
    // Создаем свойства объекта, используя this.
    this.serialNumber = serailNumber;
    this.model = "Samba-1";
    this.power = 250;
    this.batterySize = 2500;
    this.workTime = 50;
    // Делаем ссылку на прототип от родителя.
    this.__proto__ = DancingSeries;
}
// Создадим экземпляр нового объекта.
const Samba1 = new Samba(1014778);
console.log(Samba1.serialNumber); // 1014778
console.log(Samba1.startCleaning()); // I am the method of VacuumCleaner
// I am cleaning... I have been started: 1 times.
```

Конструкторы ускоряют процесс создания множества однотипных объектов:

```js
// Создадим 10 роботов пылесосов Samba, как на конвейере. 
// const robots = [];
for (let index = 0; index < 10; index++) {
    // Создадим экземпляр нового объекта и добавляем его в массив наших роботов, каждый с уникальным серийным номером.
    robots.push(new Samba(index));
}
console.log(robots[3].serialNumber); // 3
console.log(robots[7].serialNumber); // 7
```

В примере с конструкоторм мы указали родителя с помощью this.**proto**, а можно с помощью свойства prototype:

```js
function Samba(serailNumber) {
    this.serialNumber = serailNumber;
    this.model = "Samba-1";
    this.power = 250;
    this.batterySize = 2500;
    this.workTime = 50;
}
// Делаем ссылку на прототип от родителя.
Samba.prototype = DancingSeries;
const Samba1 = new Samba(1014778);
console.log(Samba1.serialNumber); // 1014778
console.log(Samba1.startCleaning()); // I am the method of VacuumCleaner
// I am cleaning... I have been started: 1 times.

console.log(Samba1.__proto__); // {model: "dancing series", power: 200, batterySize: 2100, boxSize: 0.5, workTime: 45, ...}
console.log(Samba1.prototype); // undefined
console.log(Samba1.__proto__ === Samba.prototype); // true
```

Свойства `__proto__` есть у каждого объекта, оно позволяет найти родителя. Свойство же prototype есть только у нестрелочных функций, оно выполняет служебную роль при создании объекта и с помощью оператор new.

#### prototype

Методы это всего лишь свойства, хранящие значения фукнций:

```js
function speak(line) {
  console.log(`The ${this.type} rabbit says '${line}'`);
}
let whiteRabbit = {type: "white", speak};
let hungryRabbit = {type: "hungry", speak};

whiteRabbit.speak("Oh my fur and whiskers");
// → The white rabbit says 'Oh my fur and whiskers'
hungryRabbit.speak("Got any carrots?");
// → The hungry rabbit says 'Got any carrots?'
```

Обычно метод применяется к тому объекту из которого он был вызван и ключевое слово this в теле метода ссылается на этот объект.
В данном случае this можно рассматривать как эстрапараметр передаваемый отличным от обычного аргумента фукнции способом. Можно указать явно объект внутри call, который будет подставлен вметсо this в методе:

```js
speak.call(whiteRabbit, "Oh my fur and whiskers");
```

Любая фукнция воспринимает this как объект, но делает это по разному:

- классические функции под this подразумевуют свой объект
- стрелочные функции не имеют своего this, но могут обращаться к нему на уровень выше:

```js
let finder = {
  find(array) {
    return array.some(v => v == this.value);
  },
  value: 5
};
console.log(finder.find([4, 5])); // true
```

Если в данном контексте использовать классическую фукнцию с ключевым словом this внутри метода some, то мы не сможем выйти за пределы конекста и ничего не получится.

Другой способ создать объектный тип "кролик" с методом "говорить" использование вспомогательной функции, которая примет параметры: тип данных "кролик" и функцию "говорить". Можно создать много кроликов у которых похожие методы. Механизм, который позволяет это дела называется **prototype inheritance**.

```js
let empty = {};
console.log(empty.toString);
// → function toString(){…}
console.log(empty.toString());
// → [object Object]
```

Создали пустой объект, но у него уже есть метод toString(). Когда у объекта нет какого либо свойства (метода), оно будет искаться у его прототипа, если у прототипа нет такого свойства, то будет искаться у его прототипа и так далее, пока не будет достигнут объект без протолтипа:

```js
console.log(Object.prototype) // undefined
```

На этом принципе работают созданые пользователем объекты:

- Функции Function.prototype
- Массивы Array.prototype

Но можно переопределить прототипы или указать в качестве прототипа другой объект:

```js
let blackRabbit = Object.create(protoRabbit);
```

### Object.create

Метод позволяет также создавать новые объекты как и способы ранее. Аргументами принимает прототип и свойства нового объекта в формате словаря с ключами. Данный метод хорош тем, что в качестве первого аргумента может принимать null, тогда создаваемые объекты не будут привязаны к Object и не будут наследовать его методы такие как toString(), valueOf() и т.д. Иногда нужно создать объект без единого свойства и метода:

```js
const Samba1 = new Samba(101);
console.log(Samba1.toString()); // [object Object]

const Samba1 = Object.create(null);
console.log(Samba1.toString); // undefined
console.log(Samba1.__proto__); // undefined
```

Но, есть более удобные механизмы создания объектов и насследования, которые появились с приходом ES2015

### new

Оператор new позволяет правильно вызвать конструктор, которая как функция ничего не возвращает и создать объект, по алгоритму:

1. Создаем пустой объект.
2. Задает ссылку для this на созданый объект
3. Вызывает функцию конструктор.
4. Если у функции конструктора есть свойство prototype, то устанавливает его значения для свойства объекта `__proto__`
5. Устанавливает свойство constructor ссылкой на конструктор
6. Возвращает созданный объект

Самописный оператор new в виде фукнции в соотвествии с алгоритмом выше:

```js
function createObject(constructor) {
    // Создаем новый объект.
    const obj = {};
    // Установим новому объекту прототипом прототип функции-конструктора
    Object.setPrototypeOf(obj, constructor.prototype);
    // Вызовем функцию-конструктор, передав ей как this созданный на шаге 1 объект, и передадим остальные аргументы, если они были переданы в createObject
    const argsArray = Array.prototype.slice.apply(arguments);
    const result = constructor.apply(obj, argsArray.slice(1));
    // Вернем новый объект, если конструктор вернул примитивное значение или undefined, иначе вернем то, что вернул конструктор.
    if (!result || typeof result === 'string' || typeof result === 'number' || typeof result === 'boolean') {
        return obj
    } else {
        return result;
    }
}
// Создадим экземпляр нового объекта.
const Samba1 = createObject(Samba, 1014778);
// Проверим установку свойств в конструкторе.
console.log(Samba1.serialNumber); // 1014778
// Проверим, что прототип установился корректно, и мы можем вызывать методы из родительских объектов.
console.log(Samba1.__proto__); // {model: "dancing series", power: 200, batterySize: 2100, boxSize: 0.5, workTime: 45, ...}
console.log(Samba1.startCleaning()); // I am the method of VacuumCleaner
// I am cleaning... I have been started: 1 times.
// Проверим присвоение конструктора.
console.log(Samba1.constructor); // function Object() { [native code] }
```

#### Map

Предположим нужна структура данных для храненния возраста пользователей:

```js
let ages = {
    "Julia" : 62,
    "Boris" : 39,
    "Grandpa" : 402,
    "Eddie" : 10
};

console.log(`Julia is ${ages["Julia"]}`);
console.log("Is Jack's age known?", "Jack" in ages);
console.log("Is toString's age known?", "toString" in ages);
```

Видим проблему в последней строке. Метод (свойство) объекта toString (лешнее имя) и аналогичные свойство могут дать не тот результат, что ожидаем.

Для решения проблемы лишних имен, можно создать объект без прототипа:

```js
const ages = Object.create(null);
ages.Julia = 62;
...
```

Можно использовать `Object.hasOwn(ages, "toString"); \\ false`, 

Помимо проблемы внутренних методов есть и другие при использовании объекта как словаря:

- Ключи могут быть только строками или Symbols
- Объект напрямую не итеррируемы
- Нет свойства size, т.е. кол-во элементов объекта нужно считать вручную.


Поетому в ES2015 добавили конструктор Map(), который имеет преемущества перед объектом:

- Нет по умолчнию ни ключей ни методов
- Ключи могут быть любыми, включая цифры
- Имеется свойство size
- Можно итерироваться с помощью for/of или forEach()

Конструктор Map(), предназначены для создания структуры данных ассициированных пар ключ-значение. Ключи уникальны, а значения могут повторяться.

```js
let ages = new Map();
ages.set("Julia", 62);
ages.set("Boris", 39);
ages.set("Grandpa", 402);
ages.set("Eddie", 10);
console.log(ages.has("toString")); //false
```

Объекты Map() имеют следующие методы:

- set(key, value)
- get(key)
- has(key)
- delete(key)
- clear()
- keys()
- values()
- entries()

Map() имеет недостаток, его нельзя напрямую серелизовать, например в JSON-строку.

### Полиморфизм

Полиморфизм в JS основан на утиной типизации (duck typing): "Если, что-то похожее на утку крякает, то это утка".

Например у нас есть два объекта машина и мотоцикл, если эти оба объекта имеют метод start(), т.е. они зоводятся, то данные объекты можно объеденить одним понятием **транспортные средства** и применять к данным объектам соотвествующие методы:

```js
function startVehicle(vehicle) {
    if (typeof vehicle.start === 'function') {
        vihicle.start();
    } else {
        throw new Error('Not a vehicle');
    }
}

startVehicle(car);
startVehicle(bike);
```

Другой пример со встроенными объектами JS.
Когда вызываете функцию String() для строк, она вызывает метод toSting() у строчного-объекта, так на выводе получаем напечатанную строку.
Но, со стандартным объект [object Object] функция String() не работает, потомучто, метод toString() не определен и не известно как выводить содержимое конкретного объекта (особенно вложенного и многоуровнего).
Тем не менне, для объекта можно определить метод toString() и фукнция String() будет работать.:

```js
const user = {
    name: 'John',
    age: 30,
    toString() {
        return `${this.name} is ${this.age} years old`;
    }
};
console.log(String(user)); // John is 30 years old
```

Получается хороший подход - когда кусок кода написан для работы с объектами, которые имеют определенный интерфейс, в нашем случае toString(), то любой объект, поддерживающий этот интерфейс, будет работать с этим кодом. Данная техника называется полиморфизмом. Полиморфный код может работать со значениями любой формы, если они поддерживают определенный интерфейс.

Пример широко используемого интерфейса для массиво-подобных объектов - это свойство length. Свойство length доступно и для массивов, и для строк, а также для ряда других объектов

### static

Ключевое слово static используется в классах для определения статических методов и свойств, которые принадлежат самому классу, а не экземплярам этого класса.

```js
class MathUtils {
  static square(x) {
    return x * x;
  }
}

console.log(MathUtils.square(5)); //  25

const utils = new MathUtils();
console.log(utils.square);  // undefined (это НЕ метод экземпляра)
```

Пример использования статического метода в производстве:

```js
class Car {
    constructor(make, model) {
        this.make = make;
        this.model = model;
    }

    static createFromLicensePlate(licensePlate) {
        const make = licensePlate.slice(0, 2);
        const model = licensePlate.slice(2);
        return new Car(make, model);
    }
}

const ford = Car.createFromLicensePlate('AB123CD');
```

Статический метод createFromLicensePlate() используется для создания экземпляра класса Car из лицензионного номера автомобиля. Он не используется позже с объектом ford.

Статический метод или свойство можно также задать через присвоение его самому имени класса:

```js
Car.createFromLicensePlate = function(licensePlate){
    ...
}
```

#### Singleton

Синглтон (Singleton) - это паттерн проектирования, который гарантирует, что класс может иметь только один экземпляр. В JavaScript синглтон можно реализовать с помощью класса и статического метода, который возвращает единственный экземпляр класса.

```js
class Singleton {
  static instance;

  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this;
    }
    return Singleton.instance;
  }

  someMethod() {
    console.log('Это метод синглтона');
  }
}

const singleton1 = new Singleton();
const singleton2 = new Singleton();

console.log(singleton1 === singleton2); // true
```

При попытке создать несколько экземпляров класса Singleton, мы получаем всегда один и тот же экземпляр, что полезоно для:

- Хранения глобальных переменных в одном месте
- Логирования всех ошибок в одном месте
- Хранения конфигурации в одном месте
- Централизованного кэширования
- Упрощения тестирования, где все зависимости в одном месте 

### Symbol()

Symbol() всегда уникальный, нельзя создать два одинаковых Symbol(). В ES6 был добавлен для решения проблем:

- Дублирующихся имен ключей внутри объектов, с помощью symbol можно задавать ключи с одинаковыми именами
- Для создания приватных свойств внутри объектов, symbols не отображаются в Object.keys() и for/in циклах:

```js
const test = Symbol('test');

const obj = {
    [test]: 'testValue'
}

console.log(Object.keys(obj)); // []
console.log(Object.getOwnPropertySymbols(obj)); //[ Symbol(test) ] 
console.log(Reflect.ownKeys(obj)); // [ Symbol(test) ] 
console.log(obj[test]); // testValue 
```

Возможно добавление символьного свойства в объект или класс обрамив свойство квадратными скобками, как при использовании скобочной нотации при вызове свойств объекта:

```js
const myTrip = {
    length: 2,
    0: 'New York',
    1: 'San Francisco',
    [length]: 21500

};
console.log(myTrip[length], myTrip.length); // 21500 2
```

Через Symbol можно задавать свойства прототипам:

```js
const mySymbol = Symbol('mySymbol');

Array.prototype[mySymbol] = function () {
    console.log('This function added to the Arrays prototype');
}

const myArray = [1, 2, 3];
myArray[mySymbol](); // This function added to the Arrays prototype
```

Недостатки symbols:

- Не достаточно распространен
- Нельзя изменить после создания
- Одинаково названные symbols могут запутать
- Не удаляются сборщиком мусора, в отличие от других примитивов

### Интерфейс iterator

Добавленный в ES6 цикл for/of ожидает итерируемого объекта, имеющего символьный метод `[Symbol.iterator]()` (символьное значение определенное самим языком, хранящееся в функции Symbol).
Когда метод вызван он должен вернуть объект предоставляющий второй интерфейс **итератор**, вот эта штука и занимается итеррированием. Объект имеет метод **next()**, который возвращает следующий результат, который тоже объект имеющий свойство **value**, которое в свкою очередь будет иметь следующее значение, в случае наличия или свойство **done** имеющее значение true, указывающее что итерация завершена.
Свойства объекта **next**, **value** и **done** являются строками, не символьным типом. Только Symbol.iterator, который предполагается будет добавлен в большниство объектов, является символьным типом данных:

```js
const iterator = [1, 2, 3][Symbol.iterator]();
console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

Создадим сами и итеррируемый объект на основе односвязного списка:

```js
class List{
    constructor(value, rest){
        this.value = value;
        this.rest = rest;
    }
    get length(){
        return 1 + (this.rest ? this.rest.length : 0);
    }
    static fromArray(array){
        let result = null;
        for(let i = array.length - 1; i>=0; i--){
            result = new this(array[i], result);
        }
    }
}
```

В статическом методе класса **this** ссылается на конструктор текущего класса, не экземпляра, пока еще нет экземпляров, когда данный метод вызван.

Итерирование по спику должно возвращать все элементы от начала до конца. Для этого напишем отдельный класс-итератор:

```js
class ListIterator{
    constructor(list){
        this.list = list
    }

    next(){
        if(this.list == null){
            return {done: true};
        }
        let value = this.list.value;
        this.list = this.list.rest;
        return {value, done: false};
    }
}
```

Класс отслеживает прогресс итерации по списку обновляя свое свойство **list**, до тех пор пока значения возвращаются.

Теперь сделаем класс **List** итерируемым:

```js
List.prototype[Symbol.iterator] = function(){
    return new ListIterator(this);
}
```

Данный кусок кода можно поместить непосредственно в класс. Теперь можем итерироваться по списку с помощью for/of:

```js
let list = List.fromArray([1, 2, 3]);
for(let element of list){
    console.log(element);
}
// 1
// 2
// 3
```

Пример реализации итератора внутри объекта:

```js
const myIterable = {
  data: [1, 2, 3, 4],

  [Symbol.iterator]: function () {
    let index = 0;
    return {
      next: () => {
      if(index < this.data.length){
        return { value: this.data[index++], done: false };
        } else {
        return { done: true };
        }
      }
    }
  }
}

for(el of myIterable){
    console.log(el);   // 1 2 3 4
}
```

Блягодаря наличию `[Symbol.iterator]()` cинтаксический сахар ... (rest оператор упаковки в массив) работает с любым итеррируемым объектом, позволяя превратить его в обычный массив:

```js
console.log([..."PCI"]); // ["P", "C", "I"]
```

Плюсы интерфейса (т.е. публичного метода) iterator:

- Итерация по любым объектам
- Итерация в соответствии с заданной логикой
- Инкапсуляция - спрятаны детали структуры данных, поэтому итерирооваться можно незная фнутренней организации данного объекта

### Генераторы

Использование генераторов для создания итераторов упрощает код:

```js
class Range{
    constructor(start, end){
        this.start = start;
        this.end = end;
    }
    *[Symbol.iterator](){
        for(let i = this.start; i <= this.end; i++){
            yield i;
        }
    }
}

const myRange = new Range(1, 5);

for (const num of myRange){
    console.log(num);
}
```

Обратите внимание на добавление * перед [Symbol.iterator], что указывает на то, что метод является генератором.

Функция генератор последовательно возвращает итератор, который неявно содержит свойства value и done.

## Наследование

Предположим нам нужен класс такой же как List, но мы не хотим дожидаться подсчета всех элементов, чтобы получить размер списка с помощью **length**. Хотим чтобы актуальный размер списка был всегда доступен для каждого экземпляра. Такое возможно с помощью механизма **наследования**. Можно наследовать все свойства объекта и добавить еще какие-то отличные от **супер-класса**, получив таким образом **подкласс**.

```js
class LengthList extends List{
    #length;
    constructor(value, rest){
        super(value, rest);
        this.#length = super.length;
    }
    get length(){
        return this.#length;
    }
}

console.log(LenghtList.fromArray([1, 2, 3]).length); // 3
```

Ключевое слово **super** это ссылка на родительский класс. Используется при наличие extends. Внутри constructor super должен идти первым иначе будет ошибка.

Наследование фундаментальная часть ООП, так же как и инкапсуляция или полиморфизм, но в отличии от них, которые упрощяют и прячут подробности, наследование усложняет и делает больше взаимосвязей. Т.к. чтобы понять подкласс, нужно знать друге классы от которых он произошел.

Наследования объектов можно добится следующими способами:

- Object.create
- с помощью конструктора
- ключевого слова extends

### Object.create()

Добиваемся наследования через цепочку прототипов:

```js
const animalPrototype = {
    makeSound: function(){
        console.log('Generic Animal sound');
    }
};

const birdPrototype = Object.create(animalPrototype);
birdPrototype.fly = function(){
    console.log('The bird is flying');
};

const myBird = Object.create(birdPrototype);
myBird.name = "Sparrow";
console.log(myBird.name); // Sparrow
myBird.fly(); // The bird is flying
myBird.makeSound(); // Generic Animal sound

birdPrototype.makeSound = function () {
    console.log('Tweet, tweet!');
}
```

### Функция конструктор

```js
function Animal(name) {
    this.name = name;
}
// добавили метод к прототипу конструктора Animal
Animal.prototype.makeSound = function(){
    console.log('Generic Animal Sound');
};
// создали дочерний класс Bird
function Bird(name, wingspan){
    Animal.call(this, name); // унаследуем свойства от конструктора Animal, передав this
    this.wingspan = wingspan; // передадим спицифичные для птицы свойства
}

Bird.prototype = Object.create(Animal.prototype);
Bird.prototype.fly = function(){
    console.log('The bird is flying');
}

const myBird = new Bird('Sparrow', '20 cm');
console.log(myBird.name); // Sparrow
console.log(myBird.wingspan); // 20 cm
myBird.fly(); // The bird is flying
myBird.makeSound(); // Generic Animal sound
```

### class extends

Заменим предыдущий код современным способом, создадим родителя:

```js
class Animal{
    constructor(name){
        this.name = name;
    }
    makeSound(){
        console.log('Generic Animal Sound');
    }
}

class Bird extends Animal{
    constructor(name, wingspan){
        super(name);
        this.wingspan = wingspan;
    }
    fly(){
        console.log('The bird is flying');
    }
}

const myBird = new Bird('Sparrow', '20 cm');
console.log(myBird.name); // Sparrow
console.log(myBird.wingspan); // 20 cm
myBird.fly(); // The bird is flying
myBird.makeSound(); // Generic Animal sound
```

На примере пылесосов:

```js
// Класс робот-пылесос.
class VacuumCleaner {
    model = "vacuum cleaner";
    counterOfStarts = 0;
    isFull = false;
    isObstacle = false;
    // Для создания конструктора, нужно создать метод constructor.
    constructor() {
    }
    startCleaning() {
        this.counterOfStarts++;
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of VacuumCleaner');
        console.log('I am cleaning... I have been started: ', this.counterOfStarts, 'times.');
    }
    goCharge() {
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of VacuumCleaner');
        console.log('I am going to charge...');
    }
}
// Попробуем создать экземпляр класса и посмотреть как онработает.
const BaseRobot = new VacuumCleaner;
console.log(BaseRobot.constructor); // class VacuumCleaner {
// model = "vacuum cleaner";
// counterOfStarts = 0;
// isFull = false;
// isObstacle = false;
// Для создания конструктора, нужно создать метод constructor.
// constructor() {
// }
// ...
console.log(BaseRobot.model); // vacuum cleaner
console.log(BaseRobot.startCleaning()); // I am the method of VacuumCleaner
// I am cleaning... I have been started: 1 times.
```

Cоздадим расширенную новым методом серию:

```js
// Расширенный класс DancingSeries. C помощью extends мы указываем от какого класса будем наследоваться.
class DancingSeries extends VacuumCleaner {
    // Объявляем новые свойства и переопределяем свойство model.
    model = "dancing series";
    power = 200;
    batterySize = 2100;
    boxSize = 0.5;
    workTime = 45,
    isUVLampOn = false;
    // Добавляем новый метод.
    switchUVLamp() {
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of DancingSeries');
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    }
};

// Создадим новый экземпляр класса, чтобы посмотреть как он работает и что в нем есть.
const DancingRobot = new DancingSeries;
console.log(DancingRobot.__proto__); // VacuumCleaner
{constructor: ƒ, switchUVLamp: ƒ}
console.log(DancingRobot.model); // dancing series
console.log(DancingRobot.switchUVLamp()); // I am the method of DancingSeries
// lamp is working.
```

Под капотом все ранее описанные действия. Объявляя класс движок JS:

- создает функцию конструктор по имени класса
- берет для конструктора код из метода constructor, если метода нет то конструктор тоже будет пустым.
- Если есть расширение, то в конструкторе будет служебное свойство prototype
- прописывает все методы в свойство prototype конструктора

```js
// Созданный конструктор является функцией, код которой взят из конструктора.
console.log(DancingSeries === DancingSeries.prototype.constructor); // true
// В созданном конструкторе есть свойство prototype и оно содержит все методы.
console.log(DancingSeries.prototype); // VacuumCleaner {constructor: ƒ, switchUVLamp: ƒ}
```

### Оператор instanceof

Чтоб знать от какого класса произошел объект, используется оператор бинарный instanceof:

```js
function Car(make, model){
    this.make = make;
    this.model = model;
}

var myCar = new Car('Toyota', 'Camry');

console.log(myCar instanceof Car); // true
console.log(myCar instanceof Object); // true
console.log(myCar instanceof Array); // false
```

### 04.Lecture

#### Async

Асинхронный код состоит из двух частей:

- долгая часть (требует большего времени выполнения)
- callback - вызывается по завершению долгого кода, может сообщать о его завершении

**Цикл Событий** (Event Loop) - механизм, который помещает долгую часть в очередь отложенных задач и следит за ними.

#### Event Loop

Сам цикл событий состоит из трех частей:

1. Call Stack - **стек вызовов** синхронного кода
2. Callback Queue - **очередь отложенных задач** асинхронного кода
3. API среды (ПО где запущен JS: браузера или node.js)- сам движок например не содержит асинхронную функцию setTimout()

```js
console.log("Start algorithm!");
setTimeout(function timeout() {
console.log("This will be printed after 5 seconds!");
}, 5000);
console.log("End synchronous code.");
```

Первая строка синхроная, она попадает в Call Stack, выполняется стандартными механизмами и завершается.
Вторая строка setTimeout() это асинхронная фукнция API браузера, она содержит каллбек фукнцию timeout(), которая через 5 секунд попадает в Callback Queue. (если бы была синхронная функция, то она бы попала в Call Stack и не была бы в очереди отложенных задач)

Пока длятся 5 секунд, код продолжает выполнятся дальше выведя сообщение из 7 строки.
Все это время цикл событий смотрит за стеком вызовов, если он пустой (т.е. нет синхронных задач) то он берет первую задачу из очереди отложенных асинхронных задач и помещает функцию timeout() в стек синхронных вызвов и из стека вызовов стандартный механизм выполняет и завершает timeout().

Цикл событий тупо делает два действия: следит когда освободится стек и сразу бередь задачу из очереди и помещает в стек.

При занятом долгой синхронной задачей и следовательно забытым ей стеке нет гарантии, что функция timeout() выполнится в течении 5 секунд.

Асинхронными делаются функции, которые чем-то могут быть заняты и не заблокируют основной поток, например:

- доступ к БД
- чение или запись файлв
- оптарвка или получание данных по сети

В вебе часто код для подгрузки картинок делают асинхронным, чтобы пользователю не дожидаясь были доступны текст и элементы упралвения.

Встроенные функции и методы могут быть синхронными или асинхронными, а есть в двух исполнениях сразу.

Циклы for, while - является синхронным, цикл while. Но, есть способ сделать код с такими операторами асинхронным

#### AJAX

Asynchronous JavaScript And XML (AJAX) - механизм, который позволяет обновлять страницу без перезагрузки: чаты, мессенджеры, уведомления и т.д.

##### XMLHttpRequest

Объект XMLHttpRequest позволяет создать объект запроса на сервер и ответа от него (через браузер как html-файл):

```js
// XHR GET запрос
// Для создания запроса сначала нужно создать объект XMLHttpRequest, конструктор вызывается без аргументов.
const xhr = new XMLHttpRequest();
// Открываем запрос. Первый аргумент это метод (GET, POST ...), второй адрес, куда нужно отправить запрос. У данного метода есть еще аргументы, которые мы рассмотрим позже.
xhr.open('GET', 'https://api.github.com/users/octocat');
// Отправляем запрос на сервер. Метод send() может принимать один аргумент - это тело запроса, если оно есть. Для методов POST мы бы передавали тут тело запроса, наш запрос GET не имеет тела запроса.
xhr.send();
// После отправки запроса нам нужно использовать методы слушатели, которые будут асинхронно выполнены при наступлении соответствующего события. Это методы onload, onerror и onprogress - мы сами определяем их функции.
// onload - будет вызван, когда сервер вернет ответ. Это может быть положительный ответ сервера с кодом 200 (все хорошо), так и ошибка, например страница не найдена, тогда код будет 404. Мы должны обрабатывать такие ситуации сами.
xhr.onload = function() {
    if (xhr.status != 200) { // если статус не 200, то произошла ошибка
        console.log(`Error ${xhr.status}: ${xhr.statusText}`);
    } else {
        console.log(`user: ${xhr.response}`); // response - это ответ сервера
    }
};
// onprogress - функция будет вызываться пока запрос находится в процессе, и позволяет отслеживать ход процесса отправки запроса и получения ответа от сервера. Бывает полезна при отладке сложных запросов.
xhr.onprogress = function(event) {
    console.log(`Get from server: ${event.loaded} bytes`);
};
// onerror - функция будет вызываться если в запросе пошло что-то не так. НАпример нет соединения с сервером или ошибка в адресе запроса.
xhr.onerror = function() {
    console.log("Request error");
};
// Вывод из функции onprogress.
// Get from server: 1319 bytes
// Вывод из функции onload, приведен не полностью.
user: {`
"login": "octocat",
"id": 583231,
"node_id": "MDQ6VXNlcjU4MzIzMQ==",
"avatar_url":
"https://avatars.githubusercontent.com/u/583231?v=4",
"gravatar_id": "",
"url": "https://api.github.com/users/octocat",
"html_url": "https://github.com/octocat",
"followers_url":
"https://api.github.com/users/octocat/followers",
"following_url":
"https://api.github.com/users/octocat/following{/other_user}",
...`
}
```

С помощью node.js:

```js
const XMLHttpRequest = require('xhr2');

const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.github.com/users/strogino');
xhr.send();

xhr.onload = function() {
  if (xhr.status !== 200) {
    console.log(`Error ${xhr.status}: ${xhr.statusText}`);
  } else {
    console.log(`user: ${xhr.response}`);
  }
};

xhr.onprogress = function(event) {
  console.log(`Get from server: ${event.loaded} bytes`);
};

xhr.onerror = function() {
  console.log("Request error");
};
```

Объект XMLHttpRequest имеет ряд других полезных методов, но его применение с каждом годом становится менее актуальным, т.к. есть метод fetch.

#### async/await

Появился в ES8.

**async** - превращает любую функцию в обещание и позволяет использвать await внутри нее.

**await** - останавливает выполнение функции, пока она не вернет результат.

```js
const getUser = async (url) => {
    // Делаем запрос, и ждем его результат (указание await), который будет сохранен в константу response.
    const response = await fetch(url);
    // Выполняем еще один асинхронный метод, преобразования в текст, также ждем результат, который сохраняется в константу пользователь.
    const user = await response.text();
    console.log(user);
}
getUser('https://api.github.com/users/octocat');
// Вывод в консоль.
// {
// "login": "octocat",
// "id": 583231,
// ...
// }
```

#### setTimout(), setInterval()

Запланированная асинхроность - это когда нужно синхронный код превратить в асинхронный. Например, для имитации задержки ответа от сервера:

```js
let counter = 0; // объявляем переменную counter
const amount = 100000; // объявляем переменную amount
const timerId = setInterval(() => {
    if (counter > amount) {
    // После того как наш счетчик достигнет нужного количества итераций, мы должны очистить таймер, чтобы итерации больше не выполнялись.
    clearInterval(timerId);
        console.log('End long calculations');
    }
    // Добавим вывод нашего счетчика через каждые 10000 итераций, чтобы видеть что наш код работает.
    if (counter % 10000 === 0) {
        console.log('working: ', counter);
    }
    const newDate = new Date(counter);
    counter++;
}, 0);
// Start long calculations
// working: 0
// working: 10000
// working: 20000
...
// End long calculations
```

Вышеперечисленные функции помещают колбеки в очерь отоложенных задач, поэтому они становятся асинхронными

## Ошибки

(webserial 15)

Типы ошибкок:

1. С обработкой
    - ReferenceError (ссылочная ошибка) - при попытке обращения к несуществующему объекту
    - RangeError - при попытке выполнить операцию вне диапазона
    - URIError - при неправильном использовании кодирования или декодирования URI
    - TypeError - при неправильном типе данных или у данного типа нет вызываемого метода
    - AggregateError - при возникновении несколькими ошибок одновременно ECMA 2021 для асинхронного программирования (promises)
    - EvalError - при неправильном использовании операцию eval
2. Без обработки
    - SyntaxError - при попытке выполнить операцию с неправильным синтаксисом
    - InternalError - внутренняя ошибка из-за реализации программы или библиотеки JS

### try/catch

```js
try {
    // Код, который может вызвать ошибку
} catch (error) {
    // Обработка ошибки
}
```

### Strict mode

Помещенная в начало файла или функции инструкция `"use strict"` включает строгий режим, в котором нельзя использовать несуществующие переменные.

```js
function canYouSpotTheProblem() {
  "use strict";
  for (counter = 0; counter < 10; counter++) {
    console.log("Happy happy");
  }
}

canYouSpotTheProblem();
// → ReferenceError: counter is not defined
```

Без `"use strict"` counter будет объявлен глобально, т.е. `var counter;`. Строгий режим не защитит от ошибки объявления переменной, если она была объявлено где-то ранее по коду.

По умолчанию строгий режим включен в классах и модулях.

Строгий режим c функциями если они вызываются не как методы присвоит this undefined:

```js
"use strict";
function Person(name) { this.name = name; }
let ferdinand = Person("Ferdinand"); // forgot new
// → TypeError: Cannot set property 'name' of undefined
```

Без `"use strict"` this будет ссылаться на глобальную область видимости, т.е. `this` будет `window` в браузере.

```js
function Person(name) { this.name = name; }
let ferdinand = Person("Ferdinand"); // oops
console.log(name);
// → Ferdinand
```

Т.е. у нас появилось не предвиденная нами переменная `name` в глобальной области видимости.

К счастью, конструкторы объявленные внутри class не будут иметь эту проблему.

Строгий режим запрещает также в одной функции использовать несколько параметров с одинаковыми именами.