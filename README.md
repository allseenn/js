# JavaScript Basics

This repo contains my JS code from lectures and labs by GeekBrains online university.

## 01. Lecture

### Intro

01.Lecture

**HTML** - язык разметки для веб-страниц

**CSS** - язык оформления HTML

**JS** - язык программирования или движок для веба и бекенда

### Движки

- V8
- Rhino
- SpiderMonkey
- JSC
- Chakra

Движки написаны на C++. Они интерпретируют скрипты на JS. Как правило движки встроены в прикладное ПО:

- Браузеры
- Node.js, Electron, React Native, Deno
- ПО для встраиваемых систем (роботы, Falcon 9, Iskra)

В свою очередь прикладное ПО работает в системных средах:

- Браузер установленный на десктопные OC (Windows, Linux, macOS)
- Node.js, Electron установленные на серверные OC (Windows, Linux, FreeBSD, macOS)
- Киоски (банкоматы, терминалы оплаты и т.д.) - легкая версия ОС с браузером

### Стандарты

ECMA international - European Computer Manufacturers Association - Европейская ассоциация по стандартизации компьютерного производства.

Наиболее известные стандарты ECMA Inc.:

- ECMA-376 (OOXML) - Office Open XML
- ECMA-119 (ISO9660) - формат CD-ROM и DVD-ROM
- ECMA-267 (UDF) - перезаписываемый формат CD-ROM и DVD-ROM
- ECMA-262 (ECMAScript) - язык программирования JavaScript

ECMAScript состоит из релизов:

- ...
- ES5
- ES6
- ES2022
- ES6+ - современный JS

### Этапы выполнения кода в браузере

1. Создается структура HTML-документа
2. Применяются стили
3. Добавляется контент (картинки, мультимедиа)
4. К странице подключается скрипт и выполняется

Браузер начинает выполнять JS-код в момент обнаружения его в html, поэтому рекомендуется помещать его в конце документа. Либо использовать специальные атрибуты.
Если произошла ошибка в коде, то браузер выдает сообщение в консоли, но продолжает загрузку контента, html и дальнейшего JS-кода.
Код выполнятся даже после того как все загрузилось, все время пока страница открыта.

### Операторы

#### Унарные операторы

- `-a` - Унарный минус (отрицательное число)
- `+a` - Унарный плюс  (приведение к числу)
- `a++` - Инкремент
- `a--` - Декремент
- `~a` - Побитовое отрицание
- `^a` - Побитовая инверсия (исключающее или)
- `!a` - Логическое отрицание
- `&a` - Побитовое И
- `|a` - Побитовое ИЛИ
- `<<a` - Побитовый сдвиг влево
- `>>a` - Побитовый сдвиг вправо
- `a.b` - Оператор доступа к свойству объекта (точка)
- `...a`- rest или spread операторы
- `a, b -` Оператор разделения элементов или вычисления выражений
- void - оператор пустого значения - возвращает undefined
- new - оператор создания объекта
- typeof - оператор получение типа объекта
- delete - удаление и возврат true, false в случае успеха, неуспеха

#### Бинарные операторы

- `a + b` - Сложение
- `a - b` - Вычитание
- `a * b` - Умножение
- `a / b` - Деление
- `a % b` - Остаток от деления (модуль)
- `a = b` - Оператор присваивания
- `a?.b` - Оператор опциональной цепочки
- `a ** b` - Возведение в степень
- `'a'+'b'`- Конкатенация
- `a && b` - Логическое И
- `a || b` - Логическое ИЛИ
- `a ^ b` - Исключающее ИЛИ
- `a in b` - Проверка наличия свойства в объекте
- `a of b` - В циклах for..of
- `a ?? b` - Нулевое слияние (Nullish Coalescing Operator) - удобен для задания значений по умолчанию. В нем берется правая часть, если слева null или undefined
- `a == b` - Сравнение по значению
- `a === b` - Сравнение по значению и типу
- `a != b` - Сравнение по значению
- `a !== b` - Сравнение по значению и типу
- `a > b` - Сравнение по значению
- `a < b` - Сравнение по значению
- `a >= b` - Сравнение по значению
- `a <= b` - Сравнение по значению

#### Тернарный оператор

- `a ? b : c`

Операторы сравнения, тернарный оператор,  возвращают булево значение: true, false

### Приоритет операторов

| Приоритет | Оператор | Описание |
| --- | --- | --- |
| 1 | `()` | Группировка выражений |
| 2 | `.` `[]` | Доступ к свойствам и индексам |
| 3 | `new` | Создание объектов |
| 4 | `++` `--` | Инкремент и декремент |
| 5 | `!` `~` `+` `-` `typeof` `void` | Унарные операторы |
| 6 | `*` `/` `%` | Умножение, деление и остаток |
| 7 | `+` `-` | Сложение и вычитание |
| 8 | `<<` `>>` `>>>` | Битовые сдвиги |
| 9 | `<` `<=` `>` `>=` | Сравнения |
| 10 | `==` `!=` `===` `!==` | Проверка равенства |
| 11 | `&` | Битовая операция И |
| 12 | `^` | Битовая операция XOR |
| 13 | `\|` | Битовая операция ИЛИ |
| 14 | `&&` | Логическое И |
| 15 | `\|\|` | Логическое ИЛИ |
| 16 | `?:` | Условный оператор |
| 17 | `=` `+=` `-=` `*=` `/=` `%=` `**=` | Присваивание |
| 18 | `,` | Запятая (разделитель выражений) |

### Переменные

- let
- const
- var

#### let и const

Ключевые слова let и const появились в ES2015:

- let для объявления переменных с блочной областью видимости

```js
let age = 10;
age = 15;
```

- const для объявления констант с блочной областью видимости их нельзя изменять

```js
const GAP_SIZE = 10;
GAP_SIZE = 15; // TypeError
```

#### var

До ES5 с помощью ключевого слова **var** инициализировали переменные. В современном релиза **var** осталась, но используется немного по другому:

1. Для объявления глобальных переменных.
2. Для инициализации переменной без присвоения значения:

```js
var a;
```

Значением переменной **a** будет **undefined**.

### Всплытие

**Hoisting** (всплытие) - уникальный механизм JS, позволяющий обращаться к значению переменной до ее объявления с помощью **var**. Значением при всплытии такой переменной будет undefined.

```js
console.log(age); // undefined
var brotherAge = age + 12
console.log(brotherAge) // Nan
var age = 10

console.log(name)
let name = "Ivan" // Uncaught ReferenceError
```

### Типы данных

В JS есть 8 типов данных:

1. string (строка) - неизменяемый примитив
2. number (число) - неизменяемый примитив
    - Infinity (бесконечность)
    - NaN (Not A Number)
3. bigInt (большое число) - неизменяемый примитив
4. boolean (булев) - неизменяемый примитив
    - true
    - false
5. symbol (символьный) - неизменяемый примитив
6. undefined (неопределенный) - неизменяемый примитив
7. null (нуль) - неизменяемый примитив, но при проверке указывает на то, что это объект
8. object (объект) - изменяемые типы данных
   - array (массив)
   - function (функция)

Примитивные типы данных в JavaScript не являются объектами и не имеют методов или свойств. Однако, когда вы пытаетесь использовать метод или свойство примитивного типа данных, JavaScript автоматически оборачивает его в объект, чтобы предоставить доступ к методам и свойствам.
Например, когда вы пытаетесь использовать метод toUpperCase() на строке, JavaScript оборачивает строку в объект String и предоставляет доступ к методу toUpperCase().

Для определения типа данных используют typeof:

```js
console.log(typeof 10); // number
```

Все типы данных отличаются:

- встроенными методами
- методами сравнения

#### 1. string

Строка это текст в кавычках (одинарных, двойных или обратных):

```js
let name = "Ivan";
let lastName = 'Petrov';
let fullName = `Ivan Petrov`;
```

#### Шаблонный литерал

Строки внутри обратных кавычек называют **шаблонным литералом**

#### 2. number

**Number** - это целое или дробное число, как в десятичной так и в других системах счисления, включая шестнадцатеричную. Для чисел есть ограничения от -2^53 до 2^53 не включительно.

Есть специальны значения, которые также имеют тип **number**:

- Infinity
- -Infinity
- NaN

##### Infinity

Infinity, это число, которе получается в математических операциях, типа деления на ноль.

```js
10 / 0 // Infinity
```

##### NaN

NaN поглощает арифметические операции, которые не могут быть выполнены, например операция нат разными типами данных.

```js
5 - '5' // NaN
```

#### 3. bigInt

Супербольшие целые числа. Они записываются как обычные целые, только в конце есть литера n:

```js
let bigNum = 9007199254740991n;
console.log(typeof bigNum); // bigint
```

Используются например для меток времени с микросекундами.

#### 4. boolean

**Boolean** - это логический тип данных, который может иметь два значения: **true** и **false**.

#### 5. Symbol

**Symbol** - это встроенный тип данных, который используется для создания уникальных идентификаторов. Даже при одинаковых значениях они будут различаться.

```js
let id1 = Symbol("test");
let id2 = Symbol("test");
console.log(id1 === id2); // false
```

Добавлен в ECMASCript 2015.

#### 6. undefined

**undefined** - значение не определено, как правило при пустой инициализации переменной или при возвращении функций без ключевого слова return.

```js
let name;
console.log(name); // undefined
```

#### 7. null

**null** - примитив, который возвращает **object**. [Неустранимый баг JS](https://habr.com/ru/sandbox/200708/)

```js
let name = null;
console.log(typeof name); // object
```

Null часто используют в API и при работе с DOM, когда ожидают возврата объекта, но возвращается null.

null и undefind имеют одинаковый смисл но разный тип данных

#### 8. object

Набор данных, к которым можно обратиться по имени объекта через точку:

```js
let person = {
    name: 'Ivan',
    age: 10
}
console.log(person.name); // Ivan
```

Или через квадратные скобки по ключу:

```js
console.log(person['name']); // Ivan
```

Объекты задаются пользователям, но есть 2 типа данных, которые являются встроенными объектами:

- Array
- Function

##### array

Массив это список значений, которые можно обратиться по индексу, он может хранить неограниченное количество значений.

```js
let arr = [1, 2, 3];
console.log(arr[0]); // 1
```

##### function

Функция - имеет свои методы и свои свойства. Она может быть сохранена в переменную или передана в качестве значения другому объекту.

Например, встроенный методе toString() возвращает строковое представление функции.

```js
const add = function(a, b) {
    return a + b;
}

console.log(add.toString()); // function add(a, b) { return a + b; }
```

Встроенные методы объектов, могут быть переопределены.

## 03. Lecture

### Приведение типов

#### Явное приведение типов

```js
let number = 10;
let string = number.toString();
console.log(typeof string); // string
```

#### Неявное приведение

```js
let number = 10;
let string = '10';
console.log(number + string); // 1010
```

Арифметические операции кроме сложения всегда приводят типы к одному.

#### Булево приведение

При приведении к булеву типу, у следующих значений будет **false**:

- ""
- 0, -0, NaN
- null
- undefined
- false

При приведении к булеву типу, у следующих значений будет **true**:

- "Hello"
- 42
- {} - объекты
- [] - массивы
- function foo() { ... } - функции

Булево приведение происходит автоматически при условных операторах.
Любой тип данных можно привести к булеву с помощью отрицания !. Но, чтобы не было инвертированного значения, можно использовать два отрицания !!.

```js
let value = 1;
console.log(!!value); // true
```

### Равенства

**==** нестрогое равенство, при котором происходит приведение типов:

```js
let a = 10;
let b = "10";
console.log(a == b); // true
```

**===** строгое равенство, при котором не происходит приведение типов и происходит сравнение типов данных:

```js
let a = 10;
let b = "10";
console.log(a === b); // false
```

Движки JS приводят типы по умолчанию к числу, поэтому нестрогое сравнение пустых массивов false, а сравнение тех же массивов, но с отрицанием true.
А вот сравнение пустого массива и инвертированного, тоже true:

```js
[] == []; // false
![] == ![] // true
[] == ![]; // true
// Потому, что:
+[] // 0 - в соответствии с правилами приведения выше пустой массив это false => +false = 0
![] // false - в соответствии с таблицей [] = true => !true = false => +false = 0
// 0 == 0 is true
```

Непустые объекты или непустые массивы между собой сравниваются по ссылкам, не сравнивая значения. Но, если сравнить объект с примитивом, то объект приводится к конкретному примитиву.

### Сравнения

Когда сравниваются строки, то это происходит посимвольно, слева направо:

```js
let a = '43';
let b = '42';
console.log(a > b); // true
```

Такое сравнение называют - **лексикографическим**.

В JS нет строго сравнения типа (>>), как это есть у равенств. Поэтому, у сравнений происходит приведение типов:

Если при приведении строка не может быть преобразована в число, то возвращается NaN, который не может быть ни больше, ни меньше. Поэтому при сравнении c участием NaN, всегда возвращается false.

```js
let a = 10;
let b = '9cc';
console.log(a > b); // false
```

#### Ленивые вычисления

short-circuit evaluation - по аналогии с "коротким замыканием" в электронике, где ток течет по наименьшему сопротивлению. Аналогично при ленивом вычислении логических операторов (&& и ||) в JavaScript (и других языках), при котором второй операнд вычисляется только при необходимости.

### Проверки и приведение

Если переменная не пустая строка "" и не ноль 0:

```js
let a = "John";
if (a) {
    console.log(a);
}
```

Чтобы привести число к строке можно сложить его с пустой строкой:

```js
let a = 10;
console.log("" + a); // "10"
```

Проверка в условии пустой ли массив:

```js
let a = [];
if (a.length) {
    console.log(a);
}
```

### Методы ввода

У объекта window есть методы ввода:

1. windows.alert()
2. window.prompt()
3. windows.confirm()

Т.е. window - это глобальная область видимости, то методы можно указывать без window.
Методы вызывают диалоговые окна в браузере, которые нельзя изменить и определить их положение.

### Условные конструкции

Условие - любое выражение возвращающее болевое значение (true или false). Если условие верно, то выполняется блок кода, иначе - нет. Если выражение условия возвращает не булевый тип, то он будет приведен к булевому.

false:

- ""
- 0, -0, NaN
- null
- undefined

true:

- любое другое значение

#### Условный тернарный оператор

```js
let a = 10;
let b = 20;
let c = a > b ? a : b;
console.log(c); // 20  
```

#### Switch

```js
let a = 10;
switch (a) {
    case 10:
        console.log('10');
        break;
    case 20:
        console.log('20');
        break;
    default:
        console.log('default');
        break;
}
```

### Комментарии

```js
// однострочный комментарий
/* многострочный комментарий */
```

### Консоль браузера

CTRL+SHIFT+C - открыть инструменты разработчика
CTRL+SHIFT+I - открыть инспектор
CTRL+SHIFT+J - открыть консокль

## 05. Lecture

### Функции

Функция это кусок кода (программы), которая являются объектным типом данных.

#### Функции конструкторы

JS пишутся с большой буквы:

- Number() - конвертирует аргумент в число
- String() - в строку
- Boolean() - к булеву типу

Могут быть использованы как обычные функции или [конструкторы](#конструктор-объекта) с оператором new.

#### Именование функций

Функции должны начинаться с глагола и с маленькой буквы.

```js
function getSum(a, b) {
    return a + b;
}
```

Не нужно давать слишком длинные имена функциям, типа **getSumOfTwoNumbers**

С большой буквы именуются функции-конструкторы

#### Классификация по всплытию (hoisting)

- Невсплывающие (Анонимные) функции
- Всплывающие (Именованные) функции

##### Невсплывающие функции

**Анонимные** функции используют **функциональное выражение**, где функция создается в момент выполнения данного выражения

```js
const sum = function(a, b) {
    return a + b;
};
```

##### Всплывающие функции

**Именованные** функции используют **декларативное объявление**, где функция создается до основной компиляции кода, т.е. всплывает вверх. Поэтому такая функция может быть расположена в конце кода, а вызываться в начале.

```js
function sum(a, b) {
  return a + b;
}
```

#### По возвращаемому значению

- Возвращающие значение
- Не возвращающие значение (всегда возвращает undefined)

#### По параметрам

- С обязательными параметрами
- С опциональными параметрами
- Без параметров

**Параметр функции** - это имя переменной, которое находится внутри скобок после имени функции.

**Аргумент функции** - это значение передаваемое параметру функции.

##### Обязательные параметры

JS-это не строгий язык, т.е. можно передать несколько параметров, но не все параметры будут использоваться.

```js
const minus = (a, b) => {
    return a - b;
}
console.log(minus(10, 5, 8, 9)); // 5
```

Если же передать меньше параметров, то недостающим параметрам присвоится undefined:

```js
const minus = (a, b) => {
    if (b === undefined) {
        return -a;
    }
    return a - b;
}

console.log(minus(10)); // -10
console.log(minus(10, 5)); // 5
```

В случае отсутствия значения параметра b, выполнится условие if.

##### Опциональные параметры

Если написать = (равно), после параметра, то данный параметр будет иметь значение по умолчанию:

```js
const minus = (a, b = 0) => {
    return a - b;
}
console.log(minus(10)); // 10
console.log(minus(10, 5)); // 5
```

#### По наличию побочного эффекта

- Чистые функции
- Функции с побочным эффектом
- Гибридные функции

##### Чистые функции

Чистая функция:

- не контактирует с глобальными переменными
- не связаны со сторонними побочными эффектами от других функций
- получает данные только чрез аргументы
- возвращает одно и тоже (ожидаемое) значение
- легко переиспользуемы в других местах или коде

При создании чистой функции следует быть внимательным к изменяемым типам данных, например объектам,
т.к. свойства объекта легко изменить извне, следует создавать копию объекта внутри функции:

```js
const addPropToObj(object, key, value){
    return {
        ...object,
        [key]: value
    }
}
```

Функции без побочных эффектов, как правило возвращают значение:

```js
const sum = (a, b) => {
    return a + b;
}
```

##### Функции с явными побочными эффектами

```js
const sum = (a, b) => {
    console.log(a + b);
}
```

Нечистые функции использующие **побочные эффекты** - получение данных по сети или из БД, тоже нужны и без них нельзя. Но, нужно стараться по максимуму использовать чистые, а обращения по сети и к БД выносить в грязные функции.

##### Гибридные функции

```js
const sum = (a, b) => {
    console.log(a + b);
    return a + b;
}
```

### Классификация по способу объявления

- Декларативные функции
- Функциональные выражения
- Стрелочные функции

#### Декларативные функции

Декларативная функция состоит:

- ключевого слова function
- имени функции
- параметров
- тело функции

```js
function sum(a, b) {
    return a + b;
}
```

Декларативно объявленные функции могут не завершаться точкой с запятой.

Декларативные функции могут быть объявлены раньше вызывающего их кода. Причину смотри в **Hoisting** всплытии функции.

#### Функциональное выражение

Функциональное выражение состоит:

- ключевого слова function
- параметров
- тело функции

```js
const sum = function(a, b) {
    return a + b;
}
```

Функциональные выражения часто присваивают переменной.

#### Стрелочные функции

В ES2015 появились стрелочные функции, в них убрано ключевое слово function, они состоят:

- параметров
- стрелки
- тело функции

() => {}

```js
const sum = (a, b) => 
{
    return a + b;
}
```

Можно устанавливать параметры по умолчанию:

```js
const sum = (a = 0, b = 0) => 
{
    return a + b;
}
```

Если параметр функции один, то можно убрать скобки:

```js
const square = a => 
{
    return a * a;
}
```

Но, если параметров нет вообще, то пустые скобки нужны:

```js
const square = () => 
{
    return 2 * 2;
}
```

Стрелочной функции нельзя присвоить имя типа sum(), ее можно присвоить переменной.

##### Неявный возврат

Если функция возвращает одно выражение, то можно убрать фигурные скобки и ключевое слово return (неявный возврат):

```js
const square = () => 2 * 2;
```

Вид стрелочной функции с неявным возвратом: `() =>`

##### Стрелочная функция с одним параметром без скобок

Если стрелочная функция имеет один параметр, то можно убрать скобки:

```js
const square = a => a * a;
```

Вид стрелочной функции с параметром без скобок: `=>`

#### Наращиваемые функции

Может использоваться как отдельная фукнция или в составе других функций, наращивая их фукнционал:

```js
function zeroPad(number, width) {
  let string = String(number);
  while (string.length < width) {
    string = "0" + string;
  }
  return string;
}

function printFarmInventory(cows, chickens, pigs) {
  console.log(`${zeroPad(cows, 3)} Cows`);
  console.log(`${zeroPad(chickens, 3)} Chickens`);
  console.log(`${zeroPad(pigs, 3)} Pigs`);
}

printFarmInventory(7, 16, 3);
// Output:
// 007 Cows
// 016 Chickens
// 003 Pigs
```

### Стек вызовов

ОЗУ в JS делится на 3 вида памяти:

- Стековая память (stack memory) - специализированная область памяти, предназначенная для хранения стека вызовов
- Динамическая память (dynamic memory) - область памяти, которая может быть выделена и освобождена динамически во время выполнения программы
- Куча (heap) - область памяти, которая используется для хранения данных, которые не имеют фиксированного размера

Стековая память используется для хранения **стека вызовов**

Когда вызывается функция, она добавляется на вершину стека вызовов, если внутри нее выполняется еще функция, то следующая добавляется выше и т.д.
Когда функция завершает свое выполнение, она удаляется из вершины стека и так до тех пор пока стек не освободится.

Если вызовов функций слишком много, например в случае неправильной рекурсии, то стек будет переполнен и программа завершится с ошибкой: **Maximum call stack size exceeded**

### Область видимости

- Глобальная область видимости
- Область видимости функции
- Область видимости блока
- Вложенная область видимости

Глобальные переменные являются свойствами объекта window для браузера или объекта global для Node.js

### Лексический контекст

Лексический контекст или окружение - это область видимости, которая определяется местом объявления переменной. Она имеет следующие правила:

1. Глобальные переменные видны во всех областях видимости
2. Все переменные любых локальных областей видят глобальную область
3. Переменные и объекты в локальной области видят все вложенные в нее области видимости

Каждый раз при вызове любой функции создается структура данных похожих на объект - **лексический контекст. Данная структура содержит все переменные функции и вне ее, к которым она будет обращаться:

```js
const lastName = "Petrov"
// lexical env: { lastName: "Petrov" }
function getFullName(firstName) {
    // lexical env: { lastName: "Petrov", firstName: <будет определено в момент запуска функции> }
    const fullName = firstName + " " + lastName;
    // lexical env: { lastName: "Petrov", firstName: <будет определено в момент запуска функции>, fullName: <будет вычислено в момент запуска функции> }
    return fullName;
}

getFullName("Ivan"); // "Ivan Petrov"
// lexical env в момент вызова стал таким: { lastName: "Petrov", firstName: "Ivan", fullName: "Ivan Petrov" }
```

Когда функция определена но, не выполнена, в ее лексическом контексте нет многих переменных, но есть для них задел (ключи). В момент запуска функции пробелы заполняются значениями.

#### Неправильное использование контекста

```js
const houses = [];

let i = 0;
while (i<10){
    let house = function(){
        console.log(i); // вывод номера дома по порядку
    }
    houses.push(house) 
    i++;
}

houses[0](); // 10 
houses[9](); // 10
```

Видим, что первый дом имеет номер 10 и последний тоже. Это потому-что лексический контекст общий у всех функций в массиве. Контекст содержит общую переменную i, которая к концу цикла выросла до 10. А т.к. вызов функций происходит мосле цикла, то они все видят десятку: `{ i: 10 }`

Для исправления ситуации нужно номер дома (текущее значение i) сохранять внутри блока цикла:

```js
const houses = [];

let i = 0;
while (i<10){
    let houseNumber = i
    let house = function(){
        console.log(houseNumber); // вывод номера дома по порядку
    }
    houses.push(house) 
    i++;
}

console.log(houses[0]()); // 0
```

Или еще глубже, в теле функции.

### Замыкания

Возможность передавать функцию как значение, плюс факт того, что каждый раз при вызове одной и тоже функции внутри области видимости каждого вызова создаются независимые переменные, открывает побочный эффект - **замыкание** (closures):

```js
function makeCounter() {
    let count = 0;
    return () => count++;
}
const counter = makeCounter();
console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2
```

Тут стрелочная функция которая имеет доступ к внешней переменной count называется замыканием.
Легко сравнить замыкание как функцию которая запускается в среде окружения, в которой уже задана некая переменная, причем эта среда активируется именно в том месте из которого запустили замыкание.

Этапы создания замыкания:

- создать функцию
- внутри объявить замкнутые переменные
- вернуть из функции функцию

Замыкания очень полезны:

1. для кеширования или хранилищ данных, защищенных из внешнего кода
2. скрытие переменных в модулях (когда подключено несколько скриптов с одинаковыми именами)
3. создание счетчиков

#### 1. Кеширование

Функция вычисляющая квадрат числа и сохраняющая результат в кэше:

```js
function closureFunction{
    const cache = {};
    return (x) => {
        if (cache[x]) return cache[x];
        const result = x * x;
        cache[x] = result;
        return result;
    }
}

const square = closureFunction();

console.log(square(5)); // 25
console.log(square(5)); // 25
```

#### 2. Модули

```js
(function (){
    const sliderTexts = ['Promo', 'Brands', 'Best'];
    function showSlider(text){
        console.log(text[0]);
        console.log(text[1]);
        console.log(text[2]);
    }
    showSlider(sliderTexts);
}());
```

Данная функция сразу вызывается и исполняется. Переменная sliderTexts - не видна другим и может быть переиспользована.

#### 3. Счетчики

```js
const createCounter = () => {
    let count = 0;
    return () => count++;
}

const counter = createCounter();

console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2
```

#### Недостатки замыканий

Каждый раз при новом вызове любой функции создается лексическое окружение, которе удаляется после выполнения функции. Т.к. часто для замыкания присваивают некой переменной функцию, в результате лексическое окружение остается в памяти, до завершения работы программы или до закрытия браузера, т.к. наличие ссылки (переменной) на функцию препятствует удалению лексического окружения и замкнутых в нем переменных. Поэтому большое количество замыканий приводит к утечке памяти.

### Рекурсия

Функция которая сама себя вызывает называется **рекурсивная функция**

Рекурсию применяют для воспроизведения повторяющихся действий:

1. Для обхода вложенной структуры дерева каталога или документа (DOM)
2. Для математических вычислений, которые поддаются разбиению типа:
   **Сложное вычисление = простая операция, примененная к вычислению попроще**
   $2^{10} = 2^9 \times 2 => b^{e} = b^{e-1} \times b$

```js
function power(base, exponent){
    if (exponent === 0) { // Главное задавать условие выхода иначе будет бесконечная рекурсия
        return 1;
    } else {
        return base * power(base, exponent - 1);
    }
}
console.log(power(2, 3)); // 8
```

Данная реализации вычисления степени числа в три раза медленнее чем вариант с циклом.

### Браузерные события

У HTML-тегов есть атрибут onclick, который выполняет код при нажатии мышью по тегу.

Для того чтобы не писать длинные инструкции в атрибуте onclick, можно использовать функцию-обработчик:

```html
<button onclick="buy()">Buy</button>
<script>
    function buy() { 
        alert('Congratulations! You have bought a good!');
        alert('Good luck!'); 
    }
</script>
```

## 07. Lecture

### Циклы

Цикл - набор инструкций, который выполняется несколько итераций до удовлетворения условий выхода.

Тело цикла - набор инструкций.

Итерация - повторение тела цикла.

Условие выхода из цикла - условие, при котором цикл завершается.

#### Цикл while

Цикл с предусловием:

```js
let i = 0;
while (i < 10) {
    console.log(i);
    i++;
}
```

Очень удобен для бесконечных циклов.

#### Цикл do-while

Цикл с постусловием:

```js
let i = 0;
do {
    console.log(i);
    i++;
} while (i < 10);
```

Тело цикла проверяется на условие после выполнения. Следовательно минимум один раз цикл выполнится. Полезно например при вводе пароля, а потом его проверки до тех пор пока не введут верный.

#### Цикл for

Цикл с инициализацией, условием и инкрементом:

```js
for (let i = 0; i < 10; i++) {
    console.log(i);
}
```

Самый популярный цикл.

#### Прерывание цикла

Выход из цикла происходит:

- если условие выхода из цикла возвращает **false**
- если встречается инструкция **break**

Выход из итерации цикла, но не выход из цикла:

- при достижении конца тела цикла, если условие выхода из цикла возвращает **true**
- если встречается инструкция **continue**

### Массивы

Имя массива (переменная) - это указатель на область памяти объекта. Т.к. массив это наследник объекта:

```js
typeof [] // object
```

Чтобы случайно не переименовать или удалить имя массива делают константным, элементы массива все еще могут быть изменены:

```js
const arr = [1, 2, 3];
arr[0] = 10;
console.log(arr); // [10, 2, 3]
```

Элементы массива хранятся как значения свойств объекта. А индексы как ключи свойств объекта.
К свойствам любого объекта можно обращаться через точечную нотацию или квадратные скобки. Но, обращаться используя точечную нотацию можно только свойствам (переменным), которые начинаются с буквы или символа подчеркивания и не имеют пробелов, т.е. в имена переменных не могут быть только цифрами, иначе нужно обращаться через квадратные скобки:

```js
value[2] // нельзя value.2
value["John Doe"] // нельзя value.John Doe
```

Поэтому для доступа к элементам массива, как наследнику объекта, нельзя обращаться через точечную нотацию - индексы нужно обрамлять квадратными скобками.

#### length

Как и строки, массив имеет свойство **length** - количество элементов в массиве.

К свойствам массива можно обращаться через скопобную нотоацию:

```js
arr.['length']
```

У массивов помимо встроенных свойств есть методы - это свойства, которые содержат функции.

#### toUpperCase

```js
const arr = ["one", "two", "three"];
arr.toUpperCase(); // ["ONE", "TWO", "THREE"]
```

#### concat

Конкатенация массивов:

```js
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const arr3 = arr1.concat(arr2);
console.log(arr3); // [1, 2, 3, 4, 5, 6]
```

Вторым и далее аргументами concat() можно передать любой примитив или объект и они будут добавлена справа от первого массива:

```js
const arr3 = arr1.concat(arr2, {key: 1}, "string", [10, 11, 12]); 
console.log(arr3); // [ 1, 2, 3, 4, 5, 6, { key: 1 }, 'string', 10, 11, 12 ]
```

#### push

Добавление одного или нескольких элементов в конец массива (похож unshift):

```js
const arr = [1, 2, 3];
arr.push(4, 5);
console.log(arr); // [1, 2, 3, 4, 5]
```

#### unshift

Добавляет один или несколько элементов в начало массива (похож push):

```js
const arr = [1, 2, 3];
arr.unshift(4, 5);
console.log(arr); // [4, 5, 1, 2, 3]
```

#### pop

Извлекает и удаляет последний элемент массива (похож на shift):

```js
сonst arr = [1, 2, 3];
console.log(arr.pop()); // 3
console.log(arr); // [1, 2]
```

#### shift

Удаляет первый элемент массива, сдвигая все остальные элементы влево (похож на pop):

```js
const arr = [1, 2, 3];
arr.shift();
console.log(arr); // [2, 3]
```

#### slice

Скопировать массив, путем копирования его имени переменной, создаст вторую ссылку на один и тот же массив.

Копирует часть или весь массив:

```js
const arr = [1, 2, 3, 4];

const all = arr.slice();
console.log(all); // [1, 2, 3, 4]

const start = arr.slice(1);
console.log(start); // [2, 3, 4]

const overload = arr.slice(14);
console.log(overload); // []

const minus = arr.slice(-2);
console.log(minus); // [3, 4]

const range = arr.slice(1, 3);
console.log(range); // [2, 3]

const startMinus = arr.slice(1, -1);
console.log(startMinus); // [2, 3]
```

#### splice

Удаляет элементы массива:

```js
const arr = [1, 2, 3];
arr.splice(1, 2);
console.log(arr); // [1, 3]
```

Метод splice может использоваться для полного клонирования массива:

```js
const arr = [1, 2, 3];
const arr2 = arr.splice();
console.log(arr2); // [1, 2, 3]
```

Также для клонирования, т.е. создания полной копии массива может использоваться метод высшего порядка map:

```js
const arr = [1, 2, 3];
const arr2 = arr.map(item => item);
console.log(arr2); // [1, 2, 3]
```

#### indexOf

Метод возвращает индекс первого искомого вхождения (самого левого) элемента в массиве:

```js
const arr = [1, 2, 3];
console.log(arr.indexOf(2)); // 1
console.log(arr.indexOf(5)); // -1
```

Если элемент не находится в массиве, то возвращается -1.

В методе можно указать второй параметр, который определяет с какого индекса начать поиск:

```js
const arr = [1, 2, 3];
console.log(arr.indexOf(2, 1)); // 1
```

#### lastIndexOf

Метод возвращает индекс последнего искомого вхождения (самого правого) элемента в массиве:

```js
const arr = [1, 2, 3, 2];
console.log(arr.lastIndexOf(2)); // 3
console.log[arr.lastIndexOf(5)]; // -1
```

Метод, как и indexOf имеет второй необязательный параметра, место к которого начать поиск.

#### reverse

Метод переворачивает массив:

```js
const arr = [1, 2, 3];
arr.reverse();
console.log(arr); // [3, 2, 1]
```

#### includes

Метод возвращает true если в массиве есть искомый элемент:

```js
const arr = [1, 2, 3];
console.log(arr.includes(2)); // true
```

#### sort

Метод сортирует массив:

```js
const arr = [3, 2, 1];
arr.sort();
console.log(arr); // [1, 2, 3]
```

#### join

```js
console.log(['H', 'e', 'l', 'l', 'o'].join(" ")); // H e l l o  
```

#### Массивы с циклами

Цикл очень часть используется при работе с массивами:

##### for

```js
const arr = [1, 2, 3];

for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}
```

##### for of

Цикл для массива можно записать короче:

```js
for (let item of arr) {
   console.log(item); 
}
```

Цикл был разработан для решения проблемы **сурогатных пар** (см. строки), позволяет итерироваться по знакам занимающим две символьные единицы:

```js
let roseDragon = "🌹🐉";
for (let char of roseDragon) {
  console.log(char);
}
// → 🌹
// → 🐉
```

##### forEach

```js
arr.forEach(item => console.log(item));
```

### Строки

Строки - это примитивы. Поэтому, при работе с ними происходит приведение типов.

Кодовая единица (code unit) для одного символа в строке составляет 2 байта и он закодирован в UTF-16.
Некоторые символы выходящие за 16-битный диапазон хранятся как два символа и называются **суррогатными парами**
При обращении к методам строки, происходит оборачивание строки в объект.

```js
console.log(characterScript(121));

const emoji = "😊";

console.log(emoji.length); // ❗ 2, а не 1
console.log(emoji.charCodeAt(0)); // d83d (старший суррогат)
console.log(emoji.charCodeAt(1)); // de0a (младший суррогат)
console.log(emoji.codePointAt(0)); // полноценный суррогат
console.log(emoji[0]);  // � (неправильный символ)
```

При попытке добавить новый метод, ничего не получится в отличие от объекта.

```js
let kim = "Kim";
kim.age = 88
console.log(kim); // undefined
```

Но, встроенных методов предостаточно.

#### charCodeAt

Выводит в примере выше только кодовую единицу, т.е. старший суррогат

#### codePointAt

Возвращает полноценный Unicode суррогат. Метод был разработан когда встала проблема **суррогатных пар**

#### slice()

```js
let str = 'Hello';
console.log(str.slice(1, 3)); // el
```

#### substr

```js
let str = 'Hello';
console.log(str.substr(1, 3)); // ell
```

#### substring

```js
let str = 'Hello';
console.log(str.substring(1, 3)); // el
```

#### replace

```js
let str = 'Hello';
console.log(str.replace('l', 'L')); // HelLo
```

#### split

Создает массив из строки по указанному разделителю:

```js
let str = 'Hello';
console.log(str.split('')); // ['H', 'e', 'l', 'l', 'o']
```

#### charAt

```js
let str = 'Hello';
console.log(str.charAt(1)); // e
```

#### indexOf()

```js
let str = 'Hello';
console.log(str.indexOf('ll')); // 2
```

В отличие от одноименного метода массива, для строки можно указывать несколько символов для поиска

#### length

```js
let str = 'Hello';
console.log(str.length); // 5
```

#### toUpperCase

```js
let str = 'Hello';
console.log(str.toUpperCase()); // HELLO
```

#### toLowerCase

```js
let str = 'Hello';
console.log(str.toLowerCase()); // hello
```

#### trim

Удаляет крайние пробелы, переносы строк, табуляцию и однотипные символы:

```js
let str = '   Hello   ';
console.log(str.trim()); // Hello
```

#### padStart

Дополняет строку до указанного количества символов в строке:

```js
let str = 'Hello';
console.log(str.padStart(10, '0')); // 00000Hello
```

#### repeat

Повторяет строку указанное в параметре метода количество раз:

```js
let str = 'Hello';
console.log(str.repeat(3)); // HelloHelloHello
```

## 09. Lecture

### Объекты

Правила создания объектов:

1. Объекты объявляются с помощью ключевого слова **const**.
2. Определение (тело) объекта заключается в фигурных скобках. Фигурные скобки обрамляют также начало и конец блока инструкций, например функции. Встречаются случаи когда надо явно отличить функцию от объекта:
   `n => { prop: value } // treated as function`
   `n => ({ prop: value }) // treated as object`
3. Имя (ключ) свойства отделяется от значения свойства двоеточием.
4. Имя свойства может быть любым
5. Объект не может содержать дублирующиеся имена свойств.
6. Все свойства объекта объявляются через запятую.

```js
const user = {
    name: 'John',
    age: 30
};
```

Чтобы заменить значение свойства объекта используют знак равно =:

```js
const user = {
    name: 'John',
    age: 30
};

user.age = 40;
user.lastname = 'Smith';

console.log(user); // {name: "John", age: 40, lastname: "Smith"}
```

Если при присваивании значения свойству через знак равно такого нет, то оно создастся автоматом.

#### Оператор delete

Для удаления свойства объекта применяется оператор **delete**:

```js
delete user.age;
```

При обращении к несуществующему свойству возвращает **undefined**:

```js
console.log(user.age); // undefined
```

Но, есть разница между удалением свойства и присвоением ему **undefined**:

```js
user.age = undefined;
console.log(user.age); // undefined
```

С помощью оператора **in** можно проверить наличие свойства в объекте:

```js
console.log('lastname' in user); // true
console.log('age' in user); // false
```

При сравнении объектов == сравниваются их указатели и проверяется их идентичность, но не содержание.

#### Свойства объектов

Почти все типы данных в JS имеют свойства, за исключением null и underfined. Если обратиться к их свойствам, то получим ошибку:

```js
null.length; // TypeError: Cannot read properties of null (reading 'length')
null["length"]; // TypeError: Cannot read properties of null (reading 'length')
```

Имена свойств объектов это строки.

Обращение к свойству объекта через точку:

```js
const user = {
    name: 'John',
    age: 30
};

console.log(user.name); // John
console.log(user.age); // 30
```

В любой момент можно добавить новое свойство:

```js
const user = {
    name: 'John',
    age: 30
};

user.isAdmin = true;
console.log(user); // {name: "John", age: 30, isAdmin: true}
```

Свойства можно удалять:

```js
const user = {
    name: 'John',
    age: 30
};

delete user.age; // true
console.log(user); // {name: "John"}
```

При успешном удалении свойства возвращается true, иначе false (например защищенный объект браузера).

При указании переменных в качестве аргументов функции передаются только их значения, исходные переменные остаются нетронутыми. При указании имени объекта в качестве аргумента функции передает указатель на этот объект. Поэтому при изменении объекта внутри функции, изменится исходный объект.

##### Короткое присваивание свойств объекта

Если при создании объекта передаются переменные в качестве свойств и без значений, то значения берутся из переменных, а ключами свойств становятся имена переменных.

```js
let event = "hello";
let squirrel = "World";
const obj = {event, squirrel}; // same as - const obj = {event: "hello", squirrel: "World"}
console.log(obj); // { event: 'hello', squirrel: 'World' }
```

##### Опциональное обращение к свойству объекта

Если нет уверенности, что обращение к свойству объекта существует, то можно использовать **?.**:

```js
const user = {
    name: 'John',
    age: 30
};

console.log(user?.name); // John
console.log(user?.lastName); // undefined
```

Можно использовать как точечную нотацию, так и квадратные скобки:

```js
const user = {
    name: 'John',
    age: 30
};

console.log(user?.['name']); // John
console.log(user?.['lastName']); // undefined
```

Данный механизм позволяет избежать выброса исключения при обращении к несуществующему свойству.

#### Пользовательские методы объекта

Методы объекта это свойства которым присвоены функции:

```js
function speak(line){
    console.log(`The ${this.type} rabbit says: ${line}`);
}

let whitRabbit = {type: "white", speak};
let hungryRabbit = {type: "hungry", speak};

whiteRabbit.speak("oh my fur and whiskers")
// The white rabbit says: oh my fur and whiskers
hungryRabbit.speak("got any carrots?");
// The hungry rabbit says: got any carrots?
```

В объекте принято методы объявлять после свойств:

```js
// Объект робот-пылесос
const Roomba = { // Есть негласное правило называть объекты в алгоритмах с большой буквы.
    // Обычно сначала объявляют свойства объекта.
    model: "Romba-1",
    power: 200,
    batterySize: 2100,
    boxSize: 0.5,
    workTime: 45,
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    isUVLampOn: false,
    // После свойств объявляют его методы.
    startCleaning: function () { // увеличивает счетчик стартов робота и выводит сообщение о старте
        this.counterOfStarts++;
        console.log('I am cleaning... I have been started: ', this.counterOfStarts, 'times.');
    },
    goCharge: function () { // отправка на зарядку
        console.log('I am going to charge...');
    },
    switchUVLamp: function () { // вкл.выкл ультрафиолетовой лампы
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    }
};

// Обращение к свойствам объекта.
console.log(Roomba.model); // "Romba-1"
console.log(Roomba.isFull); // false
// Вызов методов объекта.
Roomba.startCleaning(); // 'I am cleaning... I have been started: 1 times.'
// Установим свойства объекта isUVLampOn в true, чтобы продемонстрировать результат работы метода switchUVLamp.
Roomba.switchUVLamp(); // 'UV lamp is working.'
Roomba.goCharge(); // 'I am going to charge...'
```

Методы могут обращаться к свойствам объекта с помощью ключевого слова **this**

#### this

Ключевое слово this означает текущий объект, оно также доступно в любой функции:

```js
// Работа с this
const checkThis = function() {
    console.log(this);
}
checkThis(); // Window {0: global, window: Window, self: Window, document: document, name: "", location: Location, ...}
```

Из лексического контекста данной фукнции видно, что this (текущий объект) ссылается на глобальный объект window, в случае браузера или global в node.js

Внутри методов объекта this указывает на сам объект, в котором он был объявлен:

```js
const checkThisInObject = {
    testProperty: true,
    checkThis: function () {
        console.log(this);
    },
};
checkThisInObject.checkThis(); // {testProperty: true, checkThis: ƒ}
```

Контекст не указывает никаких глобальных объектов, следовательно this - это сам объект, но есть нюансы.

#### Одалживание методов

Создадим улучшенного робота-пылесоса, на основе первого:

```js
// Объект робот-пылесос модель Tango.
const Tango = { 
    model: "Tango-1",
    power: 300,
    batterySize: 3200,
    boxSize: 0.7,
    workTime: 60,
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    isUVLampOn: false,
    // После свойств объявляют его методы. А так как методы у новой модели такие же как и у старой, давайте позаимствуем их у объекта Roomba.
    startCleaning: Roomba.startCleaning,
    goCharge: Roomba.goCharge,
    switchUVLamp: Roomba.switchUVLamp,
};

console.log(Tango.model); // "Tango-1"
console.log(Tango.isFull); // false
// Вызов методов объекта.
Tango.startCleaning(); // 'I am cleaning... I have been started: 1 times.'
// Результат вызова следующего метода зависит от значения, хранящегося в свойстве объекта, а также от того как этот метод был вызван (об этом поговорим чуть ниже).
Tango.switchUVLamp(); // 'UV lamp working.'
Tango.goCharge(); // 'I am going to charge...'
```

Создадим третьего робота, но объекты экспортируем с помощью внешних способов:

```js
const Samba = {
    model: "Samba-1",
    power: 250,
    batterySize: 2500,
    boxSize: 0.5,
    workTime: 50,
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    isUVLampOn: false,
    // На этот раз мы не будем создавать методы в объекте, мы постараемся их заимствовать непосредственно перед использованием.
};

// Одолжим методы из объекта Roomba.
Samba.startCleaning = Roomba.startCleaning;
Samba.switchUVLamp = Roomba.switchUVLamp;
Samba.goCharge = Roomba.goCharge;
Samba.startCleaning(); // 'I am cleaning... I have been started: 1 times.'
// Результат вызова следующего метода зависит от значения, хранящегося в свойстве объекта, а также от того как этот метод был вызван (об этом поговорим чуть ниже).
Samba.switchUVLamp(); // 'UV lamp is working.'
Samba.goCharge(); // 'I am going to charge...'
```

Лампа работает по принципу одной кнопки (вкл/выкл). Сейчас лампа включена
Предположим мы хотим включить лампу по расписанию через пять секунд:

```js
setTimeout(Samba.switchUVLamp, 5000); // 'UV lamp is working.'
```

Но, лампа не выключается. Потому что через 5 секунд объкта Samba уже нет и внутренняя this ссылается несуществующий объект, т.е. undefined.

Можно обернуть метод в анонимную функцию, тогда ссылка на Samba сохраниться в лексическом контексте функции и объект не будет удален:

```js
setTimeout(function() {
    Samba.switchUVLamp();
}, 5000); // 'UV lamp in not working.'
```

Можно вместо анонимной функции использовать методы call, apply или bind

#### Встроенные методы объектов

### call

Метод call позволяет вызвать метод в контексте другого объекта, на примере объекта Roomba:

```js
const notARobot = {
    counterOfStarts: 10,
}

Roomba.startCleaning.call(Roomba); // 'I am cleaning... I have been started: 1 times.'
Roomba.startCleaning.call(notARobot); // 'I am cleaning... I have been started: 10 times.'
```

В последнем вызове метода мы передали с помощью call контекст другого объекта и он выполнился со своим свойством counterOfStarts равным 10. Если в качестве второго и последующих аргументов call что-то передать, то данные параметры пойдут в вызываемый метод

### apply

Аналогичен методу call, только второй параметр передается в виде массива:

```js
Roomba.startCleaning.apply(Roomba, [1, 2, 3]); // 'I am cleaning... I have been started: 10 times.'
```

### bind

Позволяет привязать контекст к фукнции (методу) навсегда:

```js
Samba.startCleaning = Roomba.startCleaning.bind(Samba);
```

Методы можно добавить в объект, путем присвоения функции как значения свойства с ключевым словом function:

```js
const user = {
    make: 'Audi',
    model: "A6",
    year: 2008,
    startEngine: function() {
        console.log('Engine is started');
    }
};

user.startEngine(); // Engine is started
```

Если использовать стрелочную функции внутри объекта, то они не будут видеть объекта, т.к. стрелочные функции не имеют собственного контекста поэтому берется объект на уровень выше, т.е. global. Тут не помогут даже call, apply и bind.

Но, стрелочные функции очень полезны как анонимные внутри самого метода объекта:

```js
const Stand = {
    model: "Stand-1",
    robots: ['Roomba-1', 'Tango-1', 'Samba-1', 'Roomba-2'],
    // Метод, с использованием стрелочной функции в качестве функции обратного вызова.
    startTestingArrow: function() {
        console.log('Start testing...');
        this.robots.forEach((value) => {
            console.log('stand: ', this.model, 'is testing robot: ', value);
        })
    },
    // Метод, с использованием классической функции в качестве функции обратного вызова.
    startTestingClassic: function() {
        console.log('Start testing...');
        this.robots.forEach(function(value) {
            console.log('stand: ', this.model, 'is testing robot: ', value);
        })
    },
};
Stand.startTestingArrow();
// Start testing...
// stand: Stand-1 is testing robot: Roomba-1
// stand: Stand-1 is testing robot: Tango-1
// stand: Stand-1 is testing robot: Samba-1
// stand: Stand-1 is testing robot: Roomba-2
Stand.startTestingClassic();
// Start testing...
// stand: undefined is testing robot: Roomba-1
// stand: undefined is testing robot: Tango-1
// stand: undefined is testing robot: Samba-1
// stand: undefined is testing robot: Roomba-2
```

Получили двойную вложенность в двух методах: startTestingArrow() и startTestingClassic(). Первый метод со стрелочной функцией внутри отработал, т.к. стрелочная функция не имея собственного this ссылается через уровень к свойству model и отрабатывает хорошо. Вот второй метод не отрабатывает как надо, потому что внутри классического метода, классическая функция видит свой контекст и this в нем не видит свойства model в результате возвращается undefined.

#### for in

Цикл for in используется для перебора свойств объекта:

```js
const user = {
    name: 'John',
    age: 30
};

for (let key in user) {
    console.log(key); // name, age - вывод всех ключей свойств объекта
    console.log(user[key]); // John, 30 - вывод всех значений свойств объекта
}
```

#### Объект в массив

У массивов для преобразование его элементов и помещения результатов в новый массив можно использовать метод **map**. Но, у объектов такого метода нет, поэтому для преобразования объекта в массив необходимо использовать методы **Object.values** и **Object.keys**.

##### Object.keys

Для сохранения в массив ключей объекта используется метод **Object.keys**:

```js
const user = {
    name: 'John',
    age: 30
};

const array = Object.keys(user); // ["name", "age"]
```

#### Object.values

Для сохранения в массив значений объекта используется метод **Object.values**:

```js
const user = {
    name: 'John',
    age: 30
};

const array = Object.values(user)); // ["John", 30]
```

#### Object.entries

Для сохранения в массив пар ключ-значение используется метод **Object.entries**:

```js
const user = {
    name: 'John',
    age: 30
};

const array = Object.entries(user); // [["name", "John"], ["age", 30]]
```

Можно было бы использовать для итерации for in по объекту без конвертации в массив, но в итерацию могут попасть наследуемые свойства объектов, включая прототип, при их наличии.

```js
const user = {
    name: 'John',
    age: 30
};

for (let key in user) {
    console.log(key); // name, age, toString, constructor
    console.log(user[key]); // John, 30, [object Object], [object Object]
}
```

Поэтому лучше преобразовывать в массив с помощью Object.keys, Object.values или Object.entries и далее работать с данными внутри массива.

#### Object.assign

Для копирования свойств одного объекта в другой используется метод **Object.assign**:

```js
const user = {
    name: 'John',
    age: 30
};

const clone = Object.assign({}, user); // {name: "John", age: 30}
```

#### Object.freeze

Делает объект неизменным (immutable). После применения этого метода к объекту невозможно:

- Добавить новые свойства
- Удалить существующие свойства
- Изменить значения уже имеющихся свойств

```js
const user = { name: "Иван", age: 30 };

Object.freeze(user);
user.age = 31; // Не изменится
user.email = "test@example.com"; // Не добавится
delete user.name; // Не удалится
console.log(user); // { name: "Иван", age: 30 }
```

Не применяется к вложенным объектам.

#### Math

Объект Math объединяет в себя математические методы, для того чтобы не плодить глобальные функции, дабы не засорять глобальное пространство имен. Иначе, велика вероятность что функции, либо переменные создаваемые пользователем могут случайно совпасть с библиотечными.

#### Математические константы

Такие как $\pi$, $e$ и другие, доступны в объекте Math. и записываются прописными буквами:

```js
console.log(Math.PI); // 3.141592653589793
console.log(Math.E); // 2.718281828459045
```

#### Math.random

Возвращает псевдослучайное число от 0 включительно до 1 не включительно:

```js
console.log(Math.random()); // 0.123456789
```

Если необходимо сгенерировать случайное целое число, то в купе с текущей функцией используют округление

#### Math.floor

Округляет до наименьшего целого числа, которое меньше или равно указанному числу:

```js
console.log(Math.floor(2.9)); // 2
```

#### Math.ceil

Округляет до наибольшего целого числа, которое больше или равно указанному числу:

```js
console.log(Math.ceil(2.1)); // 3
```

#### Math.round

Округляет до ближайшего целого числа по правилам математики:

```js
console.log(Math.round(2.4)); // 2
console.log(Math.round(2.6)); // 3
```

#### Math.abs

Возвращает модуль числа:

```js
console.log(Math.abs(-5)); // 5
console.log(Math.abs(5)); // 5
```

### Глобальные объекты

В среде JS всегда есть один глобальный объект, от которого происходят остальные объекты.

Имя такого первичного объекта всегда зависит от среды исполнения JS:

- **window** в браузере
- **global** в Node.js
- **WorkerGlobalScope** в веб-воркере

Эти объекты не являются частью языка, они являются частью движка на котором ведется работа. Глобальный объект нужен для взаимодействия со средой в которой исполняется код.

Все методы и свойства глобального объекта доступны везде без указания window или global:

```js
console.log(this); // window
window.console.log(window); // window
console.log(global); // global
console.log(this === window); // true
console.log(this === global); // true
```

### Функции высшего порядка

ПО можно конструировать двумя способами, где:

1. Код простой и очевидно без дефектов
2. Код сложный и без очевидных дефектов

$\copyright$ Theories of Programming: The Life and Works of Tony Hoare

#### 1. Простой код

```js
function range{
    pass
}

function sum{
    pass
}

console.log(sum(range(1,10)));
```

Посчитать сумму о одно до десяти.

#### 2. Сложный код

```js
let total = 0;
let count = 1
while(count <= 10){
    total += count;
    count += 1;
}

console.log(total)
```

#### Абстракция

В пример 1.Простой код использованы словарь функций (sum, range) Словарь функций представляет собою набор функций которые выполняют определенную задачу.

Проблема в том, что невозможно создать словарь (функции), на все случаи жизни. Но, можно использовать абстрактный подход - **функции высшего порядка**:

Можно написать конкретный цикл для повторения конкретного действия, например для вывода элементов в консоль:

```js
for (let i=0; i<10; i++) console.log(i);
```

Если нужно данное действие выполнять желаемое количество раз (n), можно поместить цикл в функцию:

```js
function repeat(n){
    for (let i=0; i<n; i++) console.log(i);
}
```

Но, что если нужен не вывод в консоль, а другое действие? Тогда можно передавать функцию в качестве аргумента в повторяющую функцию:

```js
function repeat(n, action){
    for (let i=0; i<n; i++) action(i);
}

repeat(10, console.log);
```

Можно не передавать заранее описанную функцию в качестве параметра, можно в ее тело передать в качестве аргумента значения:

```js
let labels = [];
repeat(10, i => labels.push(i+1));

console.log(labels);
```

В примере выше, опущены фигурные скобки, т.к. тело функции короткое и однострочное.

#### Типы функций высшего порядка

Функции высшего порядка бывают двух типов:

1. Функции возвращающие другие функции (замыкания)
2. Функции принимающие другие в функции в качестве своих аргументов. Функция аргумент называют callback функцией.
   2.1. Функции меняющие другие функции
   2.2. Функции изменяющие поток выполнения

##### 1. Функции возвращающие другие функции

```js
function greaterThan(n){
    return m => m > n;
}

let greaterThan10 = greaterThan(10);
console.log(greaterThan10(11)); // true
```

##### 2.1. Функции меняющие другие функции

```js
function noisy(f){
    return (...args) => {
        console.log('calling with', args);
        let result = f(...args);
        console.log('called with', args, ', returned', result);
        return result;
    }
}

noisy(Math.min)(3, 2, 1); 
// calling with [3, 2, 1]
// called with [3, 2, 1], returned 1
```

Функция `noisy` принимает другую функцию нахождения минимума в качестве аргумента и возвращает с помощью стрелочной конструкции "болтливую" версию, которая оповещает о начале и конце вызова. Для передачи аргументов болтливой функции используется цепочный вывоз:

```js
noisy(Math.min)(3, 2, 1);
```

##### 2.2. Функции изменяющие поток выполнения

```js
function unless(test, then){
    if (!test) then();
}

repeat(3, n => {
    unless(n%2 == 1, ()=>{
        console.log(n, 'is even');
    })
})
// 0 is even
```

#### Методы высшего порядка

#### forEach()

Метод похожий на функцию `for of`:

```js
["A", "B", "C"].forEach(item => console.log(item));
```

#### filter

Что бы отфильтровать элементы в массиве можно создать функцию высшего порядка принимающую два аргумента:

- массив
- условия отбора (тестирующая функция).

```js
function filter(array, test){
    let passed = [];
    for (let element of array){
        if(test(element)){
            passed.push(element);
        }
    }
    return passed;
}

console.log(filter(SCRIPTS, script => scripts.living));
```

Чистая функция не модифицирует массив SCRIPTS а создает новый в соответствии с тестовыми условиями (функцией).

Как и forEach, filter является стандартным методом массива.

Предположим у нас есть массив объектов, где каждый объект содержит имя студента и его оценку за экзамен:

```js
const students = [
    { name: 'John', score: 80 },
    { name: 'Jane', score: 90 },
    { name: 'Bob', score: 70 },
    { name: 'Alice', score: 85 },
    { name: 'Charlie', score: 95 },
    { name: 'Dave', score: 75 },
    { name: 'Eve', score: 85 },
    { name: 'Frank', score: 90 },
    { name: 'Grace', score: 80 },
    { name: 'Henry', score: 85 }
];
```

Мы хотим вывести только тех студентов, у которых оценка больше 80.

```js
const goodStudents = students.filter(student => student.score > 80);
```

Используя метод console.table() можно вывести массив в виде таблицы:

```js
console.table(goodStudents);
```

#### map

Создадим функцию высшего порядка, которая трансформирует элементы массива, по заданному условию (функции).
Предположим мы хотим вывести не объекты массива SCRIPTS а свойство name этих объектов:

```js
function map(array, transform){
    let mapped = [];
    for(let element of array){
        mapped.push(transform(element));
    }
    return mapped;
}

console.log(map(SCRIPTS, s => s.name))
```

**map** также стандартный метод массива.

Предположим, что мы хотим не просто вывести студентов которые набрали 80 и более баллов, но мы хотим вывести вообще всех студентов. У тех кто прошел экзамен должно быть слово "passed", а у тех кто не прошел должно быть "Not passed":

```js
const result = students.map(student => {
    if (student.score >= 80) {
        return { name: student.name, score: student.score, result: "passed" };
    } else {
        return { name: student.name, score: student.score, result: "Not passed" };
    }
});

console.table(result);
```

В данном примере мы передаем методу map анонимную функцию, таким образом метод является функцией высшего порядка.

#### reduce

Напишем функцию суммаризация (подсчет суммы значений массива) по заданным признакам:

```js
function reduce(array, combine, start){
    let current = start;
    for(let element of array)
        current = combine(current, element);
    return current;
}

console.log(reduce([1, 2, 3, 4], (a, b) => a+b, 0));
```

Встроенный в массив метод reduce на примере расчета общей сумму баллов всех студентов:

```js
const totalScore = students.reduce((acc, student) => acc + student.score, 0);
console.log(totalScore);
```

1. Первый аргумент в примере у метода reduce() это анонимная стрелочная функция обратного вызова. Данная функция принимает свои два аргумента:
   - acc - аккумулятор (временное хранилище которое передается при каждой итерации)
   - student - текущий элемент (student) из массива students
2. Второй аргумент - 0, это первоначальное значение аккумулятора.
3. Третий аргумент - индекс текущего элемента.
4. Четвертый аргумент - сам массив.

Чаще всего в reduce() используется первые два аргумента.

В качестве аккумулятора можно использовать объект и это расширяет возможности метода:

```js
const {sum, count} = SCRIPTS.reduce((acc,b) => {
    if(b.living == true) {
        acc.sum+=b.year
        acc.count++
    }
    return acc
},{sum: 0, count: 0})

console.log(Math.round(sum/count));
```

#### some

Используется для поиска хотя бы одного нужного элемента в массиве. Например, чтобы выяснить есть ли среди студентов прошедшие практику:

```js
const hasPassed = students.some(student => student.score >= 80);
console.log(hasPassed); // true
```

Функция обратного вызова вызывается для каждого элемента итерации и если один из них возвращает true, то some() возвращает true и завершает работу на первом попавшемся элементе.

#### every

Обратный методу some(). В массиве все элементы должны соответствовать заданному условию. Например, чтобы выяснить все ли студенты прошли практику:

```js
const hasPassed = students.every(student => student.score >= 80);
console.log(hasPassed); // false
```

#### find

Возвращает первый элемент, который соответствует условию. В противном случае возвращает undefined:

```js
const student = students.find(student => student.score >= 80);
console.log(student); // { name: 'Jane', score: 90 }
```

Возвращает первое найденное вхождение. Позволяет искать неточное совпадение.

#### findIndex

Возвращает индекс первого элемента, который соответствует условию. В противном случае возвращает -1:

```js
const index = students.findIndex(student => student.score >= 80);
console.log(index); // 1
```

Возвращает индекс первого вхождения. Позволяет искать неточное совпадение.

### Деструктуризация

Позволяет сохранять значения из массива или объекта в отдельные переменные:

```js
const numbers = [1, 2, 3];
const [a, b, c] = numbers;
console.log(a); // 1
console.log(b); // 2
console.log(c); // 3
```

```js
const person = { name: 'John', age: 30, city: 'New York' };
let { name, age, city } = person;
console.log(name); // John
console.log(age); // 30
console.log(city); // New York
```

Название переменных должно совпадать с именами свойств объекта. Но, можно переименовать любой свойство при деструктуризации:

```js
const person = { name: 'John', age: 30, city: 'New York' };
let { name: userName, age: userAge, city: userCity } = person;
console.log(userName); // John
console.log(userAge); // 30
console.log(userCity); // New York
```

При попытке деструктуризации null или undefined, будет ошибка.

### Сериализация

Свойства объектов не содержат значения, а всего лишь захватывают их указатель. Если у нас есть массив объектов или массивов, тогда происходит двойная адресация ссылки ссылаются на ссылки памяти, содержащие реальные значения. Можно сделать дамп памяти для отправки содержимого по сети, но это не удобно и долго. Для того, что бы сохранить чистые данные без привязки к участками памяти, существует процедура сериализации. Сереализованные данные легко переносить по сети между разными устройствами или с разной архитектурой.

#### JSON

Java Script Object Notation

Формат очень похож на объекты JS, но имена свойств (ключи) обрамлены двойными кавычками, в нем не функций, не должно быть комментариев, в конце группы ключей не ставят запятые:

```json
{
    "name": "John",
    "age": 30
}
```

##### JSON.stringify

Для конвертации объекта JS в строкове представление JSON:

```js
const person = { name: 'John', age: 30 };
const json = JSON.stringify(person);
console.log(json); // {"name":"John","age":30}
```

Метод принимает 3 аргумента:

1. Объект, который нужно конвертировать в JSON (обязательный)
2. Функция-преобразователь, применится ко всем элементам(необязательный)
3. Количество пробелов, которое будет в качестве отступов в JSON (необязательный)

##### JSON.parse

Для конвертации JSON в объект JS:

```js
const json = '{"name": "John", "age": 30}';
const person = JSON.parse(json);
console.log(person); // { name: 'John', age: 30 }
```

## ECMAScript

### 01.Lecture

В ES2015 появились новые операторы:

- **spread** - распаковывает массив (объект) или другие структуры данных в атомарные элементы
- **rest** - принимает неограниченное количество параметров

#### оператор распаковки массива/объекта

**Spread** - расширять, распространять.

Любая функция содержит служебную переменную arguments, которая является псевдомассивом. Псевдомассив не имеет стандартных методов как настоящий массив, типа forEach. Поэтому при передаче в функцию неограниченного количества переменных, мы не сможешь по ним итерироваться как по массиву. Можно только с помощью классического for, что не всегда удобно. Использую spread оператор:

```js
function sum(a, b, c) {
    const args = [...arguments];
    console.log(args);
}
```

Распаковывает массив (объект) или другие структуры данных:

```js
const sum = (a, b, c) => {
    return a + b + c;
}
const arr = [1, 2, 3];
console.log(sum(...arr)); // 6
```

Можно распаковывать внутри другого массива или объекта:

```js
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const arr3 = [...arr1, ...arr2];
console.log(arr3); // [1, 2, 3, 4, 5, 6]
```

#### оператор упаковки

**Rest** - остальные, подобные, другие. Позволяет собрать другие оставшиеся аргументы в массив, тогда не нужно будет использовать встроенный псевдомассив функций arguments:

```js
let summa
function sum(...rest) {
    for (let i = 0; i < rest.length; i++) {
        summa += args[i];
    }
}

sum(1, 2, 3, 4, 5);
console.log(summa); // 15
```

rest можно комбинировать с обычными аргументами функции:

```js
function sum(name, lastname, ...rest) {
    console.log(`your name is ${name} surname is ${lastname} and other ${rest}`);
}
```

#### spread + rest

```js
function addOne(...ar){
    let sum = 0;
    for (let x of ar) sum+=x;
    return sum;
}

console.log(addOne(1, 2, 3)); // 6
let arr = [1, 2, 3]
console.log(addOne(arr)); // 01,2,3 
console.log(addOne(...arr)); // 6
```

При передачи отдельных цифр как аргументов функция addOne собирает их в один массив (rest), по которому пробегается цикл for of, суммируя элементы. В итоге возвращается сумма в виде числа.

Если же передать массив в addOne, то он упаковывается в еще один массив [arr], поэтому функция for of пробегается не по элементам массива arr, а по элементам внешнего для arr массива, где он сам элемент. Далее, идет приведение типов: цифрового sum и массива arr, которые приводятся к строке, поэтому функция возвращает конкатенированную строку "01,2,3".

Чтобы посчитать сумму массива к нему нужно применить оператор распаковки (spread).

## 02.Lecture

### class

[Систему прототипирования](#prototype) удобно использовать для задания экземпляров, которые имеют абсолютно одинаковые свойства и методы иначе каждому экземпляру придется добавлять свои методы и свойства. Для создания экземпляров которые имеют часть одинаковых свойств и часть уникальных удобно применять классы (class). Классы в JS появился в ES2015:

```js
// Класс робот-пылесос.
class RobotVacuumCleaner {
    // Свойства класса.
    model = "Romba-1";
    power = 200;
    batterySize = 2100;
    boxSize = 0.5;
    workTime = 45;
    counterOfStarts = 0;
    isFull = false;
    isObstacle = false;
    isUVLampOn = false;
    // Конструктор класса
    constructor() {
    }
    // Методы класса.
    startCleaning() {
        this.counterOfStarts++;
        console.log('I am cleaning... I have been started: ',
        this.counterOfStarts, 'times.');
    }
    goCharge() {
        console.log('I am going to charge...');
    }
    switchUVLamp() {
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    }
}

const Roomba = new RobotVacuumCleaner();
Roomba.isUVLampOn = true;
setTimeOut(Roomba.switchUVLamp, 5000);
```

Все схоже с объектом, только добавился конструктор, свойства внутри присваиваются через равно и методы объявляются по другому. Но, ультрафиолетовая лампа не выключается, т.к. setTimOut запускает выключатель лампы через 5 секунд когда контекст методов класса исчезает и this начинает ссылаться на глобальный объект.

#### bind()

Используя стандартный метод объектов bind можно сохранить контекст.

```js
// Класс робот-пылесос.
class RobotVacuumCleaner {
    // Свойства класса.
    model = "Romba-1";
    power = 200;
    batterySize = 2100;
    boxSize = 0.5;
    workTime = 45;
    counterOfStarts = 0;
    isFull = false;
    isObstacle = false;
    isUVLampOn = false;
    // Используем его, чтобы привязать все методы класса к контексту - текущему объекту (this).
    constructor() {
        this.startCleaning = this.startCleaning.bind(this);
        this.goCharge = this.goCharge.bind(this);
        this.switchUVLamp = this.switchUVLamp.bind(this);
    }
    // Методы класса.
    startCleaning() {
        this.counterOfStarts++;
        console.log('I am cleaning... I have been started: ',
        this.counterOfStarts, 'times.');
    }
    goCharge() {
        console.log('I am going to charge...');
    }
    switchUVLamp() {
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    }
}
// Создадим экземпляр класса.
const Roomba = new RobotVacuumCleaner();
Roomba.isUVLampOn = true;
setTimeout(Roomba.switchUVLamp, 2000); // UV lamp is not working.
```

Можно еще проще. В случае с классом хорошо работают стрелочные методы, которые не имеют своего контекста, и которые по умолчанию ссылаются через уровень к глобальному для них объекту, т.е. в наше случае к своему классу:

```js
// Класс робот-пылесос.
class RobotVacuumCleaner {
    // Свойства класса.
    model = "Romba-1";
    power = 200;
    batterySize = 2100;
    boxSize = 0.5;
    workTime = 45;
    counterOfStarts = 0;
    isFull = false;
    isObstacle = false;
    isUVLampOn = false;
    // Конструктор класса, мы изучим его подробнее на следующем уроке.
    constructor() {
    }
    // Методы класса.
    startCleaning = () => {
        this.counterOfStarts++;
        console.log('I am cleaning... I have been started: ',
        this.counterOfStarts, 'times.');
    }
    goCharge = () => {
        console.log('I am going to charge...');
    }
    switchUVLamp = () => {
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    }
}
// Создадим экземпляр класса.
const Roomba = new RobotVacuumCleaner();
Roomba.isUVLampOn = true;
setTimeout(Roomba.switchUVLamp, 2000); // UV lamp is not working.
```

Тут не нужно даже инициализировать конструктор, методы отрабатывают хорошо, с привязкой к контексту нашего класса.

#### Приватные свойства

Часта для класса можно создавать приватные свойства и методы, которые используются только самим классом внутри, без доступа из вне.

Наименование приватного метода начинается с символа решетки #:

```js
class SecretiveObject {
  #getSecret() {
    return "I ate all the plums";
  }
  interrogate() {
    let shallISayIt = this.#getSecret();
    return "never";
  }
}
```

Если в классе не задан конструктор, то он будет задан пустым: `constructor() {}`

Приватное свойство перед использованием должно быть объявлено:

```js
class RandomSource {
  #max;
  constructor(max) {
    this.#max = max;
  }
  getNumber() {
    return Math.floor(Math.random() * this.#max);
  }
}
```

### Переопределение методов

Когда определяется свойство к текущему объекту оно добавляется к текущему объекту, но если свойство есть в родителе, то оно переопределяется именно в текущем объекте, не затрагивая родителя:

```js
Rabbit.prototype.teeth = "small";
console.log(killerRabbit.teeth);
// → small
killerRabbit.teeth = "long, sharp, and bloody";
console.log(killerRabbit.teeth);
// → long, sharp, and bloody
console.log((new Rabbit("basic")).teeth);
// → small
console.log(Rabbit.prototype.teeth);
// → small
```

Код иллюстрирует, как выражение `new Rabbit("basic")).teeth` наследует отсутствующее изначально свойство teeth у родителя.

Переопределение использовано например в стандартном методе toString() массива:

```js
console.log(Array.prototype.toString ==
            Object.prototype.toString);
// → false
console.log([1, 2].toString());
// → 1,2
console.log({f: 1, s: 2}.toString());
// [object Object]
```

Как видно метод toString() у объекта и массива разные. В массиве метод переобределен чтобы выводит строку значений как это делает функция join().

## 03.Lecture

### **proto**

Указывает на какой объект родитель ссылаться, если свойство **proto** не задано, то оно по умолчанию ссылается на Object.

Зададим родителя:

```js
// Объект робот-пылесос.
const VacuumCleaner = {
    Model: "vacuum cleaner",
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    startCleaning: function () {
        this.counterOfStarts++;
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of VacuumCleaner');
        console.log('I am cleaning... I have been started: ', this.counterOfStarts, 'times.');},
        goCharge: function () {
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of VacuumCleaner');
        console.log('I am going to charge...');
    }
};
```

Зададим серию наследников:

```js
// Объект робот-пылесос.
const DancingSeries = {
    // Объявляем новые свойства и переопределить свойство model.
    model: "dancing series",
    power: 200,
    batterySize: 2100,
    boxSize: 0.5,
    workTime: 45,
    isUVLampOn: false,
    // Добавляем новый метод.
    switchUVLamp: function () {
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of DancingSeries');
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    },
    // Делаем ссылку на прототип от родителя.
    __proto__: VacuumCleaner,
};
```

Зададим наследника серии:

```js
// Объект робот-пылесос.
const Samba = {
    // Обновляем свойства под конкретную модель.
    model: "Samba-1",
    power: 250,
    batterySize: 2500,
    workTime: 50,
    // Делаем ссылку на прототип от родителя.
    __proto__: DancingSeries,
};
```

Обратимся к свойствам и методам родителя через серию:

```js
// Обращение к свойствам объекта.
console.log(Samba.model); // "Samba-1"
console.log(Samba.isFull); // false
// Вызов методов объекта.
Samba.startCleaning();
// I am the method of VacuumCleaner
// 'I am cleaning... I have been started: 1 times.'
Samba.isUVLampOn = true;
Samba.switchUVLamp();
// I am the method of DancingSeries
// 'UV lamp is not working.'
Samba.goCharge();
// I am the method of VacuumCleaner
// 'I am going to charge...'
```

Механизм прототипов позволяет использовать методы объекта Array в пользовательских массивах, который в свою очередь через свое **proto** ссылкается на Object.

Создадим еще одного конечного наследника и переобределим в нем метод startCleaning(), которые есть в родителе:

```js
// Объект робот-пылесос.
const Djaiv = {
    // Обновляем свойства под конкретную модель.
    model: "Djaiv-1",
    power: 250,
    batterySize: 2500,
    workTime: 50,
    // Переопределим метод startCleaning.
    startCleaning: function () {
        this.counterOfStarts++;
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of Djaiv');
        console.log('I am Djaiv, and I am cleaning... I have been started: ', this.counterOfStarts, 'times.');
    },
    // Делаем ссылку на прототип от родителя.
    __proto__: DancingSeries,
};

Samba.startCleaning();
// I am the method of VacuumCleaner
// 'I am cleaning... I have been started: 1 times.'
Djaiv.startCleaning();
// I am the method of Djaiv
// I am Djaiv, and I am cleaning... I have been started: 1 times.
```

startCleaning() для Djaiv является переопределенным, но у родителя и наследников остался прежним.

Для работы с прототипами можно использовать 2 метода: getPrototypeOf и setProrotypeOf.

#### getPrototypeOf

Позволяет получить ссылки на прототип объекта по цепочке:

```js
// Получим прототип для объекта Djaiv.
const DjaivProto = Object.getPrototypeOf(Djaiv);
console.log(DjaivProto.model); // dancing series
const DjaivProtoProto = Object.getPrototypeOf(DjaivProto);
console.log(DjaivProtoProto.model); //vacuum cleaner
const DjaivProtoProtoProto =
Object.getPrototypeOf(DjaivProtoProto);
console.log(DjaivProtoProtoProto); // [object Object]
```

Object не имеет прототипов, т.к. является самым первым, поэтому он вернет null.

#### setPrototypeOf

Зададим новоую серию наследников musicSeries:

```js
// Объект робот-пылесос.
const MusicSeries = {
    // Объявляем новые свойства и переопределяем свойство model.
    model: "music series",
    power: 200,
    batterySize: 2100,
    boxSize: 0.5,
    workTime: 45,
    // Добавляем новый метод.
    startWipe: function () {
    // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of MusicSeries');
        console.log('I am starting to wipe the floor...');
    },
    // Делаем ссылку на прототип от родителя.
    __proto__: VacuumCleaner,
};
```

Создадим конечного наследника и используем setPrototypeOf с двумя параметрами - объект наследник, объект родитель:

```js
// Объект робот-пылесос.
const Blues = {
    // Обновляем свойства под конкретную модель.
    model: "Bluees-1",
    power: 250,
    batterySize: 2500,
    workTime: 50,
};
// Установим прототип для робота.
Object.setPrototypeOf(Blues, MusicSeries);

console.log(Object.getPrototypeOf(Djaiv).model) // dancing series
console.log(Object.getPrototypeOf(Blues).model) // music series

Djaiv.startWipe(); // Uncaught TypeError: Djaiv.startWipe is not a function
```

### Конструктор объекта

Конструктор объекта - вызываемая с помощью оператора new функция, которая создает объект и проводит инициализацию.
Функцию конструктор объекта принято называть с большой буквы, внутри нее свойства и методы объявляют с помощью this
Создадим конечного наследника от первой серии:

```js
// Конструктор объекта робот-пылесос.
function Samba(serailNumber) {
    // Создаем свойства объекта, используя this.
    this.serialNumber = serailNumber;
    this.model = "Samba-1";
    this.power = 250;
    this.batterySize = 2500;
    this.workTime = 50;
    // Делаем ссылку на прототип от родителя.
    this.__proto__ = DancingSeries;
}
// Создадим экземпляр нового объекта.
const Samba1 = new Samba(1014778);
console.log(Samba1.serialNumber); // 1014778
console.log(Samba1.startCleaning()); // I am the method of VacuumCleaner
// I am cleaning... I have been started: 1 times.
```

Похоже на описание обычного объекта, только через ключевое слово this и с использовнием оператора new при инициализации.
Это ускоряет процесс создания множества однотипных объектов с помощью конструктора:

```js
// Создадим 10 роботов пылесосов Samba, как на конвейере. 
// const robots = [];
for (let index = 0; index < 10; index++) {
    // Создадим экземпляр нового объекта и добавляем его в массив наших роботов, каждый с уникальным серийным номером.
    robots.push(new Samba(index));
}
console.log(robots[3].serialNumber); // 3
console.log(robots[7].serialNumber); // 7
```

В примере с конструкоторм мы указали родителя с помощью this.**proto**, а можно с помощью свойства prototype:

```js
function Samba(serailNumber) {
    this.serialNumber = serailNumber;
    this.model = "Samba-1";
    this.power = 250;
    this.batterySize = 2500;
    this.workTime = 50;
}
// Делаем ссылку на прототип от родителя.
Samba.prototype = DancingSeries;
const Samba1 = new Samba(1014778);
console.log(Samba1.serialNumber); // 1014778
console.log(Samba1.startCleaning()); // I am the method of VacuumCleaner
// I am cleaning... I have been started: 1 times.

console.log(Samba1.__proto__); // {model: "dancing series", power: 200, batterySize: 2100, boxSize: 0.5, workTime: 45, ...}
console.log(Samba1.prototype); // undefined
console.log(Samba1.__proto__ === Samba.prototype); // true
```

Свойства **proto** есть у каждого объекта, оно позволяет найти родителя. Свойство же prototype есть только у функций-конструкторов, оно выполняет служебную роль при создании объекта и с помощью оператор new.

### prototype

Методы это всего лишь свойства, хранящие значения фукнций:

```js
function speak(line) {
  console.log(`The ${this.type} rabbit says '${line}'`);
}
let whiteRabbit = {type: "white", speak};
let hungryRabbit = {type: "hungry", speak};

whiteRabbit.speak("Oh my fur and whiskers");
// → The white rabbit says 'Oh my fur and whiskers'
hungryRabbit.speak("Got any carrots?");
// → The hungry rabbit says 'Got any carrots?'
```

Обычно метод применяется к тому объекту из которого он был вызван и ключевое слово this в теле метода ссылается на этот объект.
В данном случае this можно рассматривать как эстрапараметр передаваемый отличным от обычного аргкумента фукнции способом. Можно указать явно объект внутри call, который будет подставлен вметсо this в методе:

```js
speak.call(whiteRabbit, "Oh my fur and whiskers");
```

Любая фукнция воспринимает this как объект, но делает это по разному:

- классические функции под this подразумевуют свой объект
- стрелочные функции не имеют своего this, но могут обращаться к нему на уровень выше:

```js
let finder = {
  find(array) {
    return array.some(v => v == this.value);
  },
  value: 5
};
console.log(finder.find([4, 5])); // true
```

Если в данном контексте использовать классическую фукнцию с ключевым словом this внутри метода some, то мы не сможем выйти за пределы конекста и ничего не получится.

Другой способ создать объектный тип "кролик" с методом "говорить" использование вспомогательной функции, которая примет параметры: тип данных "кролик" и функцию "говорить". Можно создать много кроликов у которых похожие методы. Механизм, который позволяет это дела называется **prototype inheritance**.

```js
let empty = {};
console.log(empty.toString);
// → function toString(){…}
console.log(empty.toString());
// → [object Object]
```

Создали пустой объект, но у него уже есть метод toString(). Когда у объекта нет какого либо свойства (метода), оно будет искаться у его прототипа, если у прототипа нет такого свойства, то будет искаться у его прототипа и так далее, пока не будет достигнут объект без протолтипа:

```js
console.log(Object.prototype) // undefined
```

На этом принципе работают созданые пользователем объекты:

- Функции Function.prototype
- Массивы Array.prototype

Но можно переопределить прототипы или указать в качестве прототипа другой объект:

```js
let blackRabbit = Object.create(protoRabbit);
```

### Object.create

Метод позволяет также создавать новые объекты как и способы ранее. Аргументами принимает прототип и свойства нового объекта в формате словаря с ключами. Данный метод хорош тем, что в качестве первого аргумента может принимать null, тогда создаваемые объекты не будут привязаны к Object и не будут наследовать его методы такие как toString(), valueOf() и т.д. Иногда нужно создать объект без единого свойства и метода:

```js
const Samba1 = new Samba(101);
console.log(Samba1.toString()); // [object Object]

const Samba1 = Object.create(null);
console.log(Samba1.toString); // undefined
console.log(Samba1.__proto__); // undefined
```

Но, есть более удобные механизмы создания объектов и насследования, которые появились с приходом ES2015

### new

Оператор new позволяет правильно вызвать конструктор, которая как функция ничего не возвращает и создать объект, по алгоритму:

1. Создаем пустой объект.
2. Задает ссылку для this на созданый объект
3. Вызывает функцию конструктор.
4. Если у функции конструктора есть свойство prototype, то устанавливает его значения для свойства объекта **proto**
5. Устанавливает свойство constructor ссылкой на конструктор
6. Возвращает созданный объект, т.е. фукнция конструктор ничего не возвращает

Самописный оператор new в виде фукнции:

```js
function createObject(constructor) {
    // Создаем новый объект.
    const obj = {};
    // Установим новому объекту прототипом прототип функции-конструктора
    Object.setPrototypeOf(obj, constructor.prototype);
    // Вызовем функцию-конструктор, передав ей как this созданный на шаге 1 объект, и передадим остальные аргументы, если они были переданы в createObject
    const argsArray = Array.prototype.slice.apply(arguments);
    const result = constructor.apply(obj, argsArray.slice(1));
    // Вернем новый объект, если конструктор вернул примитивное значение или undefined, иначе вернем то, что вернул конструктор.
    if (!result || typeof result === 'string' || typeof result === 'number' || typeof result === 'boolean') {
        return obj
    } else {
        return result;
    }
}
// Создадим экземпляр нового объекта.
const Samba1 = createObject(Samba, 1014778);
// Проверим установку свойств в конструкторе.
console.log(Samba1.serialNumber); // 1014778
// Проверим, что прототип установился корректно, и мы можем вызывать методы из родительских объектов.
console.log(Samba1.__proto__); // {model: "dancing series", power: 200, batterySize: 2100, boxSize: 0.5, workTime: 45, ...}
console.log(Samba1.startCleaning()); // I am the method of VacuumCleaner
// I am cleaning... I have been started: 1 times.
// Проверим присвоение конструктора.
console.log(Samba1.constructor); // function Object() { [native code] }
```

#### Map

Предположим нужна структура данных для храненния возраста пользователей:

```js
let ages = {
    "Julia" : 62,
    "Boris" : 39,
    "Grandpa" : 402,
    "Eddie" : 10
};

console.log(`Julia is ${ages["Julia"]}`);
console.log("Is Jack's age known?", "Jack" in ages);
console.log("Is toString's age known?", "toString" in ages);
```

Видим проблему в последней строке. Методо (свойство) объекта toString (лешнее имя) и аналогичные свойство могут дать не тот результат, что ожидаем.

Для решения проблемы лишних имен, можно создать объект без прототипа:

```js
const ages = Object.create(null);
ages.Julia = 62;
...
```

Можно использовать `Object.hasOwn(ages, "toString"); \\ false`, но лучше испольшовать готовое решение класса Map().

Класс Map() - структура данных ассициированных пар ключ-значение. Ключи уникальны, а значения могут повторяться.

```js
let ages = new Map();
ages.set("Julia", 62);
ages.set("Boris", 39);
ages.set("Grandpa", 402);
ages.set("Eddie", 10);
console.log(ages.has("toString")); //false
```

Map() имеет следующие методы:

- set(key, value)
- get(key)
- has(key)
- delete(key)
- clear()
- keys()
- values()
- entries()

### Полиморфизм

Когда вызываете функцию String() для объекта, она вызывает мотод toSting() у этого объекта и попробует преобразовать его в строку. Некоторые стандартные прототипы хорошо с этим справляются в отличии от [object Object].
Для собственного объекта можно переопределить метод toString():

```js
const user = {
    name: 'John',
    age: 30,
    toString() {
        return `${this.name} is ${this.age} years old`;
    }
};
console.log(user.toString()); // John is 30 years old
```

Получается хороший подход - когда когда кусок кода написан для работы с объектоами которые имеют определенный интерфейс - в нашем случае toString() - лбой объект объект который поддерживает этот интерфейс будет работать. И данная техника называется полиморфизмом. Полиморфный код может работать со значениями любой формы, если они поддерживают интерфейс. Пример широко используемого интерфейса для массиво-подобных объектов это свойство length. Свойство length доступно и для массивов и для строк, а также для ряда других объектов.

### Геттеры и сеттеры

Геттеры и сеттеры в JavaScript — это специальные методы доступа к свойствам объекта, которые позволяют перехватывать чтение и запись значений.

```js
const person = {
  firstName: "John",
  lastName: "Doe",

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },

  set fullName(value) {
    const [first, last] = value.split(" ");
    this.firstName = first;
    this.lastName = last;
  }
};

console.log(person.fullName); // 👉 "John Doe"

person.fullName = "Alice Smith";

console.log(person.firstName); // 👉 "Alice"
console.log(person.lastName);  // 👉 "Smith"
```

- Геттеры вызываются при чтении свойства (obj.prop).
- Сеттеры — при присваивании (obj.prop = value).
- Работают как свойства, но под капотом — это функции.

### static

Ключевое слово static используется в классах для определения статических методов и свойств, которые принадлежат самому классу, а не экземплярам этого класса.

```js
class MathUtils {
  static square(x) {
    return x * x;
  }
}

console.log(MathUtils.square(5)); //  25

const utils = new MathUtils();
console.log(utils.square);  // undefined (это НЕ метод экземпляра)
```

### Symbol()

Появилась в 2015. В отличие от строки Symbol() всегда уникальный, нельзя создать два одинаковых объекта Symbol():

```js
let id1 = Symbol("test");
let id2 = Symbol("test");
console.log(id1 === id2); // false
console.log(id1.description, id2.description) // test test
```

Возможно добавление символьного свойства в объект или класс обрамив свойство квадратными скобками, как при использовании скобочной нотации при вызове свойств объекта:

```js
const myTrip = {
    length: 2,
    0: 'New York',
    1: 'San Francisco',
    [length]: 21500

};
console.log(myTrip[length], myTrip.length); // 21500 2
```

### Интерфейс iterator

Цикл for/of ожидает итерируемого объекта, имеющего символьный метод Symbol.iterator (символьно значение определенное самим языком, хранящееся в функции Symbol).
Когда метод вызван он должен вернуть объект предоставляющий второй интерфейс **итератор**, вот эта штука и занимается итеррированием. Объект имеет метод **next**, который возвращает следующий результат, который тоже объект имеющий свойство **value**, которое в свкою очередь будет иметь следующее значение, в случае наличия или свойство **done** имеющее значение true, указывающее что итерация завершена.
Свойства объекта **next**, **value** и **done** являются строками, не символьным типом. Только Symbol.iterator, который предполагается будет добавлен в большниство объектов, является символьным типом данных:

```js
const iterator = [1, 2, 3][Symbol.iterator]();
console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

Создадим сами и итеррируемый объект на основе односвязного списка:

```js
class List{
    constructor(value, rest){
        this.value = value;
        this.rest = rest;
    }
    get length(){
        return 1 + (this.rest ? this.rest.length : 0);
    }
    static fromArray(array){
        let result = null;
        for(let i = array.length - 1; i>=0; i--){
            result = new this(array[i], result);
        }
    }
}
```

В статическом методе класса **this** ссылается на конструктор текущего класса, не экземпляра, пока еще нет экземпляров, когда данный метод вызван.

Итерирование по спику должно возвращать все элементы от начала до конца. Для этого напишем отдельный класс-итератор:

```js
class ListIterator{
    constructor(list){
        this.list = list
    }

    next(){
        if(this.list == null){
            return {done: true};
        }
        let value = this.list.value;
        this.list = this.list.rest;
        return {value, done: false};
    }
}
```

Класс отслеживает прогресс итерации по списку обновляя свое свойство **list**, до тех пор пока значения возвращаются.

Теперь сделаем класс **List** итерируемым:

```js
List.prototype[Symbol.iterator] = function(){
    return new ListIterator(this);
}
```

Данный кусок кода можно поместить непосредственно в класс. Теперь можем итерироваться по списку с помощью for/of:

```js
let list = List.fromArray([1, 2, 3]);
for(let element of list){
    console.log(element);
}
// 1
// 2
// 3
```

Синтаксический сахар ... работает с любым итеррируемым объектом, позволяя превратить его в обычный массив:

```js
console.log([..."PCI"]); // ["P", "C", "I"]
```

## Наследование

Предположим нам нужен класс такой же как List, но мы не хотим дожидаться подсчета всех элементов, чтобы получить размер списка с помощью **length**. Хотим чтобы актуальный размер списка был всегда доступен для каждого экземпляра. Такое возможно с помощью механизма **наследования**. Можно наследовать все свойства объекта и добавить еще какие-то отличные от **супер-класса**, получив таким образом **подкласс**.

```js
class LengthList extends List{
    #length;
    constructor(value, rest){
        super(value, rest);
        this.#length = super.length;
    }
    get length(){
        return this.#length;
    }
}

console.log(LenghtList.fromArray([1, 2, 3]).length); // 3
```

Наследование фундаментальная часть ООП, так же как и инкапсуляция или полиморфизм, но в отличи от них, которы упрощяют и прячут подробности, наследование усложняет и делает больше взаимосвязей. Т.к. чтобы понять подкласс, нужно знать друге классы от которых он произошел.

### class extends

Заменим предыдущий код современным способом, создадим родителя:

```js
// Класс робот-пылесос.
class VacuumCleaner {
    model = "vacuum cleaner";
    counterOfStarts = 0;
    isFull = false;
    isObstacle = false;
    // Для создания конструктора, нужно создать метод constructor.
    constructor() {
    }
    startCleaning() {
        this.counterOfStarts++;
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of VacuumCleaner');
        console.log('I am cleaning... I have been started: ', this.counterOfStarts, 'times.');
    }
    goCharge() {
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of VacuumCleaner');
        console.log('I am going to charge...');
    }
}
// Попробуем создать экземпляр класса и посмотреть как онработает.
const BaseRobot = new VacuumCleaner;
console.log(BaseRobot.constructor); // class VacuumCleaner {
// model = "vacuum cleaner";
// counterOfStarts = 0;
// isFull = false;
// isObstacle = false;
// Для создания конструктора, нужно создать метод constructor.
// constructor() {
// }
// ...
console.log(BaseRobot.model); // vacuum cleaner
console.log(BaseRobot.startCleaning()); // I am the method of VacuumCleaner
// I am cleaning... I have been started: 1 times.
```

Cоздадим расширенную новым методом серию:

```js
// Расширенный класс DancingSeries. C помощью extends мы указываем от какого класса будем наследоваться.
class DancingSeries extends VacuumCleaner {
    // Объявляем новые свойства и переопределяем свойство model.
    model = "dancing series";
    power = 200;
    batterySize = 2100;
    boxSize = 0.5;
    workTime = 45,
    isUVLampOn = false;
    // Добавляем новый метод.
    switchUVLamp() {
        // Добавим дополнительный вывод, чтобы знать чей метод мы вызвали.
        console.log('I am the method of DancingSeries');
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    }
};

// Создадим новый экземпляр класса, чтобы посмотреть как он работает и что в нем есть.
const DancingRobot = new DancingSeries;
console.log(DancingRobot.__proto__); // VacuumCleaner
{constructor: ƒ, switchUVLamp: ƒ}
console.log(DancingRobot.model); // dancing series
console.log(DancingRobot.switchUVLamp()); // I am the method of DancingSeries
// lamp is working.
```

Под капотом все ранее описанные действия. Объявляя класс движок JS:

- создает функцию конструктор по имени класса
- берет для конструктора код из метода constructor, если метода нет то конструктор тоже будет пустым.
- Если есть расширение, то в конструкторе будет служебное свойство prototype
- прописывает все методы в свойство prototype конструктора

```js
// Созданный конструктор является функцией, код которой взят из конструктора.
console.log(DancingSeries === DancingSeries.prototype.constructor); // true
// В созданном конструкторе есть свойство prototype и оно содержит все методы.
console.log(DancingSeries.prototype); // VacuumCleaner {constructor: ƒ, switchUVLamp: ƒ}
```

### Оператор instanceof

Чтоб знать от какого класса произошел объект, используется оператор бинарный instanceof:

```js
console.log(new Length(1, null) instanceof LengthList); // true
console.log(new Length(1, null) instanceof List); // true
console.log(new Length(1, null) instanceof Object); // true
console.log([1] instanceof Array); //true
```

### 04.Lecture

#### Async

Асинхронный код состоит из двух частей:

- долгая часть (требует большего времени выполнения)
- callback - вызывается по завершению долгого кода, может сообщать о его завершении

**Цикл Событий** (Event Loop) - механизм, который помещает долгую часть в очередь отложенных задач и следит за ними.

#### Event Loop

Сам цикл событий состоит из трех частей:

1. Call Stack - **стек вызовов** синхронного кода
2. Callback Queue - **очередь отложенных задач** асинхронного кода
3. API среды (ПО где запущен JS: браузера или node.js)- сам движок например не содержит асинхронную функцию setTimout()

```js
console.log("Start algorithm!");
setTimeout(function timeout() {
console.log("This will be printed after 5 seconds!");
}, 5000);
console.log("End synchronous code.");
```

Первая строка синхроная, она попадает в Call Stack, выполняется стандартными механизмами и завершается.
Вторая строка setTimeout() это асинхронная фукнция API браузера, она содержит каллбек фукнцию timeout(), которая через 5 секунд попадает в Callback Queue. (если бы была синхронная функция, то она бы попала в Call Stack и не была бы в очереди отложенных задач)

Пока длятся 5 секунд, код продолжает выполнятся дальше выведя сообщение из 7 строки.
Все это время цикл событий смотрит за стеком вызовов, если он пустой (т.е. нет синхронных задач) то он берет первую задачу из очереди отложенных асинхронных задач и помещает функцию timeout() в стек синхронных вызвов и из стека вызовов стандартный механизм выполняет и завершает timeout().

Цикл событий тупо делает два действия: следит когда освободится стек и сразу бередь задачу из очереди и помещает в стек.

При занятом долгой синхронной задачей и следовательно забытым ей стеке нет гарантии, что функция timeout() выполнится в течении 5 секунд.

Асинхронными делаются функции, которые чем-то могут быть заняты и не заблокируют основной поток, например:

- доступ к БД
- чение или запись файлв
- оптарвка или получание данных по сети

В вебе часто код для подгрузки картинок делают асинхронным, чтобы пользователю не дожидаясь были доступны текст и элементы упралвения.

Встроенные функции и методы могут быть синхронными или асинхронными, а есть в двух исполнениях сразу.

Циклы for, while - является синхронным, цикл while. Но, есть способ сделать код с такими операторами асинхронным

#### AJAX

Asynchronous JavaScript And XML (AJAX) - механизм, который позволяет обновлять страницу без перезагрузки: чаты, мессенджеры, уведомления и т.д.

##### XMLHttpRequest

Объект XMLHttpRequest позволяет создать объект запроса на сервер и ответа от него (через браузер как html-файл):

```js
// XHR GET запрос
// Для создания запроса сначала нужно создать объект XMLHttpRequest, конструктор вызывается без аргументов.
const xhr = new XMLHttpRequest();
// Открываем запрос. Первый аргумент это метод (GET, POST ...), второй адрес, куда нужно отправить запрос. У данного метода есть еще аргументы, которые мы рассмотрим позже.
xhr.open('GET', 'https://api.github.com/users/octocat');
// Отправляем запрос на сервер. Метод send() может принимать один аргумент - это тело запроса, если оно есть. Для методов POST мы бы передавали тут тело запроса, наш запрос GET не имеет тела запроса.
xhr.send();
// После отправки запроса нам нужно использовать методы слушатели, которые будут асинхронно выполнены при наступлении соответствующего события. Это методы onload, onerror и onprogress - мы сами определяем их функции.
// onload - будет вызван, когда сервер вернет ответ. Это может быть положительный ответ сервера с кодом 200 (все хорошо), так и ошибка, например страница не найдена, тогда код будет 404. Мы должны обрабатывать такие ситуации сами.
xhr.onload = function() {
    if (xhr.status != 200) { // если статус не 200, то произошла ошибка
        console.log(`Error ${xhr.status}: ${xhr.statusText}`);
    } else {
        console.log(`user: ${xhr.response}`); // response - это ответ сервера
    }
};
// onprogress - функция будет вызываться пока запрос находится в процессе, и позволяет отслеживать ход процесса отправки запроса и получения ответа от сервера. Бывает полезна при отладке сложных запросов.
xhr.onprogress = function(event) {
    console.log(`Get from server: ${event.loaded} bytes`);
};
// onerror - функция будет вызываться если в запросе пошло что-то не так. НАпример нет соединения с сервером или ошибка в адресе запроса.
xhr.onerror = function() {
    console.log("Request error");
};
// Вывод из функции onprogress.
// Get from server: 1319 bytes
// Вывод из функции onload, приведен не полностью.
user: {`
"login": "octocat",
"id": 583231,
"node_id": "MDQ6VXNlcjU4MzIzMQ==",
"avatar_url":
"https://avatars.githubusercontent.com/u/583231?v=4",
"gravatar_id": "",
"url": "https://api.github.com/users/octocat",
"html_url": "https://github.com/octocat",
"followers_url":
"https://api.github.com/users/octocat/followers",
"following_url":
"https://api.github.com/users/octocat/following{/other_user}",
...`
}
```

С помощью node.js:

```js
const XMLHttpRequest = require('xhr2');

const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.github.com/users/strogino');
xhr.send();

xhr.onload = function() {
  if (xhr.status !== 200) {
    console.log(`Error ${xhr.status}: ${xhr.statusText}`);
  } else {
    console.log(`user: ${xhr.response}`);
  }
};

xhr.onprogress = function(event) {
  console.log(`Get from server: ${event.loaded} bytes`);
};

xhr.onerror = function() {
  console.log("Request error");
};
```

Объект XMLHttpRequest имеет ряд других полезных методов, но его применение с каждом годом становится менее актуальным, т.к. есть метод fetch.

#### async/await

Появился в ES8.

**async** - превращает любую функцию в обещание и позволяет использвать await внутри нее.

**await** - останавливает выполнение функции, пока она не вернет результат.

```js
const getUser = async (url) => {
    // Делаем запрос, и ждем его результат (указание await), который будет сохранен в константу response.
    const response = await fetch(url);
    // Выполняем еще один асинхронный метод, преобразования в текст, также ждем результат, который сохраняется в константу пользователь.
    const user = await response.text();
    console.log(user);
}
getUser('https://api.github.com/users/octocat');
// Вывод в консоль.
// {
// "login": "octocat",
// "id": 583231,
// ...
// }
```

#### setTimout(), setInterval()

Запланированная асинхроность - это когда нужно синхронный код превратить в асинхронный. Например, для имитации задержки ответа от сервера:

```js
let counter = 0; // объявляем переменную counter
const amount = 100000; // объявляем переменную amount
const timerId = setInterval(() => {
    if (counter > amount) {
    // После того как наш счетчик достигнет нужного количества итераций, мы должны очистить таймер, чтобы итерации больше не выполнялись.
    clearInterval(timerId);
        console.log('End long calculations');
    }
    // Добавим вывод нашего счетчика через каждые 10000 итераций, чтобы видеть что наш код работает.
    if (counter % 10000 === 0) {
        console.log('working: ', counter);
    }
    const newDate = new Date(counter);
    counter++;
}, 0);
// Start long calculations
// working: 0
// working: 10000
// working: 20000
...
// End long calculations
```

Вышеперечисленные функции помещают колбеки в очерь отоложенных задач, поэтому они становятся асинхронными
