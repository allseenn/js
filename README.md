# JavaScript Basics

This repo contains my JS code from lectures and labs by GeekBrains online university. 

## 01. Lecture

### Intro

01.Lecture

**HTML** - язык разметки для веб-страниц

**CSS** - язык оформления HTML

**JS** - язык программирования или движок для веба и бекенда

### Движки

- V8
- Rhino
- SpiderMonkey
- JSC
- Chakra

Движки написаны на C++. Они интерпретируют скрипты на JS. Как правило движки встроены в прикладное ПО:

- Браузеры
- Node.js, Electron, React Native, Deno
- ПО для встраиваемых систем (роботы, Falcon 9, Iskra)

В свою очередь прикладное ПО работает в системных средах:

- Браузер установленный на десктопные OC (Windows, Linux, macOS)
- Node.js, Electron установленные на серверные OC (Windows, Linux, FreeBSD, macOS)
- Киоски (банкоматы, терминалы оплаты и т.д.) - легкая версия ОС с браузером

### Стандарты

ECMA international - European Computer Manufacturers Association - Европейская ассоциация по стандартизации компьютерного производства.

Наиболее известные стандарты ECMA Inc.:

- ECMA-376 (OOXML) - Office Open XML
- ECMA-119 (ISO9660) - формат CD-ROM и DVD-ROM
- ECMA-267 (UDF) - перезаписываемый формат CD-ROM и DVD-ROM
- ECMA-262 (ECMAScript) - язык программирования JavaScript

ECMAScript состоит из релизов:

- ...
- ES5
- ES6
- ES2022
- ES6+ - современный JS

### Этапы выполнения кода в браузере

1. Создается структура HTML-документа
2. Применяются стили
3. Добавляется контент (картинки, мультимедиа)
4. К странице подключается скрипт и выполняется

Браузер начинает выполнять JS-код в момент обнаружения его в html, поэтому рекомендуется помещать его в конце документа. Либо использовать специальные атрибуты.
Если произошла ошибка в коде, то браузер выдает сообщение в консоли, но продолжает загрузку контента, html и дальнейшего JS-кода.
Код выполнятся даже после того как все загрузилось, все время пока страница открыта.

### Переменные

- let
- const
- var

#### let и const

Ключевые слова let и const появились в ES2015:

- let для объявления переменных с блочной областью видимости

```js
let age = 10;
age = 15;
```

- const для объявления констант с блочной областью видимости их нельзя изменять

```js
const GAP_SIZE = 10;
GAP_SIZE = 15; // TypeError
```

#### var

До ES5 с помощью ключевого слова **var** инициализировали переменные. В современном релиза **var** осталась, но используется немного по другому:

1. Для объявления глобальных переменных.
2. Для инициализации переменной без присвоения значения:

```js
var a;
```

Значением переменной **a** будет **undefined**.

### Всплытие

**Hoisting** (всплытие) - уникальный механизм JS, позволяющий обращаться к значению переменной до ее объявления с помощью **var**. Значением при всплытии такой переменной будет undefined.

```js
console.log(age); // undefined
var brotherAge = age + 12
console.log(brotherAge) // Nan
var age = 10

console.log(name)
let name = "Ivan" // Uncaught ReferenceError
```

### Типы данных

В JS есть 8 типов данных:

1. string (строка) - неизменяемый примитив
2. number (число) - неизменяемый примитив
3. boolean (булевый) - неизменяемый примитив
4. undefined (неопределенный) - неизменяемый примитив
5. BigInt (большое число) - неизменяемый примитив
6. symbol (символьный) - неизменяемый примитив
7. null (нуль) - неизменяемый примитив, но при проверке указывает на то, что это объект
8. object (объект) - изменяемые типы данных
    - array (массив)
    - function (функция)

Примитивные типы данных в JavaScript не являются объектами и не имеют методов или свойств. Однако, когда вы пытаетесь использовать метод или свойство примитивного типа данных, JavaScript автоматически оборачивает его в объект, чтобы предоставить доступ к методам и свойствам.
Например, когда вы пытаетесь использовать метод toUpperCase() на строке, JavaScript оборачивает строку в объект String и предоставляет доступ к методу toUpperCase().

Для определения типа данных используют typeof:

```js
console.log(typeof 10); // number
```

Все типы данных отличаются:

- встроенными методами
- методами сравнения

#### string

Строка это текст в кавычках (одинарных, двойных или обратных):

```js
let name = "Ivan";
let lastName = 'Petrov';
let fullName = `Ivan Petrov`;
```

#### Шаблонный литерал

Строки внутри обратных кавычек называют **шаблонным литералом**

#### number

**Number** - это целое или дробное число, как в десятичной так и в других системах счисления, включая шестнадцатеричную. Для чисел есть ограничения от -2^53 до 2^53 не включительно.

Есть специальны значения, которые также имеют тип **number**:

- Infinity
- -Infinity
- NaN

Infinity, это число, которе получается в математических операциях, типа деления на ноль. 

```js
10 / 0 // Infinity
```

NaN поглощает арифметические операции, которые не могут быть выполнены, например операция нат разными типами данных.

```js
5 - '5' // NaN
```

#### boolean

**Boolean** - это логический тип данных, который может иметь два значения: **true** и **false**.

#### Undefined

**Undefined** - значение не определено, как правило при пустой инициализации переменной или при возвращении функций без ключевого слова return.

```js
let name;
console.log(name); // undefined
```

#### object

Набор данных, к которым можно обратиться по имени объекта через точку:

```js
let person = {
    name: 'Ivan',
    age: 10
}
console.log(person.name); // Ivan
```

Или через квадратные скобки по ключу:

```js
console.log(person['name']); // Ivan
```

Объекты задаются пользователям, но есть 2 типа данных, которые являются встроенными объектами:

- Array
- Function

##### array

Массив это список значений, которые можно обратиться по индексу, он может хранить неограниченное количество значений.

```js
let arr = [1, 2, 3];
console.log(arr[0]); // 1
```

##### function

Функция - имеет свои методы и свои свойства. Она может быть сохранена в переменную или передана в качестве значения другому объекту.

Например, встроенный методе toString() возвращает строковое представление функции.

```js
const add = function(a, b) {
    return a + b;
}

console.log(add.toString()); // function add(a, b) { return a + b; }
```

Встроенные методы объектов, могут быть переопределены.


#### null

**null** - примитив, который возвращает **object**. [Неустранимый баг JS](https://habr.com/ru/sandbox/200708/)

```js
let name = null;
console.log(typeof name); // object
```

Null часто используют в API и при работе с DOM, когда ожидают возврата объекта, но возвращается null.

#### Symbol

**Symbol** - это встроенный тип данных, который используется для создания уникальных идентификаторов. Даже при одинаковых значениях они будут различаться.

```js
let id1 = Symbol("test");
let id2 = Symbol("test");
console.log(id1 === id2); // false
```

Добавлен в ECMASCript 2015.

#### bigInt

Супербольшие целые числа. Они записываются как обычные целые, только в конце есть литера n:

```js
let bigNum = 9007199254740991n;
console.log(typeof bigNum); // bigint
```

Используются например для меток времени с микросекундами.

## 03. Lecture

### Приведение типов

Явное приведение типов:

```js
let number = 10;
let string = number.toString();
console.log(typeof string); // string
```

2. Неявное приведение

```js
let number = 10;
let string = '10';
console.log(number + string); // 1010
```

Арифметические операции кроме сложения всегда приводят типы к одному.

#### Булево приведение

При приведении к булевому типу, у следующих значений будет **false**:

- ""
- 0, -0, NaN
- null
- undefined
- false

При приведении к булевому типу, у следующих значений будет **true**:

- "Hello"
- 42
- {} - объекты
- [] - массивы
- function foo() { ... } - функции

Булево приведение происходит автоматически при условных операторах. 
Любой тип данных можно привести к булеву с помощью отрицания !. Но, чтобы небыло инвертированного значения, можно использовать два отрицания !!.

```js
let value = 1;
console.log(!!value); // true
```

### Равенства

**==** нестрогое равенство, при котором происходит приведение типов:

```js
let a = 10;
let b = "10";
console.log(a == b); // true
```

**===** строгое равенство, при котором не происходит приведение типов и происходит сравнение типов данных:

```js
let a = 10;
let b = "10";
console.log(a === b); // false
```

Движки JS приводят типы по умолчанию к числу, поэтому нестрогое сравнение пустых массивов false, а сравнение тех же массивов, но с отрицанием true.
А вот сравнение пустого массива и инвертированного, тоже true:

```js
[] == []; // false
![] == ![] // true
[] == ![]; // true
// Потому, что:
+[] // 0 - в соответствии с правилами приведения выше пустой массив это false => +false = 0
![] // false - в соответствии с таблицей [] = true => !true = false => +false = 0
// 0 == 0 is true
```

Непустые объекты или непустые массивы между собой сравниваются по ссылкам, не сравнивая значения. Но, если сравнить объект с примитивом, то объект приводится к конкретному примитиву.

### Сравнения

Когда сравниваются строки, то это происходит посимвольно, слева направо:

```js
let a = '43';
let b = '42';
console.log(a > b); // true
```

Такое сравнение называют - **лексикографическим**.

В JS нет строго сравнения типа (>>), как это есть у равенств. Поэтому, у сравнений происходит приведение типов:

Если при приведении строка не может быть преобразована в число, то возвращается NaN, который не может быть ни больше, ни меньше. Поэтому при сравнении c участием NaN, всегда возвращается false.

```js
let a = 10;
let b = '9cc';
console.log(a > b); // false
```

### Унарные операторы

- Унарный минус -a (отрицательное число)
- Унарный плюс +a (приведение к числу)
- Инкремент a++
- Декремент a--
- Конкатенация 'a'+'b'
- Побитовое отрицание ~a
- Побитовая инверсия (исключающее или) ^a
- Логическое отрицание !a
- Побитовое и &a
- Побитовое или |a
- Побитовый сдвиг влево <<a
- Побитовый сдвиг вправо >>a
- Оператор доступа к свойству объекта (точка) a.b
- Оператор разделения элементов или вычисления выражений ,
- Деструктуризация ...a
- void 
- typeof
- delete

### Проверки и приведение

Если переменная не путая строка "" и не ноль 0:

```js
let a = "John";
if (a) {
    console.log(a);
}
```

Чтобы привести число к строке можно сложить его с пустой строкой:

```js
let a = 10;
console.log("" + a); // "10"
```

Проверка в условии пустой ли массив:

```js
let a = [];
if (a.length) {
    console.log(a);
}
```

### Методы ввода

У объекта window есть методы ввода:

1. windows.alert()
2. window.prompt()
3. windows.confirm()

Т.е. window - это глобальная область видимости, то методы можно указывать без window.
Методы вызывают диалоговые окна в браузере, которые нельзя изменить и определить их положение.

### Условные конструкции

Условие - любое выражение возвращающее болевое значение (true или false). Если условие верно, то выполняется блок кода, иначе - нет. Если выражение условия возвращает не булевый тип, то он будет приведен к булевому.

false:

- ""
- 0, -0, NaN
- null
- undefined

true:

- любое другое значение

#### Тернарный оператор

```js
let a = 10;
let b = 20;
let c = a > b ? a : b;
console.log(c); // 20
```

#### Switch

```js
let a = 10;
switch (a) {
    case 10:
        console.log('10');
        break;
    case 20:
        console.log('20');
        break;
    default:
        console.log('default');
        break;
}
```

### Комментарии

```js
// однострочный комментарий
/* многострочный комментарий */
```

### Консоль браузера

CTRL+SHIFT+C - открыть инструменты разработчика
CTRL+SHIFT+I - открыть инспектор
CTRL+SHIFT+J - открыть консокль

## 05. Lecture

### Функции

#### Классификация по всплытию

- Анонимные
- Именованные

**Анонимные** функции используют **функциональное выражение**, где функция создается в момент выполнения данного выражения

```js
const sum = function(a, b) {
    return a + b;
};
```

**Именованные** функции используют **декларативное объявление**, где функция создается до основной компиляции кода, т.е. всплывает вверх. Поэтому такая функция может быть расположена в конце кода, а вызываться в начале.

```js
function sum(a, b) {
  return a + b;
}
```

#### По параметрам

- С обязательными параметрами
- С опциональными параметрами
- Без параметров

**Параметр функции** - это имя переменной, которое находится внутри скобок после имени функции.

**Аргумент функции** - это значение передаваемое параметру функции.

По возвращаемому значению:

- Возвращающие значение
- Не возвращающие значение (всегда возвращает undefined)

##### Опциональные параметры

Если задать функцию с одним параметром, а передать несколько, то ошибки не будет:

```js
square = x => x*x;
console.log(square(4, 'a', "string"));
// 16
```

JS-это не строгий язык, т.е. можно передать несколько параметров, но не все параметры будут использоваться. Если же передать меньше параметров, то В таком случае остальные параметры будут undefined.

Можно использовать данный побочный эффект в своих целях, например:

```js
const minus = (a, b) => {
    if (b === undefined) {
        return -a;
    }
    return a - b;
}

console.log(minus(10)); // -10
console.log(minus(10, 5)); // 5
```

В случае отсутствия значения параметра b, посчитается условие.

Если написать = (равно), после параметра, то данный параметр будет иметь значение по умолчанию:

```js
const minus = (a, b = 0) => {
    return a - b;
}
console.log(minus(10)); // 10
console.log(minus(10, 5)); // 5
```

#### По побочному эффекту

**Чистые функции** - без побочных эффектов, как правило возвращают значение:

```js
const sum = (a, b) => {
    return a + b;
}
```

**Функции с явными побочными эффектами**:

```js
const sum = (a, b) => {
    console.log(a + b);
}
```

**Гибридные функции**:

```js
const sum = (a, b) => {
    console.log(a + b);
    return a + b;
}
```

### Стрелочные функции

В ES2015 появились стрелочные функции, в них убрано ключевое слово function:

```js
const sum = (a, b) => 
{
    return a + b;
}
```

Если параметр функции один, то можно убрать скобки:

```js
const square = a => 
{
    return a * a;
}
```

Но, если параметров нет вообще, то пустые скобки нужны:

```js
const square = () => 
{
    return 2 * 2;
}
```

**Неявный возврат** - если функция возвращает одно выражение, то можно убрать фигурные скобки и ключевое слово return:

```js
const square = () => 2 * 2;
```

Можно устанавливать параметры по умолчанию:

```js
const sum = (a = 0, b = 0) => 
{
    return a + b;
}
```

### Стек вызовов

ОЗУ в JS делится на 3 вида памяти:

- Стековая память (stack memory) - специализированная область памяти, предназначенная для хранения стека вызовов
- Динамическая память (dynamic memory) - область памяти, которая может быть выделена и освобождена динамически во время выполнения программы
- Куча (heap) - область памяти, которая используется для хранения данных, которые не имеют фиксированного размера

Стековая память используется для хранения **стека вызовов**

Когда вызывается функция, она добавляется на вершину стека вызовов, если внутри нее выполняется еще функция, то следующая добавляется выше и т.д.
Когда функция завершает свое выполнение, она удаляется из вершины стека и так до тех пор пока стек не освободится.

Если вызовов функций слишком много, например в случае неправильной рекурсии, то стек будет переполнен и программа завершится с ошибкой: **Maximum call stack size exceeded**

### Область видимости

- Глобальная область видимости
- Область видимости функции
- Область видимости блока
- Вложенная область видимости

Глобальные переменные являются свойствами объекта window для браузера или объекта global для Node.js

### Лексический контекст

Лексический контекст или окружение - это область видимости, которая определяется местом объявления переменной. Она имеет следующие правила:

1. Глобальные переменные видны во всех областях видимости
2. Все переменные любых локальных областей видят глобальную область
3. Переменные и объекты в локальной области видят все вложенные в нее области видимости

Каждый раз при вызове любой функции создается структура данных похожих на объект - **лексический контекст. Данная структура содержит все переменные функции и вне ее, к которым она будет обращаться:

```js
const lastName = "Petrov"
// lexical env: { lastName: "Petrov" }
function getFullName(firstName) {
    // lexical env: { lastName: "Petrov", firstName: <будет определено в момент запуска функции> }
    const fullName = firstName + " " + lastName;
    // lexical env: { lastName: "Petrov", firstName: <будет определено в момент запуска функции>, fullName: <будет вычислено в момент запуска функции> }
    return fullName;
}

getFullName("Ivan"); // "Ivan Petrov"
// lexical env в момент вызова стал таким: { lastName: "Petrov", firstName: "Ivan", fullName: "Ivan Petrov" }
```

Когда функция определена но, не выполнена, в ее лексическом контексте нет многих переменных, но есть для них задел (ключи). В момент запуска функции пробелы заполняются значениями.

#### Неправильное использование контекста

```js
const houses = [];

let i = 0;
while (i<10){
    let house = function(){
        console.log(i); // вывод номера дома по порядку
    }
    houses.push(house) 
    i++;
}

houses[0](); // 10 
houses[9](); // 10
```

Видим, что первый дом имеет номер 10 и последний тоже. Это потому-что лексический контекст общий у всех функций в массиве. Контекст содержит общую переменную i, которая к концу цикла выросла до 10. А т.к. вызов функций происходит мосле цикла, то они все видят десятку: `{ i: 10 }`

Для исправления ситуации нужно номер дома (текущее значение i) сохранять внутри блока цикла:

```js
const houses = [];

let i = 0;
while (i<10){
    let houseNumber = i
    let house = function(){
        console.log(houseNumber); // вывод номера дома по порядку
    }
    houses.push(house) 
    i++;
}

console.log(houses[0]()); // 0
```

Или еще глубже, в теле функции.

### Замыкания

Возможность передавать функцию как значение, плюс факт того, что каждый раз при вызове одной и тоже функции внутри области видимости каждого вызова создаются независимые переменные, открывает побочный эффект - **замыкание**:

```js
function makeCounter() {
    let count = 0;
    return () => count++;
}
const counter = makeCounter();
console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2
```

Тут стрелочная функция которая имеет доступ к внешней переменной count называется замыканием.
Легко сравнить замыкание как функцию которая запускается в среде окружения, в которой уже задана некая переменная, причем эта среда активируется именно в том месте из которого запустили замыкание.

Этапы создания замыкания:

- создать функцию
- внутри объявить замкнутые переменные
- вернуть из функции функцию

Замыкания очень полезны:

1. для кеширования или хранилищ данных, защищенных из внешнего кода
2. скрытие переменных в модулях (когда подключенно несколько скриптов с одинаковыми именами)
3. создание счетчиков

#### 1. Кеширование

Функция вычисляющая квадрат числа и сохраняющая результат в кэше:

```js
function closureFunction{
    const cache = {};
    return (x) => {
        if (cache[x]) return cache[x];
        const result = x * x;
        cache[x] = result;
        return result;
    }
}

const square = closureFunction();

console.log(square(5)); // 25
console.log(square(5)); // 25
```

#### 2. Модули

```js
(function (){
    const sliderTexts = ['Promo', 'Brands', 'Best'];
    function showSlider(text){
        console.log(text[0]);
        console.log(text[1]);
        console.log(text[2]);
    }
    showSlider(sliderTexts);
}());
```

Данная функция сразу вызывается и исполняется. Переменная sliderTexts - не видна другим и может быть переиспользвана.

#### 3. Счетчики

```js
const createCounter = () => {
    let count = 0;
    return () => count++;
}

const counter = createCounter();

console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2
```

#### Недостатки замыканий

Каждый раз при новом вызове любой функции создается лексическое окружение, котрое удаляется после выполенения функции. Т.к. часто для замыкания присваивают некой переменной функцию, в результате лексическое окружение остается в памяти, до завершения работы программы или до закрытия браузера, т.к. наличие ссылки (переменной) на функцию препятствует удалению лексического окружения и замкнутых в нем переменных. Поэтому болошое количество замыканий приводит к утечке памяти.

### Рекурсия

Функция которая сама себя вызывает называется **рекурсивная функция**

Рекурсию применяют для воспроизведения повторяющихся действий:

1. Для обхода вложенной структуры дерева каталога или документа (DOM)
2. Для математических вычислений, которые поддаются разбиению типа:
    **Сложное вычисление = простая операция, примененная к вычислению попроще**
    $2^{10} = 2^9 \times 2 => b^{e} = b^{e-1} \times b$

```js
function power(base, exponent){
    if (exponent === 0) { // Главное задавать условие выхода иначе будет бесконечная рекурсия
        return 1;
    } else {
        return base * power(base, exponent - 1);
    }
}
console.log(power(2, 3)); // 8
```

Данная реализации вычисления степени числа в три раза медленнее чем вариант с циклом.



### Именование функций

Функции должны начинаться с глагола и с маленькой буквы.

```js
function getSum(a, b) {
    return a + b;
}
```

Не нужно давать слишком длинные имена функциям, типа **getSumOfTwoNumbers**

### Браузерные события

У HTML-тегов есть атрибут onclick, который выполняет код при нажатии мышью по тегу.

Для того чтобы не писать длинные инструкции в атрибуте onclick, можно использовать функцию-обработчик:

```html
<button onclick="buy()">Buy</button>
<script>
    function buy() { 
        alert('Congratulations! You have bought a good!');
        alert('Good luck!'); 
    }
</script>
```

## 07. Lecture

### Циклы

Цикл - набор инструкций, который выполняется несколько итераций до удовлетворения условий выхода.

Тело цикла - набор инструкций.

Итерация - повторение тела цикла.

Условие выхода из цикла - условие, при котором цикл завершается.

#### Цикл while

Цикл с предусловием:

```js
let i = 0;
while (i < 10) {
    console.log(i);
    i++;
}
```

Очень удобен для бесконечных циклов.

#### Цикл do-while

Цикл с постусловием:

```js
let i = 0;
do {
    console.log(i);
    i++;
} while (i < 10);
```

Тело цикла проверяется на условие после выполнения. Следовательно минимум один раз цикл выполнится. Полезно например при вводе пароля, а потом его проверки до тех пор пока не введут верный.

#### Цикл for

Цикл с инициализацией, условием и инкрементом:

```js
for (let i = 0; i < 10; i++) {
    console.log(i);
}
```

Самый популярный цикл.

#### Прерывание цикла

Выход из цикла происходит:

- если условие выхода из цикла возвращает **false**
- если встречается инструкция **break**

Выход из итерации цикла, но не выход из цикла:

- при достижении конца тела цикла, если условие выхода из цикла возвращает **true**
- если встречается инструкция **continue**

### Массивы

Имя массива (переменная) - это указатель на область памяти объекта. Т.к. массив это наследник объекта:

```js
typeof [] // object
```

Чтобы случайно не переименовать или удалить имя массива делают константным, элементы массива все еще могут быть изменены:

```js
const arr = [1, 2, 3];
arr[0] = 10;
console.log(arr); // [10, 2, 3]
```

Элементы массива хранятся как значения свойств объекта. А индексы как ключи свойств объекта. 
К свойствам любого объекта можно обращаться через точечную нотацию или квадратные скобки. Но, обращаться используя точечную нотацию можно только свойствам (переменным), которые начинаются с буквы или символа подчеркивания и не имеют пробелов, иначе нужно обращаться через квадратные скобки:

```js
value[2] // нельзя value.2
value["John Doe"] // нельзя value.John Doe
```

Поэтому для доступа к элементам массива, как наследнику объекта, нельзя обращаться через точечную нотацию - индексы нужно обрамлять квадратными скобками.

Как и строки, массив имеет свойство **length** - количество элементов в массиве.

У массивов помимо встроенных свойств есть и методы.

#### concat

Конкатенация массивов:

```js
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const arr3 = arr1.concat(arr2);
console.log(arr3); // [1, 2, 3, 4, 5, 6]
```

Аргументов concat(2) можно передать обычное число, тогда оно буде добавлено справа

#### push

Добавление одного или нескольких элементов в конец массива:

```js
const arr = [1, 2, 3];
arr.push(4, 5);
console.log(arr); // [1, 2, 3, 4, 5]
```

#### pop

Извлекает и удаляет последний элемент массива:

```js
сonst arr = [1, 2, 3];
arr.pop();
console.log(arr); // [1, 2]
```

#### shift

Удаляет первый элемент массива, сдвигая все остальные элементы влево:

```js
const arr = [1, 2, 3];
arr.shift();
console.log(arr); // [2, 3]
```

#### unshift

Добавляет один или несколько элементов в начало массива:

```js
const arr = [1, 2, 3];
arr.unshift(4, 5);
console.log(arr); // [4, 5, 1, 2, 3]
```

#### slice

Скопировать массив, путем копирования его имени переменной, создаст вторую ссылку на один и тот же массив. 

Копирует часть или весь массив:

```js
const arr = [1, 2, 3, 4];

const all = arr.slice();
console.log(all); // [1, 2, 3, 4]

const start = arr.slice(1);
console.log(start); // [2, 3, 4]

const overload = arr.slice(14);
console.log(overload); // []

const minus = arr.slice(-2);
console.log(minus); // [3, 4]

const range = arr.slice(1, 3);
console.log(range); // [2, 3]

const startMinus = arr.slice(1, -1);
console.log(startMinus); // [2, 3]
```

#### splice

Удаляет элементы массива:

```js
const arr = [1, 2, 3];
arr.splice(1, 2);
console.log(arr); // [1, 3]
```

#### indexOf

Метод возвращает индекс первого искомого вхождения (самого левого) элемента в массиве:

```js
const arr = [1, 2, 3];
console.log(arr.indexOf(2)); // 1
```

Если элемент не находится в массиве, то возвращается -1.

В методе можно указать второй параметр, который определяет с какого индекса начать поиск:

```js
const arr = [1, 2, 3];
console.log(arr.indexOf(2, 1)); // 1
```

#### lastIndexOf

Метод возвращает индекс последнего искомого вхождения (самого правого) элемента в массиве:

```js
const arr = [1, 2, 3, 2];
console.log(arr.lastIndexOf(2)); // 3
```

Метод, как и indexOf имеет второй необязательный параметра, место к которого начать поиск.

#### map

Метод возвращает новый массив, состоящий из результатов вызова функции для каждого элемента массива:

```js
const arr = [1, 2, 3];
const newArr = arr.map(item => item * 2);
console.log(newArr); // [2, 4, 6]
```

#### reverse

Метод переворачивает массив:

```js
const arr = [1, 2, 3];
arr.reverse();
console.log(arr); // [3, 2, 1]
```

#### Массивы с циклами

Цикл очень часть используется при работе с массивами:

##### for

```js
const arr = [1, 2, 3];

for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}
```

##### for of

Цикл для массива можно записать короче:

```js
for (let item of arr) {
   console.log(item); 
}
```

Цикл был разработан для решения проблемы **сурогатных пар** (см. строки), позволяет итерироваться по знакам занимающим две символьные единицы:

```js
let roseDragon = "🌹🐉";
for (let char of roseDragon) {
  console.log(char);
}
// → 🌹
// → 🐉
```

##### forEach

```js
arr.forEach(item => console.log(item));
```

### Строки

Строки - это примитивы. Поэтому, при работе с ними происходит приведение типов.

Кодовая единица (code unit) для одного символа в строке составляет 2 байта и он закодирован в UTF-16.
Некоторые символы выходящие за 16-битный диапазон хранятся как два символа и называются **суррогатными парами**
При обращении к методам строки, происходит оборачивание строки в объект.

```js
console.log(characterScript(121));

const emoji = "😊";

console.log(emoji.length); // ❗ 2, а не 1
console.log(emoji.charCodeAt(0)); // d83d (старший суррогат)
console.log(emoji.charCodeAt(1)); // de0a (младший суррогат)
console.log(emoji.codePointAt(0)); // полноценный суррогат
console.log(emoji[0]);  // � (неправильный символ)
```

При попытке добавить новый метод, ничего не получится в отличие от объекта.


```js
let kim = "Kim";
kim.age = 88
console.log(kim); // underfined
```

Но, встроенных методов предостаточно

#### charCodeAt

Выводит в примере выше только кодовую единицу, т.е. старший сурогат

#### codePointAt

Возвращает полноценный Unicode суррогат. Метод был разработан когда встала проблема **сурогатных пар**

#### slice

```js
let str = 'Hello';
console.log(str.slice(1, 3)); // el
```

#### substr

```js
let str = 'Hello';
console.log(str.substr(1, 3)); // ell
```

#### substring

```js
let str = 'Hello';
console.log(str.substring(1, 3)); // el
```

#### replace

```js
let str = 'Hello';
console.log(str.replace('l', 'L')); // HelLo
```

#### split

```js
let str = 'Hello';
console.log(str.split('')); // ['H', 'e', 'l', 'l', 'o']
```

#### charAt

```js
let str = 'Hello';
console.log(str.charAt(1)); // e
```

#### indexOf

```js
let str = 'Hello';
console.log(str.indexOf('ll')); // 2
```

В отличие от одноименного метода массива, для строки можно указывать несколько символов для поиска

#### length

```js
let str = 'Hello';
console.log(str.length); // 5
```

#### toUpperCase

```js
let str = 'Hello';
console.log(str.toUpperCase()); // HELLO
```

#### toLowerCase

```js
let str = 'Hello';
console.log(str.toLowerCase()); // hello
```

#### trim

Удаляет крайние пробелы, переносы строк, табуляцию и однотипные символы:

```js
let str = '   Hello   ';
console.log(str.trim()); // Hello
```

#### padStart

Добавляет указанное количество символов в начало строки:

```js
let str = 'Hello';
console.log(str.padStart(10, '0')); // 00000Hello
```

#### repeat

```js
let str = 'Hello';
console.log(str.repeat(3)); // HelloHelloHello
```

## 09. Lecture

### Объекты

Правила создания объектов:

1. Объекты объявляются с помощью ключевого слова **const**.
2. Определение (тело) объекта заключается в фигурных скобках. Фигурные скобки обрамляют также начало и конец блока инструкций, например функции. Встречаются случаи когда надо явно отличить функцию от объекта:

    ```js
    n => { prop: value } // treated as function
    n => ({ prop: value }) // treated as object
    ```

3. Имя (ключ) свойства отделяется от значения свойства двоеточием.
4. Имя свойства может быть любым
5. Объект не может содержать дублирующиеся имена свойств.
6. Все свойства объекта объявляются через запятую.

```js
const user = {
    name: 'John',
    age: 30
};
```

Чтобы заменить значение свойства объекта используют знак равно =:

```js
const user = {
    name: 'John',
    age: 30
};

user.age = 40;
user.lastname = 'Smith';

console.log(user); // {name: "John", age: 40, lastname: "Smith"}
```

Если при присваивании значения свойству через знак равно такого нет, то оно создастся автоматом.

Для удаления свойства объекта применяется оператор **delete**:

```js
delete user.age;
```

При обращении к несуществующему свойству возвращает **undefined**:

```js
console.log(user.age); // undefined
```

Но, есть разница между удалением свойства и присвоением ему **undefined**:

```js
user.age = undefined;
console.log(user.age); // undefined
```

С помощью оператора **in** можно проверить наличие свойства в объекте:

```js
console.log('lastname' in user); // true
console.log('age' in user); // false
```

При сравнении объектов == сравниваются их указатели и проверяется их идентичность, но не содержание.

#### Свойства объектов

Почти все типы данных в JS имеют свойства, за исключением null и underfined. Если обратиться к их свойствам, то получим ошибку:

```js
null.length; // TypeError: Cannot read properties of null (reading 'length')
null["length"]; // TypeError: Cannot read properties of null (reading 'length')
```

Имена свойств объектов это строки.

Обращение к свойству объекта через точку:

```js
const user = {
    name: 'John',
    age: 30
};

console.log(user.name); // John
console.log(user.age); // 30
```

В любой момент можно добавить новое свойство:

```js
const user = {
    name: 'John',
    age: 30
};

user.isAdmin = true;
console.log(user); // {name: "John", age: 30, isAdmin: true}
```

Свойства можно удалять:

```js
const user = {
    name: 'John',
    age: 30
};

delete user.age; // true
console.log(user); // {name: "John"}
```

При успешном удалении свойства возвращается true, иначе false (например защищенный объект браузера).

При указании переменных в качестве аргументов функции передаются только их значения, исходные переменные остаются нетронутыми. При указании имени объекта в качестве аргумента функции передает указатель на этот объект. Поэтому при изменении объекта внутри функции, изменится исходный объект.

##### Короткое присваивание свойств объекта

Если при создании объекта передаются переменные в качестве свойств и без значений, то значения берутся из переменных, а ключами свойств становятся имена переменных.

```js
let event = "hello";
let squirrel = "World";
const obj = {event, squirrel}; // same as - const obj = {event: "hello", squirrel: "World"}
console.log(obj); // { event: 'hello', squirrel: 'World' }
```

##### Опциональное обращение к свойству объекта

Если нет уверенности, что обращение к свойству объекта существует, то можно использовать **?.**:

```js
const user = {
    name: 'John',
    age: 30
};

console.log(user?.name); // John
console.log(user?.lastName); // undefined
```

Можно использовать как точечную нотацию, так и квадратные скобки:

```js
const user = {
    name: 'John',
    age: 30
};

console.log(user?.['name']); // John
console.log(user?.['lastName']); // undefined
```

Данный механизм позволяет избежать выброса исключения при обращении к несуществующему свойству.

#### Пользовательские методы объекта

Методы объекта это свойства которым присвоены функции.

В объекте принято методе объявлять после свойств:

```js
// Объект робот-пылесос
const Roomba = { // Есть негласное правило называть объекты в алгоритмах с большой буквы.
    // Обычно сначала объявляют свойства объекта.
    model: "Romba-1",
    power: 200,
    batterySize: 2100,
    boxSize: 0.5,
    workTime: 45,
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    isUVLampOn: false,
    // После свойств объявляют его методы.
    startCleaning: function () { // увеличивает счетчик стартов робота и выводит сообщение о старте
        this.counterOfStarts++;
        console.log('I am cleaning... I have been started: ', this.counterOfStarts, 'times.');
    },
    goCharge: function () { // отправка на зарядку
        console.log('I am going to charge...');
    },
    switchUVLamp: function () { // вкл.выкл ультрафиолетовой лампы
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' : 'not working'}.`);
    }
};

// Обращение к свойствам объекта.
console.log(Roomba.model); // "Romba-1"
console.log(Roomba.isFull); // false
// Вызов методов объекта.
Roomba.startCleaning(); // 'I am cleaning... I have been started: 1 times.'
// Установим свойства объекта isUVLampOn в true, чтобы продемонстрировать результат работы метода switchUVLamp.
Roomba.switchUVLamp(); // 'UV lamp is working.'
Roomba.goCharge(); // 'I am going to charge...'
```

Методы могут обращаться к свойствам объекта с помощью ключевого слова **this**

#### this

Ключевое слово this означает текущий объект, оно также доступно в любой функции:

```js
// Работа с this
const checkThis = function() {
    console.log(this);
}
checkThis(); // Window {0: global, window: Window, self: Window, document: document, name: "", location: Location, ...}
```

Из лексического контекста данной фукнции видно, что this (текущий объект) ссылается на глобальный объект window, в случае браузера или global в node.js

Внутри методов объекта this указывает на сам объект, в котором он был объявлен:

```js
const checkThisInObject = {
    testProperty: true,
    checkThis: function () {
        console.log(this);
    },
};
checkThisInObject.checkThis(); // {testProperty: true, checkThis: ƒ}
```

Контекст не указывает никаких глобальных объектов, следовательно this - это сам объект, но есть нюансы.

#### Одалживание методов

Создадим улучшенного робота-пылесоса, на основе первого:

```js
// Объект робот-пылесос модель Tango.
const Tango = { 
    model: "Tango-1",
    power: 300,
    batterySize: 3200,
    boxSize: 0.7,
    workTime: 60,
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    isUVLampOn: false,
    // После свойств объявляют его методы. А так как методы у новой модели такие же как и у старой, давайте позаимствуем их у объекта Roomba.
    startCleaning: Roomba.startCleaning,
    goCharge: Roomba.goCharge,
    switchUVLamp: Roomba.switchUVLamp,
};

console.log(Tango.model); // "Tango-1"
console.log(Tango.isFull); // false
// Вызов методов объекта.
Tango.startCleaning(); // 'I am cleaning... I have been started: 1 times.'
// Результат вызова следующего метода зависит от значения, хранящегося в свойстве объекта, а также от того как этот метод был вызван (об этом поговорим чуть ниже).
Tango.switchUVLamp(); // 'UV lamp working.'
Tango.goCharge(); // 'I am going to charge...'
```

Создадим третьего робота, но объекты экспортируем с помощью внешних способов:

```js
const Samba = {
    model: "Samba-1",
    power: 250,
    batterySize: 2500,
    boxSize: 0.5,
    workTime: 50,
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    isUVLampOn: false,
    // На этот раз мы не будем создавать методы в объекте, мы постараемся их заимствовать непосредственно перед использованием.
};

// Одолжим методы из объекта Roomba.
Samba.startCleaning = Roomba.startCleaning;
Samba.switchUVLamp = Roomba.switchUVLamp;
Samba.goCharge = Roomba.goCharge;
Samba.startCleaning(); // 'I am cleaning... I have been started: 1 times.'
// Результат вызова следующего метода зависит от значения, хранящегося в свойстве объекта, а также от того как этот метод был вызван (об этом поговорим чуть ниже).
Samba.switchUVLamp(); // 'UV lamp is working.'
Samba.goCharge(); // 'I am going to charge...'
```

Лампа работает по принципу одной кнопки (вкл/выкл). Сейчас лампа включена
Предположим мы хотим включить лампу по расписанию через пять секунд:

```js
setTimeout(Samba.switchUVLamp, 5000); // 'UV lamp is working.'
```

Но, лампа не выключается. Потому что через 5 секунд объкта Samba уже нет и внутренняя this ссылается несуществующий объект, т.е. undefined.

Можно обернуть метод в анонимную функцию, тогда ссылка на Samba сохраниться в лексическом контексте функции и объект не будет удален:

```js
setTimeout(function() {
    Samba.switchUVLamp();
}, 5000); // 'UV lamp in not working.'
```

Можно вместо анонимной функции использовать методы call, apply или bind

#### Встроенные методы объектов

### call

Метод call позволяет вызвать метод в контексте другого объекта, на примере объекта Roomba:

```js
const notARobot = {
    counterOfStarts: 10,
}

Roomba.startCleaning.call(Roomba); // 'I am cleaning... I have been started: 1 times.'
Roomba.startCleaning.call(notARobot); // 'I am cleaning... I have been started: 10 times.'
```
В последнем вызове метода мы передали с помощью call контекст другого объекта и он выполнился со своим свойством counterOfStarts равным 10. Если в качестве второго и последующих аргументов call что-то передать, то данные параметры пойдут в вызываемый метод

### apply

Аналогичен методу call, только второй параметр передается в виде массива:

```js
Roomba.startCleaning.apply(Roomba, [1, 2, 3]); // 'I am cleaning... I have been started: 10 times.'
```

### bind

Позволяет привязать контекст к фукнции (методу) навсегда:

```js
Samba.startCleaning = Roomba.startCleaning.bind(Samba);
```

Методы можно добавить в объект, путем присвоения функции как значения свойства:

```js
const user = {
    make: 'Audi',
    model: "A6",
    year: 2008,
    startEngine: function() {
        console.log('Engine is started');
    }
};

user.startEngine(); // Engine is started
```

#### for in

Цикл for in используется для перебора свойств объекта:

```js
const user = {
    name: 'John',
    age: 30
};

for (let key in user) {
    console.log(key); // name, age - вывод всех ключей свойств объекта
    console.log(user[key]); // John, 30 - вывод всех значений свойств объекта
}
```

#### Объект в массив

У массивов для преобразование его элементов и помещения результатов в новый массив можно использовать метод **map**. Но, у объектов такого метода нет, поэтому для преобразования объекта в массив необходимо использовать методы **Object.values** и **Object.keys**.

##### Object.keys

Для сохранения в массив ключей объекта используется метод **Object.keys**:

```js
const user = {
    name: 'John',
    age: 30
};

const array = Object.keys(user); // ["name", "age"]
```

#### Object.values

Для сохранения в массив значений объекта используется метод **Object.values**:

```js
const user = {
    name: 'John',
    age: 30
};

const array = Object.values(user)); // ["John", 30]
```

#### Object.entries

Для сохранения в массив пар ключ-значение используется метод **Object.entries**:

```js
const user = {
    name: 'John',
    age: 30
};

const array = Object.entries(user); // [["name", "John"], ["age", 30]]
```

Можно было бы использовать для итерации for in по объекту без конвертации в массив, но в итерацию могут попасть наследуемые свойства объектов, включая прототип, при их наличии.

```js
const user = {
    name: 'John',
    age: 30
};

for (let key in user) {
    console.log(key); // name, age, toString, constructor
    console.log(user[key]); // John, 30, [object Object], [object Object]
}
```

Поэтому лучше преобразовывать в массив с помощью Object.keys, Object.values или Object.entries и далее работать с данными внутри массива.

#### Object.assign

Для копирования свойств одного объекта в другой используется метод **Object.assign**:

```js
const user = {
    name: 'John',
    age: 30
};

const clone = Object.assign({}, user); // {name: "John", age: 30}
```

#### Math

Объект Math объединяет в себя математические методы, для того чтобы не плодить глобальные функции, дабы не засорять глобальное пространство имен. Иначе, велика вероятность что функции, либо переменные создаваемые пользователем могут случайно совпасть с библиотечными.

#### Математические константы

Такие как $\pi$, $e$ и другие, доступны в объекте Math. и записываются прописными буквами:

```js
console.log(Math.PI); // 3.141592653589793
console.log(Math.E); // 2.718281828459045
```

#### Math.random

Возвращает псевдослучайное число от 0 включительно до 1 не включительно:

```js
console.log(Math.random()); // 0.123456789
```

Если необходимо сгенерировать случайное целое число, то в купе с текущей функцией используют округление

#### Math.floor

Округляет до наименьшего целого числа, которое меньше или равно указанному числу:

```js
console.log(Math.floor(2.9)); // 2
```

#### Math.ceil

Округляет до наибольшего целого числа, которое больше или равно указанному числу:

```js
console.log(Math.ceil(2.1)); // 3
```

#### Math.round

Округляет до ближайшего целого числа по правилам математики:

```js
console.log(Math.round(2.4)); // 2
console.log(Math.round(2.6)); // 3
```

#### Math.abs

Возвращает модуль числа:

```js
console.log(Math.abs(-5)); // 5
console.log(Math.abs(5)); // 5
```

### Глобальные объекты

В среде JS всегда есть один глобальный объект, от которого происходят остальные объекты.

Имя такого первичного объекта всегда зависит от среды исполнения JS:

- **window** в браузере
- **global** в Node.js
- **WorkerGlobalScope** в веб-воркере

Эти объекты не являются частью языка, они являются частью движка на котором ведется работа. Глобальный объект нужен для взаимодействия со средой в которой исполняется код.

Все методы и свойства глобального объекта доступны везде без указания window или global:

```js
console.log(this); // window
window.console.log(window); // window
console.log(global); // global
console.log(this === window); // true
console.log(this === global); // true
```

### Функции высшего порядка

ПО можно конструировать двумя способами, где:

1. Код простой и очевидно без дефектов
2. Код сложный и без очевидных дефектов

$\copyright$ Theories of Programming: The Life and Works of Tony Hoare

#### 1. Простой код

```js
function range{
    pass
}

function sum{
    pass
}

console.log(sum(range(1,10)));
```

Посчитать сумму о одно до десяти.

#### 2. Сложный код

```js
let total = 0;
let count = 1
while(count <= 10){
    total += count;
    count += 1;
}

console.log(total)
```

#### Абстракция

В пример 1.Простой код использованы словарь функций (sum, range) Словарь функций представляет собою набор функций которые выполняют определенную задачу.

Проблема в том, что невозможно создать словарь (функции), на все случаи жизни. Но, можно использовать абстрактный подход - **функции высшего порядка**:

Можно написать конкретный цикл для повторения конкретного действия, например для вывода элементов в консоль:

```js
for (let i=0; i<10; i++) console.log(i);
```

Если нужно данное действие выполнять желаемое количество раз (n), можно поместить цикл в функцию:

```js
function repeat(n){
    for (let i=0; i<n; i++) console.log(i);
}
```

Но, что если нужен не вывод в консоль, а другое действие? Тогда можно передавать функцию в качестве аргумента в повторяющую функцию:

```js
function repeat(n, action){
    for (let i=0; i<n; i++) action(i);
}

repeat(10, console.log);
```

Можно не передавать заранее описанную функцию в качестве параметра, можно в ее тело передать в качестве аргумента значения:

```js
let labels = [];
repeat(10, i => labels.push(i+1));

console.log(labels);
```

В примере выше, опущены фигурные скобки, т.к. тело функции короткое и однострочное.

#### Типы функций высшего порядка

Функции высшего порядка бывают двух типов:

1. Функции возвращающие другие функции (замыкания)
2. Функции принимающие другие в функции в качестве своих аргументов. Функция аргумент называют callback функцией.
    2.1. Функции меняющие другие функции
    2.2. Функции изменяющие поток выполнения

##### 1. Функции возвращающие другие функции

```js
function greaterThan(n){
    return m => m > n;
}

let greaterThan10 = greaterThan(10);
console.log(greaterThan10(11)); // true
```

##### 2.1. Функции меняющие другие функции

```js
function noisy(f){
    return (...args) => {
        console.log('calling with', args);
        let result = f(...args);
        console.log('called with', args, ', returned', result);
        return result;
    }
}

noisy(Math.min)(3, 2, 1); 
// calling with [3, 2, 1]
// called with [3, 2, 1], returned 1
```

Функция `noisy` принимает другую функцию нахождения минимума в качестве аргумента и возвращает с помощью стрелочной конструкции "болтливую" версию, которая оповещает о начале и конце вызова. Для передачи аргументов болтливой функции используется цепочный вывоз:

```js
noisy(Math.min)(3, 2, 1);
```

##### 2.2. Функции изменяющие поток выполнения

```js
function unless(test, then){
    if (!test) then();
}

repeat(3, n => {
    unless(n%2 == 1, ()=>{
        console.log(n, 'is even');
    })
})
// 0 is even
```

#### Методы высшего порядка

#### forEach

Метод похожий на функцию `for of`:

```js
["A", "B", "C"].forEach(item => console.log(item));
```

#### filter

Что бы отфильтровать элементы в массиве можно создать функцию высшего порядка принимающую два аргумента:

- массив
- условия отбора (тестирующая функция).

```js
function filter(array, test){
    let passed = [];
    for (let element of array){
        if(test(element)){
            passed.push(element);
        }
    }
    return passed;
}

console.log(filter(SCRIPTS, script => scripts.living));
```

Чистая функция не модифицирует массив SCRIPTS а создает новый в соответствии с тестовыми условиями (функцией).

Как и forEach, filter является стандартным методом массива.

Предположим у нас есть массив объектов, где каждый объект содержит имя студента и его оценку за экзамен:

```js
const students = [
    { name: 'John', score: 80 },
    { name: 'Jane', score: 90 },
    { name: 'Bob', score: 70 },
    { name: 'Alice', score: 85 },
    { name: 'Charlie', score: 95 },
    { name: 'Dave', score: 75 },
    { name: 'Eve', score: 85 },
    { name: 'Frank', score: 90 },
    { name: 'Grace', score: 80 },
    { name: 'Henry', score: 85 }
];
```

Мы хотим вывести только тех студентов, у которых оценка больше 80.

```js
const goodStudents = students.filter(student => student.score > 80);
```

Используя метод console.table() можно вывести массив в виде таблицы:

```js
console.table(goodStudents);
```

#### map

Создадим функцию высшего порядка, которая трансформирует элементы массива, по заданному условию (функции).
Предположим мы хотим вывести не объекты массива SCRIPTS а свойство name этих объектов:

```js
function map(array, transform){
    let mapped = [];
    for(let element of array){
        mapped.push(transform(element));
    }
    return mapped;
}

console.log(map(SCRIPTS, s => s.name))
```

**map** также стандартный метод массива.

Предположим, что мы хотим не просто вывести студентов которые набрали 80 и более баллов, но мы хотим вывести вообще всех студентов. У тех кто прошел экзамен должно быть слово "passed", а у тех кто не прошел должно быть "Not passed":

```js
const result = students.map(student => {
    if (student.score >= 80) {
        return { name: student.name, score: student.score, result: "passed" };
    } else {
        return { name: student.name, score: student.score, result: "Not passed" };
    }
});

console.table(result);
```

В данном примере мы передаем методу map анонимную функцию, таким образом метод является функцией высшего порядка. 

#### reduce

Напишем функцию суммаризация (подсчет суммы значений массива) по заданным признакам:

```js
function reduce(array, combine, start){
    let current = start;
    for(let element of array)
        current = combine(current, element);
    return current;
}

console.log(reduce([1, 2, 3, 4], (a, b) => a+b, 0));
```

Встроенный в массив метод reduce на примере расчета общей сумму баллов всех студентов:

```js
const totalScore = students.reduce((acc, student) => acc + student.score, 0);
console.log(totalScore);
```

1. Первый аргумент в примере у метода reduce() это анонимная стрелочная функция обратного вызова. Данная функция принимает свои два аргумента:
    - acc - аккумулятор (временное хранилище которое передается при каждой итерации)
    - student - текущий элемент (student) из массива students
2. Второй аргумент - 0, это первоначальное значение аккумулятора.
3. Третий аргумент - индекс текущего элемента.
4. Четвертый аргумент - сам массив.

Чаще всего в reduce() используется первые два аргумента.

В качестве аккумулятора можно использовать объект и это расширяет возможности метода:

```js
const {sum, count} = SCRIPTS.reduce((acc,b) => {
    if(b.living == true) {
        acc.sum+=b.year
        acc.count++
    }
    return acc
},{sum: 0, count: 0})

console.log(Math.round(sum/count));
```

#### some

Используется для поиска хотя бы одного нужного элемента в массиве. Например, чтобы выяснить есть ли среди студентов прошедшие практику:

```js
const hasPassed = students.some(student => student.score >= 80);
console.log(hasPassed); // true
```

Функция обратного вызова вызывается для каждого элемента итерации и если один из них возвращает true, то some() возвращает true и завершает работу на первом попавшемся элементе.

#### every

Обратный методу some(). В массиве все элементы должны соответствовать заданному условию. Например, чтобы выяснить все ли студенты прошли практику:

```js
const hasPassed = students.every(student => student.score >= 80);
console.log(hasPassed); // false
```

#### find

Возвращает первый элемент, который соответствует условию. В противном случае возвращает undefined:

```js
const student = students.find(student => student.score >= 80);
console.log(student); // { name: 'Jane', score: 90 }
```

Возвращает первое найденное вхождение. Позволяет искать неточное совпадение.

#### findIndex

Возвращает индекс первого элемента, который соответствует условию. В противном случае возвращает -1:

```js
const index = students.findIndex(student => student.score >= 80);
console.log(index); // 1
```

Возвращает индекс первого вхождения. Позволяет искать неточное совпадение.

### Деструктуризация

Позволяет сохранять значения из массива или объекта в отдельные переменные:

```js
const numbers = [1, 2, 3];
const [a, b, c] = numbers;
console.log(a); // 1
console.log(b); // 2
console.log(c); // 3
```

```js
const person = { name: 'John', age: 30, city: 'New York' };
let { name, age, city } = person;
console.log(name); // John
console.log(age); // 30
console.log(city); // New York
```

Название переменных должно совпадать с именами свойств объекта. Но, можно переименовать любой свойство при деструктуризации:

```js
const person = { name: 'John', age: 30, city: 'New York' };
let { name: userName, age: userAge, city: userCity } = person;
console.log(userName); // John
console.log(userAge); // 30
console.log(userCity); // New York
```

При попытке деструктуризации null или underfined, будет ошибка.

### Сериализация

Свойства объектов не содержат значения, а всего лишь захватывают их указатель. Если у нас есть массив объектов или массивов, тогда происходит двойная адресация ссылки ссылаются на ссылки памяти, содержащие реальные значения. Можно сделать дамп памяти для отправки содержимого по сети, но это не удобно и долго. Для того, что бы сохранить чистые данные без привязки к участками памяти, существует процедура сериализации. Сереализованные данные легко переносить по сети между разными устройствами или с разной архитектурой.

#### JSON

Формат очень похож на объекты JS, но имена свойств (ключи) обрамлены двойными кавычками:

```json
{
    "name": "John",
    "age": 30
}
```

##### JSON.stringify

Для конвертации объекта JS в JSON:

```js
const person = { name: 'John', age: 30 };
const json = JSON.stringify(person);
console.log(json); // {"name":"John","age":30}
```

##### JSON.parse

Для конвертации JSON в объект JS:

```js
const json = '{"name": "John", "age": 30}';
const person = JSON.parse(json);
console.log(person); // { name: 'John', age: 30 }
```

# ECMAScript

## 01.Lecture

В ES2015 появились новые операторы:

- **spread** - распаковывает массив (объект) или другие структуры данных в атомарные элементы
- **rest** - принимает неограниченное количество параметров

#### spread оператор

**Spread** - расширять, распространять.

Любая фунrция содержит служебную переменную arguments, которая является псевдомассивом. Псевдомассив не имеет стандартных методов как настоящий массив, типа forEach. Поэтому при передаче в фукнцию неограниченного количетсва переменных, мы не сможешь по ним итерироваться как по массиву. Можно только с помощью классического for, что не всегда удобно. Использую spread оператор:

```js
function sum(a, b, c) {
    const args = [...arguments];
    console.log(args);
}
```

Распаковывает массив (объект) или другие структуры данных:

```js
const sum = (a, b, c) => {
    return a + b + c;
}
const arr = [1, 2, 3];
console.log(sum(...arr)); // 6
```

Можно распаковывать внутри другого массива или объекта:

```js
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const arr3 = [...arr1, ...arr2];
console.log(arr3); // [1, 2, 3, 4, 5, 6]
```

#### rest оператор

**Rest** - остальные, подобные, другие. Позволяет собрать другие оставшиеся аргументы в массив, тогда не нужно будет использовать пведомассив arguments.

```js
let summa
function sum(...rest) {
    for (let i = 0; i < rest.length; i++) {
        summa += args[i];
    }
}

sum(1, 2, 3, 4, 5);
console.log(summa); // 15
```

rest можно комбинировать с обычными аргументами фукнции:

```js
function sum(name, lastname, ...rest) {
    console.log(`your name is ${name} surname is ${lastname} and other ${rest}`);
}
```

### Чистые функции

Чистая функция: 

- не контактирует с глобальными переменными
- получает данные только чрез аргументы
- возвращает одно и тоже (ожидаемое) значение
- легко переиспользуемы в других местах или коде

При создании чистой функции следуюет быть внимательным к изменемым типам аднных, например объектам,
т.к. свойства объекта легко изменить извене, следует создавать копию объекта внутри функции:

```js
const addPropToObj(object, key, value){
    return {
        ...object,
        [key]: value
    }
}
```

Нечистые функции используещие **побочне эффекты** - получение данных по сети или из БД, тоже нужны и без них нельзя. Но, нужно стараться по максимуму использвать чистые, а обращения по сети и к БД выносить в грязные функции.
