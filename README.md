# JavaScript Basics

This repo contains my JS code from lectures and labs by GeekBrains online university. 

## 01. Lecture

### Intro

01.Lecture

**HTML** - язык разметки для веб-страниц

**CSS** - язык оформления HTML

**JS** - язык программирования или движок для веба и бекенда

### Движки

- V8
- Rhino
- SpiderMonkey
- JSC
- Chakra

Движки написаны на C++. Они интерпретируют скрипты на JS. Как правило движки встроены в прикладное ПО:

- Браузеры
- Node.js, Electron, React Native, Deno
- ПО для встраиваемых систем (роботы, Falcon 9, Iskra)

В свою очередь прикладное ПО работает в системных средах:

- Браузер установленный на десктопные OC (Windows, Linux, macOS)
- Node.js, Electron установленные на серверные OC (Windows, Linux, FreeBSD, macOS)
- Киоски (банкоматы, терминалы оплаты и т.д.) - легкая версия ОС с браузером

### Стандарты

ECMA international -  European Computer Manufacturers Association - Европейская ассоциация по стандартизации компьютерного производства. 

Наиболее известные стандарты ECMA:

- ECMA-376(OOXML) - Office Open XML
- ECMA-119 (ISO9660) - формат CD-ROM и DVD-ROM 
- ECMA-267 (UDF) - перезаписываемый формат CD-ROM и DVD-ROM
- ECMA-262 (ECMAScript) - язык программирования JavaScript

ECMAScript состоит из релизов:

- ES5
- ES6
- ES2022
- ES6+ - современный JS

### Этапы выполнения кода в браузере

1. Создается структура HTML-документа
2. Применяются стили
3. Добавляется контент (картинки, мультимедиа)
4. К странице подключается скрипт и выполняется

Браузер начинает выполнять JS-код в момент обнаружения его в html, поэтому рекомендуется помещать его в конце документа. Либо использовать специальные атрибуты.
Если произошла ошибка в коде, то браузер выдает сообщение в консоли, но продолжает загрузку контента, html и дальнейшего JS-кода.
Код выполнятся даже после того как все загрузилось, все время пока страница открыта.

### Переменные

- let
- const
- var

#### let и const

Ключевые слова let и const появились в ES2015:

- let для объявления переменных с блочной областью видимости

```js
let age = 10;
age = 15;
```

- const для объявления констант с блочной областью видимости их нельзя изменять

```js
const GAP_SIZE = 10;
GAP_SIZE = 15; // TypeError
```

#### var

До ES5 с помощью ключевого слова **var** инициализировали переменные. В современном релиза **var** осталась, но используется немного по другому:

1. Для объявления глобальных переменных.
2. Для инициализации переменной без присвоения значения:

```js
var a;
```

Значением переменной **a** будет **undefined**.

### Всплытие

**Hoisting** (всплытие) - уникальный механизм JS, позволяющий обращаться к значению переменной до ее объявления с помощью **var**. Значением при всплытии такой переменной будет undefined.

```js
console.log(age); // underfined
var brotherAge = age + 12
console.log(brotherAge) // Nan
var age = 10

console.log(name)
let name = "Ivan" // Uncaught ReferenceError
```

### Типы данных

В JS есть 8 типов данных:

1. string (строка)
2. number (число)
3. boolean (булевый)
4. undefined (неопределенный)
5. object (объект)
    - array (массив)
    - function (функция)
6. null (нуль)
7. BigInt (большое число)
8. symbol (символьный)

Примитивные типы данных в JavaScript не являются объектами и не имеют методов или свойств. Однако, когда вы пытаетесь использовать метод или свойство примитивного типа данных, JavaScript автоматически оборачивает его в объект, чтобы предоставить доступ к методам и свойствам.
Например, когда вы пытаетесь использовать метод toUpperCase() на строке, JavaScript оборачивает строку в объект String и предоставляет доступ к методу toUpperCase().

Для определения типа данных используют typeof:

```js
console.log(typeof 10); // number
```

Все типы данных отличаются:

- встроенными методами
- методами сравнения

#### Строка

Строка это текст в кавычках (одинарных, двойных или обратных):

```js
let name = "Ivan";
let lastName = 'Petrov';
let fullName = `Ivan Petrov`;
```

#### Шаблонный литерал

Строки внутри обратных кавычек называют **шаблонным литералом**

#### Числа

**Number** - это целое или дробное число, как в десятичной так и в других системах счисления, включая шестнадцатеричную. Для чисел есть ограничения от -2^53 до 2^53 не включительно.

Есть специальны значения, которые также имеют тип **number**:

- Infinity
- -Infinity
- NaN

Infinity, это число, которе получается в математических операциях, типа деления на ноль. 

```js
10 / 0 // Infinity
```

NaN поглощает арифметические операции, которые не могут быть выполнены, например операция нат разными типами данных.

```js
5 - '5' // NaN
```

#### Boolean

**Boolean** - это логический тип данных, который может иметь два значения: **true** и **false**.

#### Undefined

**Undefined** - значение не определено, как правило при пустой инициализации переменной или при возвращении функций без ключевого слова return.

```js
let name;
console.log(name); // undefined
```

#### Объект

Набор данных, к которым можно обратиться по имени объекта через точку:

```js
let person = {
    name: 'Ivan',
    age: 10
}
console.log(person.name); // Ivan
```

Или через квадратные скобки по ключу:

```js
console.log(person['name']); // Ivan
```

Объекты задаются пользователям, но есть 2 типа данных, которые являются встроенными объектами:

- Array
- Function

##### Array

Массив это список значений, которые можно обратиться по индексу, он может хранить неограниченное количество значений.

```js
let arr = [1, 2, 3];
console.log(arr[0]); // 1
```

##### Function

Функция - имеет свои методы и свои свойства. Она может быть сохранена в переменную или передана в качестве значения другому объекту.

Например, встроенный методе toString() возвращает строковое представление функции.

```js
const add = function(a, b) {
    return a + b;
}

console.log(add.toString()); // function add(a, b) { return a + b; }
```

Встроенные методы объектов, могут быть переопределены.


#### Null

**Null** - примитив, который возвращает **object**. [Неустранимый баг JS](https://habr.com/ru/sandbox/200708/)

```js
let name = null;
console.log(typeof name); // object
```

Null часто используют в API и при работе с DOM, когда ожидают возврата объекта, но возвращается null.

#### Symbol

**Symbol** - это встроенный тип данных, который используется для создания уникальных идентификаторов. Даже при одинаковых значениях они будут различаться.

```js
let id1 = Symbol("test");
let id2 = Symbol("test");
console.log(id1 === id2); // false
```

Добавлен в ECMASCript 2015.

#### BigInt

Супербольшие целые числа. Они записываются как обычные целые, только в конце есть литера n:

```js
let bigNum = 9007199254740991n;
console.log(typeof bigNum); // bigint
```

Используются например для меток времени с микросекундами.

## 03. Lecture

### Приведение типов

Явное приведение типов:

```js
let number = 10;
let string = number.toString();
console.log(typeof string); // string
```

2. Неявное приведение

```js
let number = 10;
let string = '10';
console.log(number + string); // 1010
```

Арифметические операции кроме сложения всегда приводят типы к одному.

#### Булево приведение

При приведении к булевому типу, у следующих значений будет **false**:

- ""
- 0, -0, NaN
- null
- undefined
- false

При приведении к булевому типу, у следующих значений будет **true**:

- "Hello"
- 42
- {} - объекты
- [] - массивы
- function foo() { ... } - функции

Булево приведение происходит автоматически при условных операторах. 
Любой тип данных можно привести к булеву с помощью отрицания !. Но, чтобы небыло инвертированного значения, можно использовать два отрицания !!.

```js
let value = 1;
console.log(!!value); // true
```

### Равенства

**==** нестрогое равенство, при котором происходит приведение типов:

```js
let a = 10;
let b = "10";
console.log(a == b); // true
```

**===** строгое равенство, при котором не происходит приведение типов и происходит сравнение типов данных:

```js
let a = 10;
let b = "10";
console.log(a === b); // false
```

Движки JS приводят типы по умолчанию к числу, поэтому нестрогое сравнение пустых массивов false, а сравнение тех же массивов, но с отрицанием true.
А вот сравнение пустого массива и инвертированного, тоже true:

```js
[] == []; // false
![] == ![] // true
[] == ![]; // true
// Потому, что:
+[] // 0 - в соответствии с правилами приведения выше пустой массив это false => +false = 0
![] // false - в соответствии с таблицей [] = true => !true = false => +false = 0
// 0 == 0 is true
```

Непустые объекты или непустые массивы между собой сравниваются по ссылкам, не сравнивая значения. Но, если сравнить объект с примитивом, то объект приводится к конкретному примитиву.

### Сравнения

Когда сравнивются строки, то это происходит посимвольно, слева направо:

```js
let a = '43';
let b = '42';
console.log(a > b); // true
```

Такое сравнение называют - **лексикографическим**.

В JS нет строго сравнения типа (>>), как это есть у равенств. Поэтому, у сравнений происходит приведение типов:

Если при приведении строка не можыть быть преобразована в число, то возвращается NaN, который не может быть ни больше, ни меньше. Поэтому при сравнении c участием NaN, всегда возвращается false.

```js
let a = 10;
let b = '9cc';
console.log(a > b); // false
```

### Унарные операторы

- Унарный минус -a (отрицательное число)
- Унарный плюс +a (приведение к числу)
- Инкремент a++
- Декремент a--
- Конкатенация 'a'+'b'
- Побитовое отрицание ~a
- Побитовая инверсия (исключающее или) ^a
- Логическое отрицание !a
- Побитовое и &a
- Побитовое или |a
- Побитовый сдвиг влево <<a
- Побитовый сдвиг вправо >>a
- Оператор доступа к свойству объекта (точка) a.b
- Оператор разделения элементов или вычисления выражений ,
- Деструктуризация ...a
- void 
- typeof
- delete

### Проверки и приведение

Если переменная не путая строка "" и не ноль 0:

```js
let a = "John";
if (a) {
    console.log(a);
}
```

Чтобы привести число к строке можно сложить его с пустой строкой:

```js
let a = 10;
console.log("" + a); // "10"
```

Проверка в условии пустой ли массив:

```js
let a = [];
if (a.length) {
    console.log(a);
}
```

### Методы ввода

У объекта window есть методы ввода:

1. windows.alert()
2. window.prompt()
3. windows.confirm()

Т.е. window - это глобальная область видимости, то методы можно указывать без window.
Методы вызывают диалоговые окна в браузере, которые нельзя изменить и определить их положение.


### Условные конструкции

Условие - любое выражение возвращающее болевое значение (true или false). Если условие верно, то выполняется блок кода, иначе - нет. Если выражение условия возвращает не булевый тип, то он будет приведен к булевому.

false:

- ""
- 0, -0, NaN
- null
- undefined

true:

- любое другое значение

#### Тернарный оператор

```js
let a = 10;
let b = 20;
let c = a > b ? a : b;
console.log(c); // 20
```

#### Switch

```js
let a = 10;
switch (a) {
    case 10:
        console.log('10');
        break;
    case 20:
        console.log('20');
        break;
    default:
        console.log('default');
        break;
}
```

### Комментарии

```js
// однострочный комментарий
/* многострочный комментарий */
```

### Консоль браузера

CTRL+SHIFT+C - открыть инструменты разработчика
CTRL+SHIFT+I - открыть инспектор
CTRL+SHIFT+J - открыть консокль

## 05. Lecture

### Функции

#### Классификация по всплытию

- Анонимные
- Именованные

**Анонимные** функции используют **функциональное выражение**, где функция создается в момент выполнения данного выражения

```js
const sum = function(a, b) {
    return a + b;
};
```

**Именованные** функции используют **декларативное объявление**, где функция создается до основной компиляции кода, т.е. всплывает вверх. Поэтому такая функция может быть расположена в конце кода, а вызываться в начале.

```js
function sum(a, b) {
  return a + b;
}
```

#### По параметрам

- С обязательными параметрами
- С опциональными параметрами
- Без параметров

**Параметр функции** - это имя переменной, которое находится внутри скобок после имени функции.

**Аргумент функции** - это значение передаваемое параметру функции.

По возвращаемому значению:

- Возвращающие значение
- Не возвращающие значение (всегда возвращает undefined)

##### Опциональные параметры

Если задать функцию с одним параметром, а передать несколько, то ошибки не будет:

```js
square = x => x*x;
console.log(square(4, 'a', "string"));
// 16
```

JS-это не строгий язык, т.е. можно передать несколько параметров, но не все параметры будут использоваться. Если же передать меньше параметров, то В таком случае остальные параметры будут undefined.

Можно использовать данный побочный эффект в своих целях, например:

```js
const minus = (a, b) => {
    if (b === undefined) {
        return -a;
    }
    return a - b;
}

console.log(minus(10)); // -10
console.log(minus(10, 5)); // 5
```

В случае отсутствия значения параметра b, посчитается условие.

Если написать = (равно), после параметра, то данный параметр будет иметь значение по умолчанию:

```js
const minus = (a, b = 0) => {
    return a - b;
}
console.log(minus(10)); // 10
console.log(minus(10, 5)); // 5
```

#### По побочному эффекту

**Чистые функции**без побочных эффектов, как правило возвращают значение:

```js
const sum = (a, b) => {
    return a + b;
}
```

**Функции с явными побочными эффектами**:

```js
const sum = (a, b) => {
    console.log(a + b);
}
```

**Гибридные функции**:

```js
const sum = (a, b) => {
    console.log(a + b);
    return a + b;
}
```

### Стрелочные функции

В ES2015 появились стрелочные функции, в них убрано ключевое слово function:

```js
const sum = (a, b) => 
{
    return a + b;
}
```

Если параметр функции один, то можно убрать скобки:

```js
const square = a => 
{
    return a * a;
}
```

Но, если параметров нет вообще, то пустые скобки нужны:

```js
const square = () => 
{
    return 2 * 2;
}
```

Если функция возвращает одно выражение, то можно убрать фигурные скобки и ключевое слово return:

```js
const square = () => 2 * 2;
```

Можно устанавливать параметры по умолчанию:

```js
const sum = (a = 0, b = 0) => 
{
    return a + b;
}
```

### Стек вызовов

ОЗУ в JS делится на 3 вида памяти:

- Стековая память (stack memory) - специализированная область памяти, предназначенная для хранения стека вызовов
- Динамическая память (dynamic memory) - область памяти, которая может быть выделена и освобождена динамически во время выполнения программы
- Куча (heap) - область памяти, которая используется для хранения данных, которые не имеют фиксированного размера

Стековая память используется для хранения **стека вызовов**

Когда вызывается функция, она добавляется на вершину стека вызовов, если внутри нее выполняется еще функция, то следующая добавляется выше и т.д.
Когда функция завершает свое выполнение, она удаляется из вершины стека и так до тех пор пока стек не освободится.

Если вызовов функций слишком много, например в случае неправильной рекурсии, то стек будет переполнен и программа завершится с ошибкой: **Maximum call stack size exceeded**

### Область видимости

- Глобальная область видимости
- Область видимости функции
- Область видимости блока
- Вложенная область видимости

Глобальные переменные являются свойствами объекта window для браузера или объекта global для Node.js

### Лексическая область видимости

Лексическая область видимости - это область видимости, которая определяется местом объявления переменной. Она имеет следующие правила:

1. Глобальные переменные видны во всех областях видимости
2. Все переменные любых локальных областей видят глобальную область
3. Переменные и объекты в локальной области видят все вложенные в нее области видимости

### Замыкания

Возможность передавать функцию как значение, плюс факт того, что каждый раз при вызове одной и тоже функции внутри области видимости каждого вызова создаются независимые переменные, открывает побочный эффект - **замыкание**:

```js
function makeCounter() {
    let count = 0;
    return () => count++;
}
const counter = makeCounter();
console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2
```

Тут стрелочная функция которая имеет доступ к внешней переменной count называется замыканием.
Легко сравнить замыкание как функцию которая запускается в среде окружения, в которой уже задана некая переменная, причем эта среда активируется именно в том месте из которого запустили замыкание.

### Рекурсивная функция

Функция которая сама себя вызывает называется **рекурсивная функция**

```js
function power(base, exponent){
    if (exponent === 0) {
        return 1;
    } else {
        return base * power(base, exponent - 1);
    }
}
console.log(power(2, 3)); // 8
```

Данная реализации вычисления степени числа в три раза медленнее чем вариант с циклом.

### Именование функций

Функции должны начинаться с глагола и с маленькой буквы.

```js
function getSum(a, b) {
    return a + b;
}
```

Не нужно давать слишком длинные имена функциям, типа **getSumOfTwoNumbers**

### Браузерные события

У HTML-тегов есть атрибут onclick, который выполняет код при нажатии мышью по тегу.

Для того чтобы не писать длинные инструкции в атрибуте onclick, можно использовать функцию-обработчик:

```html
<button onclick="buy()">Buy</button>
<script>
    function buy() { 
        alert('Congratulations! You have bought a good!');
        alert('Good luck!'); 
    }
</script>
```

## 07. Lecture

### Циклы

Цикл - набор инструкций, который выполняется несколько итераций до удовлетворения условий выхода.

Тело цикла - набор инструкций.

Итерация - повторение тела цикла.

Условие выхода из цикла - условие, при котором цикл завершается.

#### Цикл while

Цикл с предусловием:

```js
let i = 0;
while (i < 10) {
    console.log(i);
    i++;
}
```

Очень удобен для бесконечных циклов.

#### Цикл do-while

Цикл с постусловием:

```js
let i = 0;
do {
    console.log(i);
    i++;
} while (i < 10);
```

Тело цикла проверяется на условие после выполнения. Следовательно минимум один раз цикл выполнится. Полезно например при вводе пароля, а потом его проверки до тех пор пока не введут верный.

#### Цикл for

Цикл с инициализацией, условием и инкрементом:

```js
for (let i = 0; i < 10; i++) {
    console.log(i);
}
```

Самый популярный цикл.

#### Прерывание цикла

Выход из цикла происходит:

- если условие выхода из цикла возвращает **false**
- если встречается инструкция **break**

Выход из итерации цикла, но не выход из цикла:

- при достижении конца тела цикла, если условие выхода из цикла возвращает **true**
- если встречается инструкция **continue**

### Массивы

Имя массива (переменная) - это указатель на область памяти объекта.
Чтобы случайно не переименовать или удалить имя массива делают константным, элементы массива все еще могут быть изменены:

```js
const arr = [1, 2, 3];
arr[0] = 10;
console.log(arr); // [10, 2, 3]
```

Элементы массива хранятся как значения свойств объекта. А индексы как ключи свойств объекта. Для доступа к элементам массива нельзя использовать точечную нотацию - индексы нужно обрамлять квадратными скобками.

Как и строки, массив имеет свойство **length** - количество элементов в массиве.

У массивов помимо встроенных свойств есть и методы.

#### push

Добавление одного или нескольких элементов в конец массива:

```js
const arr = [1, 2, 3];
arr.push(4, 5);
console.log(arr); // [1, 2, 3, 4, 5]
```

#### pop

Извлекает и удаляет последний элемент массива:

```js
сonst arr = [1, 2, 3];
arr.pop();
console.log(arr); // [1, 2]
```

#### shift

Удаляет первый элемент массива, сдвигая все остальные элементы влево:

```js
const arr = [1, 2, 3];
arr.shift();
console.log(arr); // [2, 3]
```

#### unshift

Добавляет один или несколько элементов в начало массива:

```js
const arr = [1, 2, 3];
arr.unshift(4, 5);
console.log(arr); // [4, 5, 1, 2, 3]
```

#### slice

Скопировать массив, путем копирования его имени переменной, создаст вторую ссылку на один и тот же массив. 

Копирует часть или весь массив:

```js
const arr = [1, 2, 3, 4];

const all = arr.slice();
console.log(all); // [1, 2, 3, 4]

const start = arr.slice(1);
console.log(start); // [2, 3, 4]

const overload = arr.slice(14);
console.log(overload); // []

const minus = arr.slice(-2);
console.log(minus); // [3, 4]

const range = arr.slice(1, 3);
console.log(range); // [2, 3]

const startMinus = arr.slice(1, -1);
console.log(startMinus); // [2, 3]
```

#### splice

Удаляет элементы массива:

```js
const arr = [1, 2, 3];
arr.splice(1, 2);
console.log(arr); // [1, 3]
```

#### indexOf

Метод возвращает индекс первого искомого вхождения (самого левого) элемента в массиве:

```js
const arr = [1, 2, 3];
console.log(arr.indexOf(2)); // 1
```

Если элемент не находится в массиве, то возвращается -1.

В методе можно указать второй параметр, который определяет с какого индекса начать поиск:

```js
const arr = [1, 2, 3];
console.log(arr.indexOf(2, 1)); // 1
```

#### map

Метод возвращает новый массив, состоящий из результатов вызова функции для каждого элемента массива:

```js
const arr = [1, 2, 3];
const newArr = arr.map(item => item * 2);
console.log(newArr); // [2, 4, 6]
```

#### Массивы с циклами

Цикло очень часть используется при работе с массивами:

```js
const arr = [1, 2, 3];

for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}
```

## 09. Lecture

### Объекты

Правила создания объектов:

1. Объекты объявляются с помощью ключевого слова **const**.
2. Определение (тело) объекта заключается в фигурных скобках.
3. Имя (ключ) свойства отделяется от значения свойства двоеточием.
4. Имя свойства может быть любым
5. Объект не может содержать дублирующиеся имена свойств.
6. Все свойства объекта объявляются через запятую.

```js
const user = {
    name: 'John',
    age: 30
};
```

#### Свойства объектов

Почти все типы данных в JS имеют свойства, за исключением null и underfined. Если обратиться к их свойствам, то получим ошибку:

```js
null.length; // TypeError: Cannot read properties of null (reading 'length')
null["length"]; // TypeError: Cannot read properties of null (reading 'length')
```

Имена свойств объектов это строки.

Обращение к свойству объекта через точку:

```js
const user = {
    name: 'John',
    age: 30
};

console.log(user.name); // John
console.log(user.age); // 30
```

В любой момент можно добавить новое свойство:

```js
const user = {
    name: 'John',
    age: 30
};

user.isAdmin = true;
console.log(user); // {name: "John", age: 30, isAdmin: true}
```

Свойства можно удалять:

```js
const user = {
    name: 'John',
    age: 30
};

delete user.age; // true
console.log(user); // {name: "John"}
```

При успешном удалении свойства возвращается true, иначе false (например защищенный объект браузера).

При указании переменных в качестве аргументов функции передаются только их значения, исходные переменные остаются нетронутыми. При указании имени объекта в качестве аргумента функции передает указатель на этот объект. Поэтому при изменении объекта внутри функции, изменится исходный объект. 

#### Методы объектов

Методы можно добавить в объект, путем присвоения функции как значения свойства:

```js
const user = {
    make: 'Audi',
    model: "A6",
    year: 2008,
    startEngine: function() {
        console.log('Engine is started');
    }
};

user.startEngine(); // Engine is started
```

#### this

Ключевое слово this означает текущий объект

#### for in

Цикл for in используется для перебора свойств объекта:

```js
const user = {
    name: 'John',
    age: 30
};

for (let key in user) {
    console.log(key); // name, age - вывод всех ключей свойств объекта
    console.log(user[key]); // John, 30 - вывод всех значений свойств объекта
}
```

#### Объект в массив

У массивов для преобразование его элементов и помещения результатов в новый массив можно использовать метод **map**. Но, у объектов такого метода нет, поэтому для преобразования объекта в массив необходимо использовать методы **Object.values** и **Object.keys**.

##### Object.keys

Для сохранения в массив ключей объекта используется метод **Object.keys**:

```js
const user = {
    name: 'John',
    age: 30
};

const array = Object.keys(user)); // ["name", "age"]
```

#### Object.values

Для сохранения в массив значений объекта используется метод **Object.values**:

```js
const user = {
    name: 'John',
    age: 30
};

const array = Object.values(user)); // ["John", 30]
```

#### Object.entries

Для сохранения в массив пар ключ-значение используется метод **Object.entries**:

```js
const user = {
    name: 'John',
    age: 30
};

const array = Object.entries(user); // [["name", "John"], ["age", 30]]
```

Можно было бы использовать для итерации for in по объекту без конвертации в массив, но в итерацию могут попасть наследуемые свойства объектов, включая прототип, при их наличии.

```js
const user = {
    name: 'John',
    age: 30
};

for (let key in user) {
    console.log(key); // name, age, toString, constructor
    console.log(user[key]); // John, 30, [object Object], [object Object]
}
```

Поэтому лучше преобразовывать в массив с помощью Object.keys, Object.values или Object.entries и далее работать с данными внутри массива.

### Глобальные объекты

В среде JS всегда есть один глобальный объект, от которого происходят остальные объекты.

Имя такого первичного объекта всегда зависит от среды исполнения JS:

- **window** в браузере
- **global** в Node.js
- **WorkerGlobalScope** в веб-воркере

Эти объекты не являются частью языка, они являются частью движка на котором ведется работа. Глобальный объект нужен для взаимодействия со средой в которой исполняется код.

Все методы и свойства глобального объекта доступны везде без указания window или global:

```js
console.log(this); // window
window.console.log(window); // window
console.log(global); // global
console.log(this === window); // true
console.log(this === global); // true
```

### Функции высшего порядка

Функции высшего порядка бывают двух типов:

1. Функции принимающие другие в функции в качестве своих аргументов. Функция аргумент называют callback функцией.
2. Функции возвращающие другие функции (замыкания)

Есть методы которые работают как функции высшего порядка:

#### filter

Предположим у нас есть массив объектов, где каждый объект содержит имя студунта и его оценку за экзамен:

```js
const students = [
    { name: 'John', score: 80 },
    { name: 'Jane', score: 90 },
    { name: 'Bob', score: 70 },
    { name: 'Alice', score: 85 },
    { name: 'Charlie', score: 95 },
    { name: 'Dave', score: 75 },
    { name: 'Eve', score: 85 },
    { name: 'Frank', score: 90 },
    { name: 'Grace', score: 80 },
    { name: 'Henry', score: 85 }
];
```

Мы хотим вывести только тех студентов, у которых оценка больше 80.

```js
const goodStudents = students.filter(student => student.score > 80);
```

Используя метод console.table() можно вывести массив в виде таблицы:

```js
console.table(goodStudents);
```

#### map

Предположим, что мы хотим не просто вывести студентов которые набрали 80 и более баллов, но мы хотим вывести вообще всех студентов. У тех кто прошел экзамен должно быть слово "passed", а у тех кто не прошел должно быть "Not passed":

```js
const result = students.map(student => {
    if (student.score >= 80) {
        return { name: student.name, score: student.score, result: "passed" };
    } else {
        return { name: student.name, score: student.score, result: "Not passed" };
    }
});

console.table(result);
```

В данном примере мы передаем методу map анонимную функцию, таким образом метод является функцией высшего порядка. 

#### reduce

Предположим, что мы хотим вывести общую сумму баллов всех студентов:

```js
const totalScore = students.reduce((acc, student) => acc + student.score, 0);
console.log(totalScore);
```

1. Первый аргумент в примере у метода reduce() это анонимная стрелочная функция обратного вызова. Данная функция принимает свои два аргумента:
    - acc - аккумулятор
    - student - текущий элемент (student) из массива students
2. Второй аргумент - 0, это первоначальное значение аккумулятора.
3. Третий аргумент - индекс текущего элемента.
4. Четвертый аргумент - сам массив.

Чаще всего в reduce() используется первые два аргумента.

#### some

Используется для поиска хотя бы одного нужного элемента в массиве. Например, чтобы выяснить есть ли среди студентов прошедшие практику:

```js
const hasPassed = students.some(student => student.score >= 80);
console.log(hasPassed); // true
```

Функция обратного вызова вызывается для каждого элемента итерации и если один из них возвращает true, то some() возвращает true и завершает работу на первом попавшемся элементе.

#### every

Обратный методу some(). В массиве все элементы должны соответствовать заданному условию. Например, чтобы выяснить все ли студенты прошли практику:

```js
const hasPassed = students.every(student => student.score >= 80);
console.log(hasPassed); // false
```

#### find

Возвращает первый элемент, который соответствует условию. В противном случае возвращает undefined:

```js
const student = students.find(student => student.score >= 80);
console.log(student); // { name: 'Jane', score: 90 }
```

Возвращает первое найденное вхождение. Позволяет искать неточное совпадение.

#### findIndex

Возвращает индекс первого элемента, который соответствует условию. В противном случае возвращает -1:

```js
const index = students.findIndex(student => student.score >= 80);
console.log(index); // 1
```

Возвращает индекс первого вхождения. Позволяет искать неточное совпадение.

### Деструктуризация

Позволяет сохранять значения из объекта или массива в отдельные переменные:

```js
const numbers = [1, 2, 3];
const [a, b, c] = numbers;
console.log(a); // 1
console.log(b); // 2
console.log(c); // 3
```

```js
const person = { name: 'John', age: 30, city: 'New York' };
const { name, age, city } = person;
console.log(name); // John
console.log(age); // 30
console.log(city); // New York
```

Название переменных должно совпадать с именами свойств объекта. Но, можно переименовать любой свойство в деструктуризации:

```js
const person = { name: 'John', age: 30, city: 'New York' };
const { name: userName, age: userAge, city: userCity } = person;
console.log(userName); // John
console.log(userAge); // 30
console.log(userCity); // New York
```


